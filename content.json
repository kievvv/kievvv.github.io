{"meta":{"title":"iullius’ Blog","subtitle":"","description":"Personal Blog","author":"iullius","url":"https://kievvv.github.io","root":"/"},"pages":[{"title":"","date":"2023-08-24T15:55:53.633Z","updated":"2023-08-24T15:55:53.633Z","comments":false,"path":"about/index.html","permalink":"https://kievvv.github.io/about/index.html","excerpt":"","text":"博客内容包括个人生活的方方面面，所有细碎琐事、灵光一闪。 一处个人向的自留地。 不知是小径的何处分岔引你走入我的花园？ The blog contains all aspects of my life, all the little things, the sparks of inspiration. A self-oriented private plot. I wonder which fork of the paths lead you into my garden? このブログには、私の人生のあらゆる側面、あらゆるささいなこと、インスピレーションの火花が含まれている。 自己中心的なプライベートプロット。 あなたを私の庭に導くのはどの分岐点だろうか？ บล็อกประกอบด้วยทุกแง่มุมในชีวิตของฉัน สิ่งเล็กๆ น้อยๆ ทั้งหมด จุดประกายแห่งแรงบันดาลใจ พล็อตส่วนตัวที่มุ่งเน้นตนเอง ฉันสงสัยว่าทางแยกใดที่นำคุณไปสู่สวนของฉัน? Diarii omnes vitae meae rationes continet, omnes res parvas, inspirationis scintillas. A privata machinatione auto-orientatur. Miror quae te in hortum meum viarum ducunt?"},{"title":"所有分类","date":"2023-07-19T14:10:37.736Z","updated":"2023-07-19T14:10:37.736Z","comments":true,"path":"categories/index.html","permalink":"https://kievvv.github.io/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-07-19T14:14:55.627Z","updated":"2023-07-19T14:14:55.627Z","comments":true,"path":"friends/index.html","permalink":"https://kievvv.github.io/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-07-19T14:10:57.864Z","updated":"2023-07-19T14:10:57.864Z","comments":true,"path":"tags/index.html","permalink":"https://kievvv.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-12-19T13:30:49.310Z","updated":"2023-12-19T13:30:49.310Z","comments":false,"path":"moments/index.html","permalink":"https://kievvv.github.io/moments/index.html","excerpt":"","text":"12.19 今天是一个好日子，值得狠狠祝贺！ 12.11 看完暗黑 好，但这样的叙述方式让我很无助，需要借助关系图和流程图来理解 12.5 我游荡了一会 倒数 倒数 睁开眼 没有一声枪响 从背后最清澈的海底拽出一颗苹果 妈妈 向上 再向上 向往 向上 全部给你 我吞下一片失忆 童年睡去数千个钟 太阳下 烹煮人的余味 煎煮 找碴 天空下起漫天石子 向下 石子向下 单手向上 向往 生命向下 从背后最疼痛的浓汤里 有一颗苹果 都给你 吃了长大 吐沫也芬芳 这是一门设计 不带一丝犹豫 这是一场命定 不在树上 砸不出道理 握手里 伤害你 生来有一颗苹果 美味不得自知 得品 自洽 回头梳洗 吃 完了清醒 原是我生而有的一颗苹果 背后流的一条果酱 12.2 有时候一个选择会导致之后的好多好多个选择，虽然选择的时候是经过慎重思考的，是局部最优的，但贪心算法往往没办法达到全局最优。 总感觉选着选着，选项会越来越少。不想把路越走越窄。 12.1 一周岁生日快乐，我的好帮手！ 2023.11.30 spotify年度总结 2023.11.27 我暂且称这一天是2023年最幸福的一天 回到ss的下午金光灿灿，这是太普通太普通的一天了，我在熟悉而陌生的校道上来回走，说得每句话都以”那时候“开头，像坐了时光机一样，穿越回高中年代，体验了最稀松平常的一个下午。 但也是那时候我清楚地意识到：自己是一个局外人。 很美好的事情曾经在那里发生过，是因为那些人和事情让那个地方变得美好，所有的美好都没有消失，但它们已经不在那个地方了。所有曾经发生过的美好永远在记忆里鲜活，它们一直伴随着我，不管我去到哪里。 Isaac Gracie 高二的时候我第一次听All my mind(live)，我说那是我听过最好的一首live。那时候没有多想。 而我听到歌手本人现场演唱的时刻，距离我高二时第一次在耳机里听到同一首歌的时刻，二者的物理距离只有约20多分钟车程。但这其中我已经经历了太多太多。 刚进入场地，Isaac刚好出场，熟悉的All my mind旋律响起，黑暗中，没有人看见我的泪光，也没有人看见我的会心一笑。 世事难料。 2023.11.20 某一时刻的经历或见闻，不一定在当下产生太大影响，有时，是在将来的某一瞬间突然回想起过去的某一特定时刻，似曾相识、似有预兆，时间的流逝似乎被更大的维度所包含、概括。 2023.11.18 可是真的很冷真的很冷 2023.11.11 久违的出游 2023.11.10:16 - 子进程用英文怎么说？ - Forbidden City. 2023.11.10:9 今日标题： 《OpenAI被黑客攻击后，我得了空心病》 2023.11.10:0 突然发现一个事实： 我的椅背是我衣柜的Cache! 2023.11.7:23 昨晚发现的一批新歌真的很顶！ 今天的余记 2023.11.6:21 《Sex Education》s4完结，一部剧包含了太多kpi，不知道想讲个什么故事。 2023.11.6:1 新增了一个Moments页面，以后就把这里当朋友圈发了，记录杂七杂八的生活。 2023.11.6:0 this is test for my Moments!"}],"posts":[{"title":"2023年终总结","slug":"010review_of_2023","date":"2023-12-30T18:48:20.000Z","updated":"2023-12-31T09:16:36.535Z","comments":true,"path":"2023/12/31/010review_of_2023/","link":"","permalink":"https://kievvv.github.io/2023/12/31/010review_of_2023/","excerpt":"","text":"2023年终总结能够选择，是一项莫大的权力。2023年，我的可选项比以往来说都要多。至于我怎么选的，请看VCR： Jan.买相机了 跟同学爬楼 去年春节，祝各位奉旨发财！ Feb.海边 第一次公费比赛 Mar.久违，香港 HKU 草间弥生展 弥敦道 年度最佳风光照 龚琳娜老师 Apr.南头古城 计组… May.烫头了 壮壮妈 演出-《龙舌兰》 国赛体验 Jun.特种兵-长沙 年度最佳甜品 过生日 年度最佳晚霞 年度印象最深刻的演出-《Happy Now?》 公费旅行-桂林 每天都是阴雨 Jul.后期末生活 深圳湾 欢乐谷-雪域雄鹰 西湾红树林 蛇口 第一次做勾线摆件 暑假回家前吃顿好的！ 平云山-露营 在山上半夜被热得受不了，帐篷里都是小虫子 Aug.在家 我的comfort zone 最后的卷毛 跟家人一起 假期消遣 在湛江 杨千嬅演唱会 山顶的朋友 Sep.开学了 演出-《What was I made for》 Oct.最五味杂陈的一个月 国庆去玩了：香港-澳门-顺德 又来了，香港 故宫博物馆-互赠生日卡 久违，澳门 又来了，顺德 月初开心的事情是旅行和见家人，月末开心的事情是和雅思分手 中间闹心的部分就不回忆了.. Nov.舞台-《胡桃夹子》 盐田千春展 2023年11月27日，年度最开心的一天 以评委身份回母校，it means a lot! 和高中班主任jw，一起回忆了一些我的PTSD，发现很多事情其实已经释怀了 Isaac Gracie-演唱会 Dec.结项了，真的很开心！ 2023年，普普通通的活着，如果突然想做什么事，能做的就做了。身边的人一直在，同时也认识了很多新朋友，解锁了很多新体验。 新年愿望是：希望家人身体健康，希望身边的人和自己人生顺利，希望世界上所有猫猫狗狗被善良对待，希望世界和平。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://kievvv.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"Life","slug":"Life","permalink":"https://kievvv.github.io/tags/Life/"}]},{"title":"CKKS与BFV算法的图片同态加密、密态检索与同态解密","slug":"009CKKS_BFV_FHE","date":"2023-12-11T11:57:43.000Z","updated":"2023-12-11T12:39:27.666Z","comments":true,"path":"2023/12/11/009CKKS_BFV_FHE/","link":"","permalink":"https://kievvv.github.io/2023/12/11/009CKKS_BFV_FHE/","excerpt":"","text":"CKKS与BFV算法的图片同态加密、密态检索与同态解密本文基于TenSEAL库实现，是《数据安全与隐私保护》课程Project，由于是课程作业性质，这里的重点放在了运行效率的比较，没有将server端和client段做严谨区分，context的公私钥分离也略显潦草。本文的源码可以在这里找到，仅供参考，若想深入学习请查看官方文档。 如果不了解同态加密，以下是一些供参考的文章： 同态加密Homomorphic Encryption介绍 全同态加密算法深入解析 同态加密详解 这是同态加密实现的经典逻辑框图： 以下是正文： 介绍全同态加密（Fully Homomorphic Encryption，FHE）是一种密码学技术，允许在加密状态下执行计算操作，而无需解密数据。本实验选用两种常见的全同态加密方案，即CKKS（Cheon-Kim-Kim-Song）和BFV（Brakerski-Vaikuntanathan-Gentry）。 CKKS（Cheon-Kim-Kim-Song）CKKS 是一种基于环的全同态加密方案。环是一种数学结构，允许在加密域上进行多项式运算。CKKS 方案主要用于处理实数和复数，因此在机器学习和数据分析等领域中得到广泛应用。 主要特点： 支持加法和乘法运算。 适用于实数和复数的加密计算。 允许动态调整安全参数以平衡安全性和性能。 BFV（Brakerski-Vaikuntanathan-Gentry）BFV 是一种基于多项式环的全同态加密方案。它是 Gentry 的经典全同态加密方案的改进版本，旨在提高效率和应用范围。 主要特点： 支持加法、乘法和混合运算（同时进行加法和乘法）。 允许在多项式环上进行计算。 提供更高的效率和灵活性，适用于更广泛的应用场景。 TenSEALTenSEAL是一个基于 Microsoft Research 的 Simple Encrypted Arithmetic Library（SEAL）的同态加密库。它是专为支持深度学习任务中的同态加密操作而设计的，与 PySyft 框架集成，以支持联邦学习和安全多方计算。 主要特点和功能： SEAL 基础： TenSEAL建立在 Microsoft Research 提供的 SEAL 库之上，该库专注于提供同态加密的基础原语。这使得 TenSEAL 可以充分利用 SEAL 的强大功能，同时为用户提供更高层次的接口。 同态加密支持： TenSEAL 提供了同态加密的功能，使得用户可以在加密状态下执行计算，而无需解密敏感数据。 PySyft 集成： TenSEAL 与 PySyft 框架集成，支持联邦学习和安全多方计算。这使得 TenSEAL 能够与 PySyft 中的其他工具和库协同工作，实现更广泛的隐私保护应用。 CKKS 和 BFV 算法： TenSEAL 实现了两种常见的同态加密算法，即 CKKS 和 BFV。这两种算法分别适用于不同的使用场景，CKKS 用于处理实数和复数，而 BFV 用于通用的多项式环上的计算。 实验内容从开源的库中选择一个开源库验证比较不同全同态加密算法的效率。 场景设置：1）选取M张64*64（或更大的图片）加密存储于数据库 or 文件中；2） 对于一张查询图片，在密态下跟数据库 or文件中加密图像进行匹配。 要求：1） report实验环境（如，操作系统，CPU型号，内存等）2） report同一开源库中不同FHE算法的计算效率（多测几次求平均）3） 总结分析所测试算法的优劣 实验环境 操作系统 CPU型号 内存 Linux Ubuntu 22.04.3 AMD Ryzen 7 5800H(16 CPUs) 16Gb 本实验的图片数据集使用CelebA数据集，选取前100张做加密测试。 实验流程与代码实现本实验选用基于python的TenSEAL库，实现了CKKS和BFV两种全同态加密算法对批量图片文件的加密、解密、存储和密态检索，同时本实验进行多次测试，比较了同一同态加密库不同算法的加密、解密和检索效率，本部分主要汇报实验和代码实现流程，因为两算法实现流程类似，因此以CKKS为例子进行详细分析。 主函数本代码需包含以下库： import tenseal as ts import sqlite3 from PIL import Image import numpy as np import os from time import time 本代码主函数如下： if __name__ == &quot;__main__&quot;: # 定义 CKKS context，并分离公私钥 context = ts.context( ts.SCHEME_TYPE.CKKS, poly_modulus_degree=8192, coeff_mod_bit_sizes=[60, 40, 40, 60] ) context.generate_galois_keys() context.global_scale = 2**40 # 设置全局缩放因子 ckks_secret_key = context.secret_key() context.make_context_public() # 创建或连接到 SQLite 数据库 conn = sqlite3.connect(&quot;ckks_encrypted_images.db&quot;) cursor = conn.cursor() # 创建表以存储加密向量 cursor.execute(&#39;&#39;&#39; CREATE TABLE IF NOT EXISTS EncryptedImages ( id INTEGER PRIMARY KEY AUTOINCREMENT, encrypted_red BLOB, encrypted_green BLOB, encrypted_blue BLOB ) &#39;&#39;&#39;) t_start_add = time() # 加密并将每个图像存储到数据库中 restored_image() t_end_add = time() print(&quot;ckks同态加密用时: &#123;&#125; ms&quot;.format((t_end_add - t_start_add) * 1000)) # 提交更改并关闭连接 conn.commit() conn.close() print(&quot;加密存储完成&quot;) # 读取要查询的图片并加密 query_image_path = &quot;./data/5.jpg&quot; encrypted_query_red, encrypted_query_green, encrypted_query_blue = encrypt_image(query_image_path, context, ts.SCHEME_TYPE.CKKS) # 连接到 SQLite 数据库 conn = sqlite3.connect(&quot;ckks_encrypted_images.db&quot;) cursor = conn.cursor() # 查询数据库以获取加密向量 cursor.execute(&quot;SELECT encrypted_red, encrypted_green, encrypted_blue FROM EncryptedImages&quot;) rows = cursor.fetchall() # 计算余弦相似度并排序 similarities = [] for i, row in enumerate(rows, start=1): # 反序列化数据库中的密文向量 serialized_red, serialized_green, serialized_blue = row encrypted_red = ts.ckks_vector_from(context, serialized_red) encrypted_green = ts.ckks_vector_from(context, serialized_green) encrypted_blue = ts.ckks_vector_from(context, serialized_blue) # 计算余弦相似度 similarity_red = calculate_cosine_similarity(encrypted_query_red, encrypted_red) similarity_green = calculate_cosine_similarity(encrypted_query_green, encrypted_green) similarity_blue = calculate_cosine_similarity(encrypted_query_blue, encrypted_blue) # 将三个通道的相似度取平均作为整体相似度 average_similarity = (similarity_red + similarity_green + similarity_blue) / 3 similarities.append((i, average_similarity)) print(f&quot;计算第&#123;i&#125;张图片的相似度&quot;) # 对相似度进行排序 print(&quot;相似度排序中...&quot;) similarities.sort(key=lambda x: abs(x[1] - 1)) # 输出相似度最接近1的图像编号和相似度值 print(similarities) closest_result = similarities[0] print(f&quot;最相似的图片为: &#123;closest_result[0]&#125;, 二者余弦相似度为: &#123;closest_result[1]&#125;&quot;) # 关闭数据库连接 conn.close() # 解密并还原图像 decrypt_all_image() 主函数的每一个关键步骤均在代码中以注释说明，其流程可总结如下： 定义 CKKS context，并分离公私钥； 创建并连接到 SQLite 数据库，创建表； 将图片数据进行同态加密，并存储到数据库中； 读取要查询的图片； 从数据库中获取加密数据，反序列化，并与查询图片计算余弦相似度，选取相似度最高的图片，输出； 将数据库中的所有加密数据全部解密，并还原为jpg图片。 context是TenSEAL库实现同态加密的核心参数，在加密前要根据加密算法对context进行相应初始化，同时需要生成galois_keys、global_scale等特定参数。在默认生成的context中是同时包含公钥和私钥的，为了代码在现实中有使用价值，需要对context进行公私钥分离，使用分离了私钥只含有公钥的context加密，而使用单独保管的私钥进行解密和密文检索等工作。 本实验使用轻量级的SQLite数据库来存储加密后的密文数据，为将CKKSVector或BFVVector对象存入数据库，需要调用该类的序列化方法，相应地要对数据库中的数据进行解密或密文检索，需要使用反序列化方法后再进行后续操作。 图像加密存储本实验的图像加密存储分为图像加密和图像存储两部分，在代码实现中也分为restored_image()和encrypt_image两个函数，restored_image函数中会调用encrypt_image函数，restored_image函数实现如下： def restored_image(): # 加密并将每个图像存储到数据库中 for i in range(1, 101): # 读取图片 image_path = f&quot;./data/&#123;i&#125;.jpg&quot; values_red, values_green, values_blue = encrypt_image(image_path, context, ts.SCHEME_TYPE.CKKS) # 将加密向量的值序列化 serialized_red = values_red.serialize() serialized_green = values_green.serialize() serialized_blue = values_blue.serialize() # 将序列化的加密向量插入到数据库中 cursor.execute(&#39;&#39;&#39; INSERT OR REPLACE INTO EncryptedImages (id, encrypted_red, encrypted_green, encrypted_blue) VALUES (?, ?, ?, ?) &#39;&#39;&#39;, (i, sqlite3.Binary(serialized_red), sqlite3.Binary(serialized_green), sqlite3.Binary(serialized_blue))) print(f&quot;加密存储第&#123;i&#125;张图片&quot;) 这一函数首先从.&#x2F;data文件夹中读取100张图片（本实验中图片数M取100），调用encrypt_image函数得到R、G、B三个加密数据列表，调用序列化方法，然后将加密数据按R、G、B三通道分别存入数据库中。 encrypt_image函数实现如下： def encrypt_image(image_path, context_public, encryption_algorithm): image = Image.open(image_path) image = image.resize((64, 64)) # 调整大小 image_array = np.array(image) # 分离每个通道 red_channel = image_array[:, :, 0].flatten().tolist() green_channel = image_array[:, :, 1].flatten().tolist() blue_channel = image_array[:, :, 2].flatten().tolist() # 加密每个通道，使用公钥 encrypted_red = ts.ckks_vector(context_public, red_channel) encrypted_green = ts.ckks_vector(context_public, green_channel) encrypted_blue = ts.ckks_vector(context_public, blue_channel) return encrypted_red, encrypted_green, encrypted_blue 这一函数获取图片路径后，读取图片并调整图片分辨率（本实验图片分辨率取为64*64），将图片分为R、G、B三通道，分别调用TenSEAL加密方法ts.ckks_vector（或ts.bfv_vector）使用公钥进行加密。 图像检索在图像加密存储到数据库之后，下一个任务是给定图像，在加密数据中进行图像检索，这一部分代码的核心逻辑在主函数中实现。 首先要读取希望查询的图片，并调用一次同态加密算法获取查询图片的密文： if __name__ == &quot;__main__&quot;: # ... query_image_path = &quot;./data/5.jpg&quot; encrypted_query_red, encrypted_query_green, encrypted_query_blue = encrypt_image(query_image_path, context, ts.SCHEME_TYPE.CKKS) # ... 图像检索核心逻辑如下： if __name__ == &quot;__main__&quot;: # ... # 计算余弦相似度并排序 similarities = [] for i, row in enumerate(rows, start=1): # 反序列化数据库中的密文向量 serialized_red, serialized_green, serialized_blue = row encrypted_red = ts.ckks_vector_from(context, serialized_red) encrypted_green = ts.ckks_vector_from(context, serialized_green) encrypted_blue = ts.ckks_vector_from(context, serialized_blue) # 计算余弦相似度 similarity_red = calculate_cosine_similarity(encrypted_query_red, encrypted_red) similarity_green = calculate_cosine_similarity(encrypted_query_green, encrypted_green) similarity_blue = calculate_cosine_similarity(encrypted_query_blue, encrypted_blue) # 将三个通道的相似度取平均作为整体相似度 average_similarity = (similarity_red + similarity_green + similarity_blue) / 3 similarities.append((i, average_similarity)) print(f&quot;计算第&#123;i&#125;张图片的相似度&quot;) # 对相似度进行排序 print(&quot;相似度排序中...&quot;) similarities.sort(key=lambda x: abs(x[1] - 1)) # 输出相似度最接近1的图像编号和相似度值 print(similarities) closest_result = similarities[0] print(f&quot;最相似的图片为: &#123;closest_result[0]&#125;, 二者余弦相似度为: &#123;closest_result[1]&#125;&quot;) # ... 如上所说，首先要对数据库中的数据进行反序列化以获得密文，然后调用calculate_cosine_similarity函数计算三通道的余弦相似度，将三通道的平均余弦相似度作为匹配标准，因为同态加密往往涉及浮点数运算，密文之间无无法做精确比较，因此这里认为平均余弦相似度最接近1图片即为要匹配的图片，最后输出匹配图片的序号。 这里匹配的核心是余弦相似度的计算，其公式为：$\\text{Similarity}(\\mathbf{A}, \\mathbf{B}) &#x3D; \\frac{\\sum_{i&#x3D;1}^{n} A_i \\cdot B_i}{\\sqrt{\\sum_{i&#x3D;1}^{n} A_i^2} \\cdot \\sqrt{\\sum_{i&#x3D;1}^{n} B_i^2}}$。 由于CKKSVector和BFVVector类的成员函数差异，在两个算法中，calculate_cosine_similarity函数的实现略有不同，如下： def calculate_cosine_similarity(vector1, vector2): # 分子（ckks） numerator = vector1.dot(vector2) numerator = numerator.pow(2) # 如果是bfv算法，分子的计算方法替换为下面两行 # numerator = vector1.dot(vector2) # numerator = numerator * numerator # 分母 denominator1 = vector1.dot(vector1) denominator2 = vector2.dot(vector2) denominator = denominator1 * denominator2 numerator = numerator.decrypt(ckks_secret_key) denominator = denominator.decrypt(ckks_secret_key) numerator_array = np.array(numerator) denominator_array = np.array(denominator) similarity = np.sum(numerator_array) / np.sum(denominator_array) return similarity 图像解密与还原为了验证全此处全同态加密的有效性，这部分对加密数据进行解密和还原，这一部分实现封装在decrypt_all_image中，函数如下： def decrypt_all_image(): # 创建或连接到 SQLite 数据库 conn = sqlite3.connect(&quot;bfv_encrypted_images.db&quot;) cursor = conn.cursor() # 查询数据库以获取加密向量 cursor.execute(&quot;SELECT encrypted_red, encrypted_green, encrypted_blue FROM EncryptedImages&quot;) rows = cursor.fetchall() # 创建保存目录 save_directory = &quot;./restored_images/&quot; os.makedirs(save_directory, exist_ok=True) # 解密并还原每个图像 for i, row in enumerate(rows, start=1): # 反序列化加密向量的值 serialized_red, serialized_green, serialized_blue = row # 反序列化加密向量 deserialized_red = ts.bfv_vector_from(context, serialized_red) deserialized_green = ts.bfv_vector_from(context, serialized_green) deserialized_blue = ts.bfv_vector_from(context, serialized_blue) # 使用私钥解密 decrypted_red = deserialized_red.decrypt(secret_key = bfv_secret_key) decrypted_green = deserialized_green.decrypt(secret_key = bfv_secret_key) decrypted_blue = deserialized_blue.decrypt(secret_key = bfv_secret_key) # 转换为 NumPy 数组 red_channel = np.array(decrypted_red) green_channel = np.array(decrypted_green) blue_channel = np.array(decrypted_blue) # 由于解密后是一维数组，需要重新调整为图像形状 shape = (int(len(decrypted_red) ** 0.5), int(len(decrypted_red) ** 0.5), 1) red_channel = red_channel.reshape(shape) green_channel = green_channel.reshape(shape) blue_channel = blue_channel.reshape(shape) # 合并通道并进行值的缩放和截断 restored_image_array = np.clip(np.concatenate([red_channel, green_channel, blue_channel], axis=2), 0, 255).astype(&#39;uint8&#39;) # 将还原后的图像数组转换为图像对象 restored_image = Image.fromarray(restored_image_array.astype(&#39;uint8&#39;)) # 保存还原后的图像为 JPG 文件 restored_image.save(f&quot;./restored_images/&#123;i&#125;_restored.jpg&quot;) print(f&quot;解密还原第&#123;i&#125;张图片&quot;) conn.close() print(&quot;解密完成&quot;) 其中关键步骤均用注释进行说明，需要注意的部分主要是：调用反序列化方法、使用私钥解密、图片形状reshape。 以上均基于CKKS同态加密算法进行分析，如果要换用BFV算法，需要更改的地方主要有： 数据库名称：conn = sqlite3.connect(&quot;bfv_encrypted_images.db&quot;) context初始化： # 定义 BFV context，并分离公私钥 context = ts.context(ts.SCHEME_TYPE.BFV,poly_modulus_degree=8192,plain_modulus=1032193) context.global_scale = 2**20 context.generate_galois_keys() bfv_secret_key = context.secret_key() context.make_context_public() 加密方法： encrypted_red = ts.bfv_vector(context, red_channel) encrypted_green = ts.bfv_vector(context, green_channel) encrypted_blue = ts.bfv_vector(context, blue_channel) 反序列化方法： serialized_red, serialized_green, serialized_blue = row encrypted_red = ts.bfv_vector_from(context, serialized_red) encrypted_green = ts.bfv_vector_from(context, serialized_green) encrypted_blue = ts.bfv_vector_from(context, serialized_blue) calculate_cosine_similarity函数中分子计算方法，上文已做解释。 此外还有一些相应的变量名称需要更换，不再赘述。 实验结果和效率比较为保证算法比较的客观性，本实验实现两种算法的代码流程基本一致，影响算法复杂度的两个关键参数poly_modulus_degree和global_scale也保持一致，设置为：context.poly_modulus_degree=8192、context.global_scale = 2**40。在实验数据上，统一使用了CelebA人脸数据集的前100张图片作为测试数据，在读取图片时统一将图片分辨率更改为64*64。 下面对CKKS和BFV两个算法的三个测试维度（同态加密、密态搜索、同态解密）分别测试用时，测试过程截图如下： 每次执行算法的用时都略有不同，这里对每种算法的每项任务的平均用时取3次测试结果的平均值，以便进行效率比较和分析，测试结果如下： 同态加密用时： 测试次数\\算法 CKKS BFV 1 6877ms 7896ms 2 6957ms 7337ms 3 6699ms 7398ms 平均 6844.3ms 7543.7ms 密态搜索用时： 测试次数\\算法 CKKS BFV 1 21818ms 64848ms 2 20206ms 64673ms 3 20475ms 65213ms 平均 20833ms 64911.3ms 同态解密用时： 测试次数\\算法 CKKS BFV 1 3255ms 4545ms 2 3341ms 4044ms 3 3449ms 4185ms 平均 3348.3ms 4258ms 上述测试结果，从不同任务的角度来看，密态搜索任务的用时是最长的，而密态解密的用时最短；从算法的角度来看，三项任务中CKKS算法的运行速度均比BFV算法快，CKKS算法在同态加密平均比BFV算法快10.2%，在密态搜索中快211.6%，在同态解密中快27.7%，整体上看，CKKS算法效率始终高于BFV算法，效率优势在密态搜索任务上体现得非常显著。 分析与总结在本次实验从不同的任务角度对比了CKKS和BFV两种同态加密算法在图像处理任务中的性能。结合实验过程和结果，做出以下分析与总结： 在实验环境方面，我在Window宿主系统使用wsl2的Linux Ubuntu操作系统（22.04.3）、CPU型号为AMD Ryzen 7 5800H（16核）以及16 Gb运行内存下进行了TenSEAL库中CKKS和BFV两种同态加密算法执行同态加密、密态检索、同态解密三个任务的效率测试。 在任务性能方面，我针对同一开源库中的CKKS和BFV两种同态加密算法进行了多次测试，以获取更为稳定的平均性能数据。在图像加密存储任务中，可以观察到CKKS算法相对于BFV算法，平均快了10.2%。在密态搜索任务中，CKKS算法表现出更为显著的优势，其运行速度相比BFV算法平均快了211.6%。而在同态解密任务中，CKKS算法仍然保持较高的效率，平均快了27.7%。 从不同算法的角度看，CKKS算法在所有测试任务中都表现出了更高的效率。在密态搜索任务中，其性能提升尤为显著，这可能归因于CKKS算法对多项式环上计算的适用性以及其更高的并行性。相较之下，BFV算法在同态加密任务中的性能相对较低，可能由于其更为复杂的计算模型导致的。 此外，在不同任务中，我们还观察到密态搜索任务的耗时相对较长，而密态解密任务的用时最短。这可以解释为，在同态加密中，解密操作相对简单，而密文搜索可能涉及到更多的计算，导致相对较高的执行时间。但是，更短的时间不能与算法的优劣直接关联，由于BFV更复杂的计算机制，虽然效率偏低，但可能会会同态加密的安全性或其他方面有提升，这里不做展开。 综上所述，从测试结果中可以得出结论，CKKS算法在多项测试任务中表现出更高的性能和效率，而BFV算法相对较慢。在选择同态加密算法时，需要根据具体应用场景和任务需求来权衡算法的优劣，以确保系统在安全性和性能之间取得合适的平衡。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://kievvv.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Cryptography","slug":"Cryptography","permalink":"https://kievvv.github.io/tags/Cryptography/"},{"name":"PrivacyProtection","slug":"PrivacyProtection","permalink":"https://kievvv.github.io/tags/PrivacyProtection/"}]},{"title":"Bitcoin: A Peer-to-Peer Electronic Cash System-论文随记","slug":"008review-Bitcoin","date":"2023-12-05T15:49:00.000Z","updated":"2023-12-05T15:50:01.705Z","comments":true,"path":"2023/12/05/008review-Bitcoin/","link":"","permalink":"https://kievvv.github.io/2023/12/05/008review-Bitcoin/","excerpt":"","text":"互联网上的商务活动几乎完全依赖于作为值得信赖的第三方的金融机构来处理电子支付。尽管这个系统对大多数交易来说运作良好，但仍然存在基于信任的模型固有的弱点。由于金融机构无法避免调解争端，完全不可逆转的交易并非真正可能。调解的成本增加了交易成本，限制了最小实际交易规模，并削减了小额随意交易的可能性。同时，无法进行不可逆转支付的能力丧失也带来了更广泛的代价。由于存在撤销的可能性，对信任的需求扩散开来。商家必须对其客户保持警惕，要求提供比他们实际需要的更多信息。一定比例的欺诈被接受为不可避免。这些成本和支付的不确定性可以通过使用实物货币进行面对面交易来避免，但在没有值得信赖的第三方的情况下，通过通信渠道进行支付的机制并不存在。 需要一种基于加密证明而不是信任的电子支付系统，使任何两个愿意的当事方能够直接进行交易，而无需信赖第三方。计算上不可逆转的交易将保护卖方免受欺诈，而常规的担保机制可以轻松实施以保护买方。 在这篇论文中，作者提出了使用点对点分布式时间戳服务器解决双花问题的方案，以生成交易的时间顺序的计算证明。只要诚实的节点总体上控制的CPU算力资源多于任何一组攻击节点的合作，该系统就是安全的。 交易在区块链中，电子货币就是数字签名链，数字签名链就是电子货币。 所有者转移货币给下一个所有者的方式为：将“前一个交易的哈希值+下一个所有者的公钥”进行数字签名，将该数字签名添加到货币末尾。 双花问题上面的方法可以保证来源的可信，但是没有办法保证该货币只被使用了一次。在现实生活中，一块钱纸币花出去就没了，但比特币是没有实体的，它只是一个哈希签名，如果我使用前一个哈希值+不同人的公钥进行签名，那一个比特币就可以向不同人使用多次。如果一百块可以用两次，那它事实上就变成两百块了，这显然是不科学的，这就是双花问题。比特币解决双花问题的方法就是引入时间戳，将时间纳入哈希签名中，经过验证后，只有交易时间最早的那笔交易是有效的。 纳入时间戳之后，事实上形成了一个连续性的系统，每个哈希都包含了上一个哈希的信息，如果系统中有恶意者想插入伪造的区块，那么他将要重做插入位置后面的所有块，他才能得到信任。 Proof-of-WorkProof-of-Work（工作量证明）是在一个区块公布之前，号召所有节点来解决的一个数学难题。解决这个数学难题计算量非常大，非常耗费CPU算力。这个数学难题有且只有唯一的答案，这个答案将会作为这个区块的一部分。之所以需要Proof-of-Work，是为建立一个基于数学的信任机制，假定大多数的节点（的计算资源）都是可信的，那么解决同一个难题，肯定是计算资源多的更快计算出答案（！暂且这样说），最快得出答案将被采纳。这个数学难题的特点是： 基于每一个区块，答案都不一样，且答案唯一 解答这一问题无法利用任何先验知识，没有简便解法，其解答过程相当于是在遍历答案的所有取值空间，逐个尝试，相当于是完全随机的 解答问题的计算量非常大，但验证答案是否正确只需要一次哈希运算 答案一经采纳，将作为区块的一部分，该区块的哈希将传给下一个区块。那么如果有人想插入伪造区块，那么他的工作量就是将插入位置之后的所有区块全部重做，将每一个区块中的数学难题全部重新算一遍，这在可信节点占大多的系统中是不可能办到的。 一定是计算资源多的一方更快计算出答案吗？不一定。因为答案是随机分布的，也许计算资源少的恶意节点计算恶意区块时恰巧很快就蒙到正确答案了。如果遇到这种情况，区块链是会接受这个答案的，但随后，可信节点会计算出真答案，恶意答案和真答案不一样，那么区块链会将两个答案同时保留，分别根据两个不同的答案建立下一个区块，区块链从这里开始会产生分支。但是，我们假定可信节点是占大多数的，恶意节点会一两次碰巧，但当链变长之后，其计算速度肯定不如占大多数的可信节点快的。可信链的长度将逐渐超过恶意链，当超过一个阈值时，较短的链（恶意链）将会被去除，只保留长的链。 PoW是区块链信任机制的核心，同时也是区块链灾难般性能的始作俑者，验证一笔交易的算力消耗太大了。In case you don’t know, “计算数学难题”这件事就是平时说的“挖矿”，计算出结果就可以将一个区块打包，为了激励矿工，计算出一道数学难题并将区块链打包，就会得到一定比特币作为回报，这就是激励机制。 工作流程 新交易被广播到所有节点。 每个节点将新交易收集到一个块中。 每个节点都致力于为其区块寻找困难的工作量证明。 当节点找到工作量证明时，它会将块广播到所有节点。 仅当块中的所有交易均有效且尚未花费时，节点才会接受该块。 节点通过使用已接受块的哈希值作为前一个哈希值创建链中的下一个块来表达对块的接受。 以上是区块链的基本流程，但原文中还有更加深入的内容，如激励、磁盘空间缩减、简化的支付验证、数值的合并与分割、交易隐私、数值计算等，有机会再做展开。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://kievvv.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Cryptography","slug":"Cryptography","permalink":"https://kievvv.github.io/tags/Cryptography/"},{"name":"Blockchain","slug":"Blockchain","permalink":"https://kievvv.github.io/tags/Blockchain/"}]},{"title":"基于Shamir门限的彩色图片秘密共享方案","slug":"007Shamir-pic-secret-sharing","date":"2023-11-08T01:35:49.000Z","updated":"2023-12-11T12:25:24.274Z","comments":true,"path":"2023/11/08/007Shamir-pic-secret-sharing/","link":"","permalink":"https://kievvv.github.io/2023/11/08/007Shamir-pic-secret-sharing/","excerpt":"","text":"Shamir门限秘密共享方案Shamir的秘密共享（Shamir’s Secret Sharing）是一个将秘密分解为多个部分的方法，这样只有得到一定数量的部分才能重新构建该秘密。它是基于多项式插值，尤其是Lagrange插值原理。 在秘密共享的场景中，Shamir的方法允许一个秘密被分解为n个部分，其中任何k个部分可以用来重新构建原始的秘密，但k-1个部分或更少的部分没有任何信息。 以下是该方法的基本原理和流程： 选择秘密: 假设我们有一个秘密S，并且S是一个数字。在数字图像中，这一数字可认为是图片中各个像素值。 定义多项式: 选择一个k-1阶多项式：$$f(x)&#x3D;a_0+a_1x+a_2x^2+…+a_{k-1}x^{k-1}$$ 其中，$a_0&#x3D;S$(秘密），并且$a_0,a_2,…,a_{k-1}$是随机数。 生成分享：对于共享秘密的每个接收者，选择一个不同的x值，并计算多项式f(x)在这个x值上的值。这将生成一系列的(x, y)坐标，其中x是x值，y是f(x)的结果。 分发分享：将每个接收者的(x, y)坐标提供给相应的接收者。每个接收者将获得一个坐标点，这个坐标点包含了足够的信息来还原出原始的秘密。 重构秘密：为了还原原始秘密S，至少需要k个坐标点。这可以通过使用拉格朗日插值法来实现，从这些坐标点中重建多项式f(x)，并找到其常数项$a_0$，即原始秘密S。 改进部分课上示例为灰度图片，要实现彩色图片秘密共享其实也很简单，把彩色图片分成RGB三个通道分别按灰度图片的方法处理，三通道合成为一个其中一个子秘密，共n个子秘密，选择其中任意k个（门限）即可恢复原图。 在解密实现上，使用了拉格朗日插值函数进行逐比特差值恢复。在拉格朗日函数的实现上进行了优化改进，由于原始的浮点数计算将会产生小数，在恢复为像素时由于近似运算会使恢复的秘密图片产生可察觉的视觉差异。这里将原拉格朗日函数中的除法修改为与其模逆元的乘法，避免了小数的出现，由于原本像素模数256不是质数，在计算模逆元时会带来一定麻烦，因此模数选用了大小近似但是质数的257，在此基础上可以使用费马小定理计算模逆元，提高了算法的效率，从测试结果看，这一替换方法在秘密恢复过程中不会产生可察觉的视觉影响。 效果展示采用 3&#x2F;5 门限共享 ，原图如下： 加密生成的5个子秘密如下： 对以上彩色图像的 5 个子秘密进行了组合遍历测试，即遍历了 5 个子秘密中任意选取 3 个的所有可能情况，测试可视化结果如下： 源码from PIL import Image import numpy as np #--------------------------------参数设定------------------------------- n = 5 # 秘密分割份数 r = 3 # 门限数 path = &#39;test4.png&#39; # 秘密图片路径 testNum = 4 # 用于测试图片的命名 mod = 257 # 模数 #--------------------------------参数设定------------------------------- def read_image(path): &#39;&#39;&#39; input: 图片路径 output: 图片矩阵的三个通道, 图片矩阵形状 &#39;&#39;&#39; img = Image.open(path) img_array = np.asarray(img) red_channel = img_array[:,:,0].flatten() green_channel = img_array[:,:,1].flatten() blue_channel = img_array[:,:,2].flatten() return red_channel, green_channel, blue_channel, img_array.shape def polynomial(img, n, r): &#39;&#39;&#39; input: img: 输入图像，它应该是一个2D numpy数组。 n: 想生成的图像的数量。 r: 多项式的阶数。 output: 一个形状为 (n, num_pixels) 的numpy数组，其中每一行代表一个生成的图像 &#39;&#39;&#39; num_pixels = img.shape[0] coef = np.random.randint(low = 0, high = mod, size = (num_pixels, r - 1)) gen_imgs = [] for i in range(1, n + 1):#子秘密 base = np.array([i ** j for j in range(1, r)]) base = np.matmul(coef, base) img_ = img + base img_ = img_ % mod gen_imgs.append(img_) return np.array(gen_imgs) def lagrange(x, y, num_points, x_test): l = np.zeros(shape=(num_points, )) for k in range(num_points): l[k] = 1 for k_ in range(num_points): if k != k_: num = (x_test - x[k_]) % mod den = (x[k] - x[k_]) % mod inverse_den = pow(int(den), mod-2, mod) l[k] = (l[k] * num * inverse_den) % mod L = 0 for i in range(num_points): L = (L + y[i]*l[i]) % mod return L def decode(imgs, index, r, n): assert imgs.shape[0] &gt;= r x = np.array(index) dim = imgs.shape[1] img = [] for i in range(dim): y = imgs[:, i] pixel = lagrange(x, y, r, 0) % mod img.append(pixel) return np.array(img) if __name__ == &quot;__main__&quot;: #------------------------------------加 密------------------------------------ print(&quot;**************&quot;) print(&quot;Encrypt begin.&quot;) print(&quot;**************&quot;) r_channel, g_channel, b_channel, shape = read_image(path) gen_imgs_r = polynomial(r_channel, n = n, r = r) gen_imgs_g = polynomial(g_channel, n = n, r = r) gen_imgs_b = polynomial(b_channel, n = n, r = r) for i in range(n): # 将三个通道合并，得到其中一个子秘密 combined_img = np.stack(( gen_imgs_r[i].reshape(shape[0], shape[1]), gen_imgs_g[i].reshape(shape[0], shape[1]), gen_imgs_b[i].reshape(shape[0], shape[1]) ), axis=-1) Image.fromarray(combined_img.astype(np.uint8)).save(f&quot;test&#123;testNum&#125;_&#123;i+1&#125;.jpeg&quot;) print(f&quot;test&#123;testNum&#125;_&#123;i+1&#125;.jpeg is saved.&quot;) #------------------------------------加 密------------------------------------ #------------------------------------解 密------------------------------------ print(&quot;**************&quot;) print(&quot;Decrypt begin.&quot;) print(&quot;**************&quot;) # 遍历所有图片组合以验证解密效果 for i in range(n): for j in range(i+1, n): for k in range(j+1, n): # 选择子秘密和对应的x值 selected_subsecrets = [i, j,k] selected_x_values = [i+1, j+1,k+1] # 解密 origin_img_r = decode(gen_imgs_r[selected_subsecrets, :], selected_x_values, r=r, n=n) origin_img_g = decode(gen_imgs_g[selected_subsecrets, :], selected_x_values, r=r, n=n) origin_img_b = decode(gen_imgs_b[selected_subsecrets, :], selected_x_values, r=r, n=n) # 将解密结果合并 combined_origin_img = np.stack(( origin_img_r.reshape(shape[0], shape[1]), origin_img_g.reshape(shape[0], shape[1]), origin_img_b.reshape(shape[0], shape[1]) ), axis=-1) # 保存图像，名称包含所选的子秘密的编号 filename = f&quot;test&#123;testNum&#125;_recovered_&#123;i+1&#125;_&#123;j+1&#125;_&#123;k+1&#125;.jpeg&quot; Image.fromarray(combined_origin_img.astype(np.uint8)).save(filename) print(f&quot;&#123;filename&#125; is saved.&quot;) # 挑选制定的子秘密进行解密，如下标第1,2,4张，对应x值为2,3,5 # selected_subsecrets = [1,2,4] # selected_x_values = [2,3,5] # origin_img_r = decode(gen_imgs_r[selected_subsecrets, :], selected_x_values, r=r, n=n) # origin_img_g = decode(gen_imgs_g[selected_subsecrets, :], selected_x_values, r=r, n=n) # origin_img_b = decode(gen_imgs_b[selected_subsecrets, :], selected_x_values, r=r, n=n) # 将解密结果合并 # combined_origin_img = np.stack(( # origin_img_r.reshape(shape[0], shape[1]), # origin_img_g.reshape(shape[0], shape[1]), # origin_img_b.reshape(shape[0], shape[1]) # ), axis=-1) # Image.fromarray(combined_origin_img.astype(np.uint8)).save(f&quot;test&#123;testNum&#125;_origin.jpeg&quot;) #------------------------------------解 密------------------------------------ 项目地址：https://github.com/kievvv/RGBpicSecretSharing","categories":[{"name":"项目","slug":"项目","permalink":"https://kievvv.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"Cryptography","slug":"Cryptography","permalink":"https://kievvv.github.io/tags/Cryptography/"},{"name":"PrivacyProtection","slug":"PrivacyProtection","permalink":"https://kievvv.github.io/tags/PrivacyProtection/"}]},{"title":"Matlab基础语法备忘录","slug":"006MatlabNote","date":"2023-08-24T11:55:29.000Z","updated":"2023-10-20T03:21:53.695Z","comments":true,"path":"2023/08/24/006MatlabNote/","link":"","permalink":"https://kievvv.github.io/2023/08/24/006MatlabNote/","excerpt":"","text":"MatLab的索引是从1开始的 清空 clc 清空命令行clear all 清空工作区所有变量 变量命名区分大小写，长度&lt;&#x3D;63 %单行注释%%多行注释 变量名字以字母开头，中间可以是字母、数字、下划线 数据类型 数字 字符和字符串 字符串用单引号`` length(str) 矩阵 A=[1 2 3; 4 5 3; 3 2 7]：;表示换行，行内用空格或, B=A&#39;：求转置 C=A(:)：转成一维矩阵 D=inv(A)：求逆矩阵 E=zeros(10,5,3)：3维矩阵，每维都是10行5列，元素全是0 元胞数组 A=cell(1,6)：1行6列的元胞数组 A&#123;2&#125;=eye(3) ：把该单位矩阵赋给A中第2个元素 eye(n)：生成n维单位矩阵 magic(n)：生成n阶幻方（横竖斜任意方向数字和总相同） 结构体 books=struct(&#39;name&#39;,&#123;&#123;'Machine Learning','Data Mining'&#125;&#125;,&#39;price&#39;,[30,40])：相当于键值对、字典 books.name books.name(1)：小括号取出的是cell books.name&#123;1&#125;：中括号取出的是具体值 矩阵操作A=[1 2 3 4 5 6 7 8]、】B=1:2:9：构造矩阵-&gt;起点:步长:终点B=[1 3 5 7 9]C=repmat(B,3,2)：重复B，竖着重复3次，横着重复2次D=ones(2,4)：2行4列的纯一矩阵 矩阵四则运算+ - *：字面意思A/B：等价于A * inv(B)，和B的逆相乘A .* B：两矩阵对应项相乘，有.的都是对对应项操作，./同理 下标A(2,3)A(2,:)：:表示取所有[m,n]=find(A&gt;20)：找A中大于20的元素，将其横纵坐标分别赋给m数组和n数组 逻辑与流程控制 for循环 for 循环变量=初值:步长:终值 ... end 步长为1的话可以省略即for 循环变量=初值:终值 while循环 while 布尔表达式 ... end if(else)语句 if 布尔表达式 ... end if 布尔表达式 ... else ... end 绘图…","categories":[{"name":"笔记","slug":"笔记","permalink":"https://kievvv.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"https://kievvv.github.io/tags/Matlab/"}]},{"title":"Netflix使用及解锁4k折腾记","slug":"005Netflix4k","date":"2023-08-22T18:39:31.000Z","updated":"2023-10-20T03:28:15.766Z","comments":true,"path":"2023/08/23/005Netflix4k/","link":"","permalink":"https://kievvv.github.io/2023/08/23/005Netflix4k/","excerpt":"","text":"其实没用Netflix之前也没什么，虽然天天看网飞剧，但找资源也不费劲。相安无事。自从换了个4k屏幕，决定整一下Netflix，开始了新的折腾。 大陆现在基本就是找平台买号。已有很不错的文章，不再重复造轮子，如下：2023中国解锁Netflixi详细教程，教你用最少的钱看奈飞&#x2F;网飞合租平台可以参考上文。一般都买最高级别的会员方案，支持4k分别率。在购买的时候注意有无地区限制，比如账号在某些地区不能使用。Netflix在不同地区登录其资源是不同的。至于解锁流媒体限制的问题。登录账号后可以搜索《绝命毒师》进行验证，如果有这部剧集的资源说明当前节点已经解锁流媒体，反之则没有解锁。如果解锁流媒体就可以看到其他流媒体平台的影视作品，反之，则只能看Netflix自制的影视，即左上角都有”N”标志。是否能解锁流媒体限制与所用的节点搭建方式有关，与Netflix账号无关。 本人设备是Windows11 PC浏览器及客户端、IPad、IPhone。1080P是基本需求。主要方法如下： IPad、IPhone需要用非大陆Apple ID下载Netflix客户端，登陆即可正常播放。如果一直转圈圈基本是节点问题，多换几个。 Windows浏览器基本就是Microsoft Microsoft Edge和Chrome两个。 Microsoft Edge进官网登录直接播放就可以达到1080P。 查看分辨率的方法：快捷键Ctrl+Shift+Alt+D，非全屏即可显示。该方法浏览器和客户端都适用。 Chrome原生会限制分辨率，最高720P。可以通过插件强制改成1080P。插件名字是Netflix 1080p。 按上面方法如果没达到1080p的话，先等一下缓冲看看，因为Netflix会自动根据网络情况调整画质。如果还是不行就更换节点。浏览器用着挺好的，如果不用4k的话不推荐用Windows客户端。 接下来是Netflix解锁4k分辨率的方法： 基本条件： 支持4k(3840×2160) 60Hz的显示器 Netflix订阅方案为高级版（支持Ultra HD） Netflix串流画质设定为“高”或“自动”（账户-&gt;播放设定） 安装HEVC拓展 CPU：至少要第7代Intel Core（Kaby Lake）或以上 GPU：Nvidia GTX 1050、1060、1070或 1080等级以上显卡 HDMI线材&gt;&#x3D;2.0，才能支持60Hz HDR 网络速度：25Mbps以上（官方测速） 充足的流量：4k一小时7GB左右 Microsoft Edge最新版原生最高支持Netflix 4k首先安装tampermonkey拓展，是一个浏览器脚本环境然后打开并安装Netflix UHD脚本在浏览器Netflix播放视频，右键菜单，点PlayReady DRM Info(UHD Ready)如果全部都是勾说明符合4k播放条件，点开剧集详情页，应该会有4k的标识 否则显示的是“高画质”。如果此时播放没办法达到4k，可能是网络问题。 如果Info中最底下两行是叉，那就是没安装HEVC拓展。不介意几块钱可以直接在微软商店搜索，付费购买。不付费的方法也有，网上搜到的大部分适用于win10的，win11不适用。我最后摸索出来适用于win11的HEVC拓展免费安装方法： 进入如下网址：https://store.rg-adguard.net/ 在微软商店中找到HEVC拓展应用程序的URL：https://www.microsoft.com/en-us/p/hevc-video-extensions-from-device-manufacturer/9n4wgh0z6vhq 输入搜索框，生成下载链接，下载.appxbundle文件，安装即可。 如果浏览器还是达不到4k，可以尝试客户端。 首先在Windows系统设置中切换到国外地区，打开微软商店，下载Netflix客户端。win11用户打开客户端大概率是一直在转圈圈，是因为windows的一个限制规则，可通过改注册表来解决。方法如下：https://zhuanlan.zhihu.com/p/386357019我用的是第二个方法。 进入并登录客户端后，应该可以播放4k了。 2023.10.20更新 因为最近新设备mac mini，mac端使用Netflix观看4k影视最方便的方法应该是直接使用safari浏览器，是原生支持4k串流的。 如果更新了Mac OS 14(Sonoma)的话，新版safari可以制作伪app了，也就是把网页快捷方式包装得像是一个app，添加到程序坞和启动台，一键启动，体验蛮不错的。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://kievvv.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Netflix","slug":"Netflix","permalink":"https://kievvv.github.io/tags/Netflix/"}]},{"title":"观展游记之「草间弥生：一九四五年至今」","slug":"004YayoiKusama","date":"2023-08-09T18:38:23.000Z","updated":"2023-09-23T16:06:46.239Z","comments":true,"path":"2023/08/10/004YayoiKusama/","link":"","permalink":"https://kievvv.github.io/2023/08/10/004YayoiKusama/","excerpt":"","text":"3月3日，我在香港M+艺术馆参观了《草间弥生：一九四五年至今》这个展，很喜欢。这篇游记主要记录和回顾观展的内容。（该展已于2023年5月14日结束） 展览官方介绍如下： 「发掘草间弥生超凡绚烂的艺术之路，见证艺术连系人心、治愈心灵的力量」 草间弥生坚持不懈地追求前卫艺术实践，使她成为二十一世纪的全球文化偶像。她在逾七十年的创作生涯中发展出独树一帜的核心美学和人生哲学。其作品展示浩瀚无垠之境，反思大自然的生命形态与循环，掳获世人的目光。“草间弥生：一九四五年至今”呈现艺术家的创作生涯，强调她对相互连结的追求，以及不断推动其创作的生命哲思。“草间弥生：一九四五年至今”是草间在日本以外的亚洲地区举行的最大回顾展，展出逾200件展品，涵盖绘画、素描、雕塑、装置及档案资料等各种媒材。是次回顾展按时序及主题出发，由第二次世界大战尾声创作的绘画至其最近期的沉浸式作品，围绕“无限”、“积累”、“全面连结”、“生物宇宙”、“死亡”和“生命的力量”六个主题，全面地呈现草间艺术生涯的各个发展阶段。 Offical Website M+场馆不算十分好找，地铁九龙站出门后还有十分钟左右路程，稍微有些绕，不过当时在九龙站出站时就已经看到该展览的物料宣传，当然也有包括故宫博物馆等艺术展览的宣传，这个街区是艺术文化活动较集中的地方。 在M+整体体验非常好，包括场馆的建筑风格、内部装潢、安静程度、服务人员和设施等都很不错。 几个记忆点：电梯前面有专人替顾客按电梯并礼貌地鞠躬打招呼；服务人员中英粤切换流利；买学生票无需check证件；支持微信支付宝。 进入正题。展览标题处这幅自画像包含草间弥生经典的波点样式和黑黄配色，开篇明志，后续会看到更多类似元素。 玄关处主要是波点元素为主的人脸像，配色十分鲜艳大胆，下图仍为艺术家自画像，配色很抓眼。 第一个展厅。该展厅的展品全部是无主体的纹理平面画。场馆里人其实挺多的，但是很安静，连走路脚步都会不自觉放轻，基本没有小孩子吵闹声。 每次看见纯纹理的作品我都会停下来仔细端详一下，在看草间这一系列作品时也不例外。这部分画都是纯视觉向的，比较抽象。有一种说法是这些花纹是作者在自己梦中看到的景象。草间弥生的创作很大一部分与她早期患精神疾病时的灵感相联系。 然后来到装置艺术区域。 红黑触手草间弥生的经典设计，视觉冲击力很强，我最爱的展品之一。 长满阴茎的女孩和家具主题是针对女性受性侵害的隐喻。 综合展厅。该展厅装置和画都有，以波点、纹理为主。波点大蘑菇 这是毛细血管么？ 然后就是Highlight之一：黑黄蛇纹图这幅画的画幅很大，现场效果非常震撼。近看纹理和质感都非常妙，摄人心魄。我凑近看了差不多有五分钟。 下一个很出圈的装置艺术是黑黄南瓜展馆内的瓜，小小的很精致： 场馆外的大瓜，应该不是艺术家原作品，属于是宣传周边： 下一个展区，主题是生命的色彩。整个区域的作品色彩非常明艳，表现的是生命和活力。 下一个装置艺术区，主要是探讨人体器官本身，以及人和地狱的联系 接着是通过装置和影像展示的行为艺术相关的作品，也包括草间弥生的个人自白。这部分还是要在现场观看感受，很难描述清楚。 1967 年，草间弥生纽约公园、克赖斯勒艺术博物馆举办“人体嘉年华”活动，邀请了许多模特在墙上以及各自的身体上进行创作。 要离开时偶然从一个门缝进入，别有洞天。发现一处现代感很浓的装置艺术，一滩金属材质拟液态物体，就着栅状光线，如果以动态视角观看的话，金属表面有光怪陆离的效果。草间似乎不是善用光影的艺术家，该作品跟她其他作品的形态差别好像也比较大。但就挺好看的。 展览设计有些复杂，来来回回把二层场馆逛了两三遍，没想到还是有遗漏。出来之后发现地下一层还有大型装置艺术的场馆，有点遗憾地错过了。","categories":[{"name":"游记","slug":"游记","permalink":"https://kievvv.github.io/categories/%E6%B8%B8%E8%AE%B0/"}],"tags":[{"name":"Art","slug":"Art","permalink":"https://kievvv.github.io/tags/Art/"},{"name":"Photos","slug":"Photos","permalink":"https://kievvv.github.io/tags/Photos/"}]},{"title":"SQUIRREL：论文随记","slug":"003SQUIRREL-review","date":"2023-07-27T19:28:54.000Z","updated":"2023-09-23T15:43:09.296Z","comments":true,"path":"2023/07/28/003SQUIRREL-review/","link":"","permalink":"https://kievvv.github.io/2023/07/28/003SQUIRREL-review/","excerpt":"","text":"这是一篇Fuzzing测试相关论文的阅读随记，主要为了理清思路方法，文章题目是：SQUIRREL: Testing Database Management Systems with Language Validity and Coverage Feedback，2020年发表在CCS USA，一作是佐治亚理工学院的Rui Zhong，二作Yongheng Chen（是CTFer！ 相关链接如下：论文，源码 Abstract Fuzzing is an increasingly popular technique for verifying software functionalities and finding security vulnerabilities. However, current mutation-based fuzzers cannot effectively test database management systems (DBMSs), which strictly check inputs for valid syntax and semantics. Generation-based testing can guarantee the syntax correctness of the inputs, but it does not utilize any feedback, like code coverage, to guide the path exploration. In this paper, we develop Sqirrel, a novel fuzzing framework that considers both language validity and coverage feedback to test DBMSs. We design an intermediate representation (IR) to maintain SQL queries in a structural and informative manner. To generate syntactically correct queries, we perform type-based mutations on IR, including statement insertion, deletion and replacement. To mitigate semantic errors, we analyze each IR to identify the logical dependencies between arguments, and generate queries that satisfy these dependencies. We evaluated Sqirrel on four popular DBMSs: SQLite, MySQL, PostgreSQL and MariaDB. Sqirrel found 51 bugs in SQLite, 7 in MySQL and 5 in MariaDB. 52 of the bugs are fixed with 12 CVEs assigned. In our experiment, Sqirrel achieves 2.4×243.9× higher semantic correctness than state-of-the-art fuzzers, and explores 2.0×-10.9× more new edges than mutation-based tools. These results show that Sqirrel is effective in finding memory errors in database management systems. Fuzzing模糊测试 -&gt; 一种软件测试方法，通过半随机方式的数据发送以验证软件功能和查找安全漏洞 基于mutation的fuzzer 因为DBMS严格检查输入-&gt;不可用 基于generation的fuzzer -&gt;可以保证syntax correctness 但不能利用feedback(代码覆盖率等)来引导探索路径 Squirrel 兼顾language validity和coverage feedback Intermediate Representation -&gt; 使得查询structural和informative Type-based mutation -&gt; 保证语法(syntactically)正确 Semantics-Guided Instantiation -&gt; 保证语义(semantically)正确 Introduction主要贡献 Propose syntax-preserving mutation and semantics-guided instantiation to address the challenges of fuzzing DBMSs. Implement Squirrel, an end-to-end system that combines mutation and generation to detect DBMS bugs. Evaluated Squirrel on real-world DBMSs and identified 63 memory error issues. The result shows that Squirrel outperforms existing tools on finding bugs from DBMSs. Problem Definition1. Query Processing in DBMSHow a DBMS handles SQL queries1) parse First parses the query to get its syntactic meaning Breaks the query into individual tokens Checks them against the grammar rules 2) validation Checks the semantic correctness of the query 3) ptimization 构造几个可能的查询计划 -&gt; 确定给定查询最有效的查询计划 4) execution 执行 + 返回 如果1, 2阶段不满足，则不会进行到3, 4 2 Challenges of DBMS TestingIntroduce existing DBMS testing techniques &amp; Illustrate their limitations主要有两种DBMS测试方法：1) model-based generation 基于模型生成遵循精确的语法模型以生成语法正确的输入 pros: 语法正确 cons: 顺序扫描整个输入空间-&gt;不能有效搜索程序的状态空间 很难保证语义正确性-&gt;会被过滤 2) random mutation 随机变异更新现有输入以生成新输入 pros: 利用先前执行的反馈来评估生成的输入的优先级 如果反馈表明之前的输入很有趣，模糊器会将其放入队列中以进行进一步的变异 -&gt;可以有效地探索程序的状态空间 cons: 在处理结构化输入方面效率低下(如SQL、JS) 1. 随机翻转一个 SQL 关键字的位很难产生另一个有效的关键字 2. 整个查询将在语法上变得不正确 AFL 生成的查询的验证率很低- &gt; 语义正确很重要 3 Our ApproachPresent our insight to solve this problem1) Generating Syntax-Correct Queries IR-&gt;使得查询structural和informative 基于类型的突变来保证句法正确性 -&gt;每个语句都有语法类型，每个数据都有语义类型 从每个 IR 中剥离具体数据，如表名，以专注于改变骨架 2) Improving Semantic Correctness确保语义正确是NP-hard问题 通过动态查询实例化 -&gt; 保证其 SQL 模板的表现力 给定语法正确的 SQL 查询的骨架 -&gt; 尝试用关系满足数据依赖图的具体操作数填充骨架 (根据预定义的基本规则构建其数据依赖图) Overview of Sqirrel 四个组成部分 Translator, Mutator, Instantiator, SQL Fuzzer 主要流程 从查询队列中选一个查询I IR Translator将查询I翻译成IR的向量V 同时从V中剥离具体值，使其成为骨架 Mutator生成新的向量V’(通过插入、删除、替换) -&gt; V’语法正确 Instantiator对V’进行数据依赖性分析 （并构建新的数据依赖图） Instantiator选择新的具体值填充V’,which满足数据依赖性 将V’转回SQL语句I‘ 运行： if 崩溃 -&gt; 找到触发错误的输入 else if 触发了新的执行路径 -&gt; 保存到队列 Intermediate Representation 中间表示（IR Translator）SQL语句I转化成 -&gt; IR向量V -&gt; 改变成V’ -&gt; 转换回SQL语句I’ IR特点：expressive, general, simple Syntax-Preserving Mutation 语法保留突变Token区分 structure：关键字 + 数学运算符 改变structure会改变查询的操作，从而触发不同的功能 data：常量值、名称等 修改与语义相关的data可能会生成语义不正确的查询导致DBMS拒绝执行 改变structure的影响更大-&gt;剥离数据，在结构上变异 1) Structure-Data Separation 基本规则：用“x”替换语义数据，将常量数字更改为 1 或 1.0 在IR library存储不同的IR 2) Type-Based Mutation 主要是operand的变异 -&gt; 要么修改整个IR，要么修改operand 三种变异 Insertion插入Replacement替换 -&gt;在IR库中选择对应位置的孩子进行插入或替换 Deletion删除验证语法正确转回SQL语句，传入执行 if 成功执行 -&gt; 语法正确，继续使用 else -&gt; 丢弃 Semantics-Guided Instantiation 语义引导实例化1) Data Dependency Inference灰色线是从属关系，黑色线是对等关系 细化数据类型，遵循lifetime原则：用前创建，删后不用 关系规则是一个包含四个元素的元组（α,β,γ,S）：α是关系目标，β是关系源； γ 定义关系； S 表示关系的范围 2) IR Instantiation dataMap：跟踪具有不同类型的唯一名称relationMap：将每个元素映射到其依赖项 验证语义正确转回SQL语句，传入执行 if 满足依赖性，成功执行 -&gt; 语义正确，继续使用 else -&gt; 丢弃 if interesting -&gt; 保存入队列 Implementation &amp; Evaluation此处略 Discussion1. DBMS-Specific Logic-&gt;针对不同DBMS系统的SQL方言语法进行设计可以提高测试效果 2. Relation-Rule Construction人工编写关系规则 -&gt; 自动推断（数据流分析&#x2F;深度学习） 3. Collisions in Code-Coverage扩大Bitmap的大小以缓解Collision 4. Alternative Feedback Mechanismscode coverage VS semantics-correct queries -&gt; 有害的代码覆盖率阻碍了语义正确查询的生成 Related Work &amp; Conclusion略 SummarySQUIRREL: Testing Database Management Systems with Language Validity and Coverage Feedback这篇论文提出了一种新型的自动化测试工具Squirrel，它的主要作用是用于测试关系型数据库管理系统(DBMS)。这篇论文在2020年11月首次发表在2020 ACM SIGSAC Conference上，作者为来自宾夕法尼亚州立大学和佐治亚理工学院的Rui Zhong等6人，当前在Google学术上被引用次数为40次。 模糊测试是一种用于验证软件功能和查找软件安全漏洞的技术。但是，目前基于突变（mutation）的模糊器（fuzzer）无法有效测试会严格检查输入的语法语义正确性的数据库管理系统；基于生成（generation）的测试无法利用反馈来指导测试路径。 基于以上现状，本文整合了上述两种测试框架的优点，介绍了一种名为Sqirrel的新型模糊测试框架，用于测试数据库管理系统（DBMS），同时考虑了语言有效性和覆盖反馈。Squirrel使用中间表示（IR, Intermediate Representation）以结构化和信息化的方式维护SQL查询，并对IR进行基于类型的变异以生成语法正确的查询。它还分析每个IR以识别参数之间的逻辑依赖关系，并生成满足这些依赖关系的查询以减轻语义错误。 Squirrel的测试流程包括以下步骤： 生成初始查询：Sqirrel使用基于模型的生成方法生成初始查询。 转换为IR：Sqirrel将初始查询转换为IR，以便于后续的变异和分析。 变异：Sqirrel对IR进行基于类型的变异，以生成语法正确的查询。 依赖分析：Sqirrel分析每个IR以识别参数之间的逻辑依赖关系，并生成满足这些依赖关系的查询以减轻语义错误。 执行查询：Sqirrel执行生成的查询，并记录覆盖信息。 覆盖反馈：Sqirrel使用覆盖信息来指导下一轮变异，以提高测试效率和覆盖率。这个流程不断迭代，直到达到预设的测试目标或者测试时间结束。上述6个流程是对Squirrel框架的高度概括，在具体实现上仍有很多较为细节的步骤，保证了Squirrel框架的结果准确、逻辑合理、运算高效，整个框架的代码实现超过了四万行。 随后，作者将Squirrel框架在真实的数据库管理系统上测试。主要关注以下三个问题：是否能检测出内存漏洞？是否超过了SOTA的测试工具？语言正确性和覆盖率反馈在测试中的作用如何？ 由此，将实验分为三个部分：语法正确性测试、语义正确性测试和性能测试。 在语法正确性和语义正确性测试中，作者使用Sqirrel、AFL、SQLsmith、QSYM、Angora和GRIMOIRE等六个工具对SQLite和MySQL进行测试，并比较了它们的测试效果。作者使用了10个已知的语法错误和缺陷来评估这些工具的测试效果，并计算了它们的错误检测率和测试时间。 在性能测试中，作者使用了Sqirrel、AFL、SQLsmith、QSYM、Angora和GRIMOIRE等六个工具对SQLite和MySQL进行测试，并比较了它们的测试效果。作者使用了10个已知的性能问题来评估这些工具的测试效果，并计算了它们的测试时间和覆盖率。 Sqirrel在40天内发现了四个流行的DBMSs上的63个内存错误问题，其中包括51个SQLite错误、7个MySQL错误和5个MariaDB错误。综合实验各项指标，其结果表明Sqirrel在语法正确性测试、语义正确性测试和性能测试中都表现出色，能够有效地检测出各种类型的错误和缺陷，并且具有较高的测试效率和覆盖率。 最后，对文章所做的研究不足之处及未来可以继续开展工作总结如下： 提高测试效率：本文中提到Sqirrel的测试效率相对较低，需要较长的时间来生成测试用例。结合我自身复现代码的过程也印证了这一点。因此，未来的工作可以探索如何提高测试效率，例如使用并行化技术或者优化测试用例生成算法。 提高测试覆盖率：本文中Sqirrel的测试覆盖率仍有提升空间。未来的工作可以探索如何提高测试覆盖率，例如使用符号执行技术或者结合其他测试方法。 改进测试用例生成算法：本文中使用的测试用例生成算法可以生成语法正确的测试用例，但是无法保证语义正确。未来的工作可以探索如何改进测试用例生成算法，以提高测试用例的语义正确性。 扩展到其他类型的漏洞：本文中Sqirrel主要用于检测内存损坏漏洞，而数据库管理系统中存在的漏洞多种多样，面对的外部威胁更是防不胜防。未来的工作可以探索如何将Squirrel扩展到检测其他类型的漏洞，例如SQL注入漏洞或者逻辑漏洞等。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://kievvv.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Fuzzing","slug":"Fuzzing","permalink":"https://kievvv.github.io/tags/Fuzzing/"},{"name":"Database","slug":"Database","permalink":"https://kievvv.github.io/tags/Database/"},{"name":"SQL","slug":"SQL","permalink":"https://kievvv.github.io/tags/SQL/"}]},{"title":"密码学笔记","slug":"002CryptoNote","date":"2023-07-19T13:36:33.000Z","updated":"2023-09-23T15:40:08.044Z","comments":true,"path":"2023/07/19/002CryptoNote/","link":"","permalink":"https://kievvv.github.io/2023/07/19/002CryptoNote/","excerpt":"","text":"第一章 引言信息安全基本属性 机密性 （Confidentiality）保证信息为授权者使用而不泄漏给未经授权者。别人“看不到”或“看不懂” 认证（Authentication）消息认证，保证消息来源的真实性身份认证，确保通信实体的真实性证明“你就是你” 完整性 （Integrity）数据完整性，未被未授权篡改或者损坏系统完整性，系统未被非授权操纵，按既定的功能运行信息没有被“动过” 不可否认性（Non-repudiation ）要求无论发送方还是接收方都不能抵赖所进行的传输 可靠性（Reliability）特定行为和结果的一致性 可用性 （Availability）保证信息和信息系统随时为授权者提供服务，而不要出现非授权者滥用却对授权者拒绝服务的情况。 可控性（Controllability）授权实体可以控制信息系统和信息使用的特性 审计（Accountability）确保实体的活动可被跟踪 密码编码学密码算法的分类 按功能加密算法：用于机密性解决方案杂凑函数：用于完整性解决方案数字签名：用于认证和不可否认性 按密钥的使用方式对称密钥密码 : 加密密钥与解密密钥相同非对称密钥密码（公钥密码）:加密密钥与解密密钥不同 公钥密码部分解决了对称密钥密码算法中密钥共享、密钥管理的问题。 第一代公开的、完全说明细节的商业级密码标准是DES 被动攻击与主动攻击被动攻击-&gt;不影响通讯网络嗅探、流量分析主动攻击-&gt;影响通讯网络中断、假冒身份、数据包篡改 密码分析学安全的概念Kerckhoffs假设假定密码分析者和敌手知道所使用的密码系统。 即密码体制的安全性仅依赖于对密钥的保密,而不应依赖于算法的保密。 密码分析学的目标 破译密文 破译密钥 破译出明文 密文是[破译]的基础，密钥是[破译]的核心目标，而明文虽然是有用的想要的信息，但它是[破译出]密钥后才有的产物，所以核心是破译密文和密钥 密码分析方法的分类攻击密码体制的方法 穷举攻击：通过试遍所有的密钥来进行破译。对抗：可增大密钥的数量。 统计分析攻击：通过分析密文和明文的统计规律来破译。对抗：设法使明文和密文的统计规律不一样。 解密变换攻击：针对加密变换的数学基础，通过数学求解设法找到解密变换。对抗：选用具有坚实的数学基础和足够复杂的加密算法。 密码破译 唯密文攻击（Ciphertext Only Attack）：在唯密文攻击中，攻击者只能获取到加密后的密文，没有任何关于明文或密钥的其他信息。攻击者的目标是通过分析密文来推断出明文或密钥的信息。 已知明文攻击（Known Plaintext Attack）：在已知明文攻击中，攻击者可以获取到一些已知明文和对应的密文对。攻击者的目标是通过这些已知对来破解密钥或加密算法。 选择明文攻击（Chosen Plaintext Attack）：在选择明文攻击中，攻击者可以选择一些明文，并获取对应的密文。攻击者可以根据这些选择的明文和对应的密文来分析加密算法或破解密钥。 选择密文攻击（Chosen Ciphertext Attack）：在选择密文攻击中，攻击者可以选择一些密文，并获取对应的解密结果或其他与密文相关的信息。攻击者可以利用这些选择的密文和相关信息来破解密钥或分析加密算法。 以上攻击强度依次递增 无条件安全和计算上安全无条件安全的(不可破译的)无论截获多少密文，都没有足够信息来唯一确定明文，则该密码是无条件安全的，即对算法的破译不比猜测有优势 计算上安全的使用有限资源对一个密码系统进行分析而未能破译，则该密码是强的或计算上安全的 计算上安全的密码算法要满足的准则 破译密文的代价超过被加密信息的价值。 破译密文所花的时间超过信息的有用期。 习题Kerckhoffs假设指的是？密码分析的目标在于？ 古典密码算法置换密码置换（Permutation）对明文字符或字符组进行位置移动的密码明文的字母保持相同，但顺序被打乱了。 值不变顺序变 单表代替密码算法代替(Substitution)密码构造一个或多个密文字母表，然后用密文 字母表中的字母或者字母组来代替明文字母或字母组，各字母或 字母组的相对位置不变，但其本身的值改变了。 值变顺序不变 加法密码凯撒密码 乘法密码仿射密码 仿射密码是乘法密码和加法密码的结合。加密函数：y&#x3D;ax+b(mod26)密钥：a，b解密函数：x&#x3D;a^(-1)(y-b)(mod26) 缺点：不能对抗统计分析 多表代替密码算法Vigenere（维吉尼亚）密码 可证明安全性密码游戏与规约把密码破译归结到困难问题上，而当困难问题实际上是简单的： 密码不安全，可通过解决困难问题来攻破 密码还是安全的，但是不是可证明安全 CDH假设 第二章 流密码基本概念一次一密• 优点：• 密钥随机产生，仅使用一次• 无条件安全• 加密和解密为加法运算，效率较高• 缺点：• 密钥长度至少与明文长度一样长• 密钥共享困难，不太实用 • 改进：• 种子密钥生成无限长的密钥（流密码的思想，共享一小段） 流密码的基本思想• 利用密钥k产生一个密钥流z&#x3D;z0z1z2…，并使用如下规则对明文串x&#x3D;x0x1x2…（加法或者简单处理方法）加密：y&#x3D;y0y1y2…＝Ez0(x0)Ez1(x1) Ez2(x2)…， 流密码的定义内部记忆元件的状态σi独立于明文字符的叫做同步流密码，否则叫做自同步流密码。在同步流密码中，由于zi&#x3D;f(k,σi)与明文字符无关，因而此时密文字符yi&#x3D;Ezi(xi)也不依赖于此前的明文字符。可将同步流密码的加密器分成密钥流产生器和加密变换器两个部分。 同步流密码 密码设计者的最大愿望是设计出一个滚动密钥生成器，使得密钥经其扩展成的密钥流序列具有如下性质：极大的周期良好的统计特性抗线性分析 有限状态自动机模型有限状态自动机可用有向图表示，称为转移图箭头和箭尾代表状态，（)中前者代表引起状态改变的输入，后者代表状态改变后的输出 密钥流生成器密钥流产生器: 参数为k的有限状态自动机，一个输出符号集Z、一个状态集∑、两个函数φ和ψ以及一个初始状态σ0组成。状态转移函数φ:σi→σi+1，将当前状态σi变为一个新状态σi+1，输出函数ψ:σi→zi，当前状态σi变为输出符号集中的一个元素zi。一般采用线性的φ和非线性的ψ密钥流生成器可分成驱动部分和非线性组合部分驱动部分是一个或多个线性反馈 移位寄存器。（LFSR是流密码构造的关键模块) 二元序列的伪随机性二元序列的相关概念GF（2）上的一个无限序列-&gt;a&#x3D;(a1,a2,…,an,…)称为二元序列，若 ai属于GF(2)，0或者1。 游程 自相关函数 伪随机序列满足条件Golomb伪随机公设 线性反馈移位寄存器反馈移位寄存器GF(2)上一个n级反馈移位寄存器由n个二元存储器与一个反馈函数f(a1,a2,…,an) 组成 反馈函数f(a1,a2,…,an)是n元布尔函数，即函数的自变量和因变量只取0和1这 两个可能的值。 线性反馈移位寄存器反馈函数是个线性函数 密钥流的周期给定密钥流 ，如果存在整数r，使得 对于任意 ，都有 ，则称 r为该密钥流的一个周期， 称满足 的最小正整数为该密钥流的最小周期或简称周期。 m-序列线性反馈移位寄存器的多项式表示定理2.2 p(x)|q(x)的充要条件是G(p(x)) Í G(q(x)) m-序列产生的条件Golomb伪随机公设①在序列的一个周期内，0与1的个数相差至多为1。②在序列的一个周期内，长为i的游程占游程总数的1&#x2F;2i (i&#x3D;1,2,…)，且在等长的游程中0的游程个数和1的游程个数相等。③异相自相关函数是一个常数。 m-序列安全性解方程方法线性反馈移位寄存器综合求解法非线性序列密钥流生成器可分解为驱动子系统和非线性组合子系统驱动子系统常用一个或多个线性反馈移位寄存器来实现非线性组合子系统用非线性组合函数F来实现 密钥k扩展 而成的密钥流序列z应满足的性质： 种子密钥的长度足够长（一般来说就是流密码的密钥长度） 极大的周期 良好的统计特性 极大的线性复杂度 极大的k错线性复杂度 抗统计分析 混乱性 扩散性 抗线性分析 Geffe序列生成器J-K触发器Pless生成器第三章 分组密码概述通常取n&#x3D;m若n&lt;m ，则为有数据扩展的分组密码。若n&gt;m ，则为有数据压缩的分组密码。 安全性设计原则混淆原则(Confusion) 混淆原则就是将密文、明文、密钥三者之间的统计关系和代数关系变 得尽可能复杂，使得敌手即使获得了密文和明文，也无法求出密钥的任何信息 即使获得了密文和明文的统计规律，也无法求出明文的新的信息 明文不能由已知的明文，密文及少许密钥比特代数地或统计地表示出来。 密钥不能由已知的明文，密文及少许密钥比特代数地或统计地表 示出来。 引入了非线性变化 扩散原则(Diffusion) 扩散原则就是应将明文的统计规律和结构规律散射到相当长的一段统计中去(Shannon的原话) 也就是说让明文中的每一位影响密文中的尽可能多的位，或者说让密 文中的每一位都受到明文中的尽可能多位的影响。实际上扩散原则应该把密文和密钥的关系加进去，也就是要让密文中的每 一位影响尽可能多的位 分组密码算法的要求 分组长度n要足够大防止明文穷举攻击 密钥量要足够大使所有密钥同等地好+防止密钥穷举攻击 由密钥确定置换的算法要足够复杂充分实现明文与密钥的扩散和混淆，没有简单的关系可循 加密和解密运算简单易于高速实现 数据扩展 差错传播尽可能地小一个密文分组的错误尽可能少的影响其他密文分组的解密 分组密码的结构两种常见的分组密码结构是Feistel网络Feistel Net和 SP网络Substitution-permutation Net DES-&gt;FeistalAES-&gt;SP 代换代换是输入集A到输出A’上的一一映射双射条件保证在给定k下可从密文惟一地恢复出原明文 Feistel密码结构乘积密码指顺序地执行两个或多个基本密码系统，使得最后结果的密码强度高于每个基本密码系统产生的结果 参数分组大小密钥大小轮数子密钥产生算法轮函数 要求快速的软件实现算法容易分析 Feistel加密结构将每组明文分成左右两半L0和R0，在进行完n轮迭代后，左右两半再合并到一起以产生密文分组其中Ki是第i轮用的子密钥，由加密密钥K得到。一般地，各轮子密钥彼此不同而且与K也不同 Feistel解密结构本质上和加密过程是一样的，子密钥Ki的次序与加密过程相反 DES算法基本参数分组长度为64 bits (8 bytes)密文分组长度也是64 bits密钥长度为64 bits，有8 bits奇偶校验，有效密钥长度为56 bits 流程 初值置换IP 16轮迭代的乘积变换逆初值置换IP^-1轮函数即 密钥编排即 填充Padding给定加密消息的长度是随机的，按64bit分组时，最后一组消息 长度可能不足64 bit。可以填充一些数字，通常用最后1字节作为填 充指示符（PI） DES的安全性目前攻击DES的主要方法有时间-空间权衡攻击、差分攻击、线性攻击和相关 密钥攻击等方法线性攻击方法是最有效的一种方法 多重DES多重DES就是使用多个密钥利用DES对明文进行多次加密 可以增加密钥量 双重DES 中间相遇攻击三重DES当k1&#x3D;k3时，则称为双密钥三重DES 分组密码的工作模式 工作模式：根据不同的数据格式和安全性要求, 以一个具体的分组密码算法为基础构造一个分组密码系统的方法 电码本(ECB)模式 直接利用加密算法分别对分组数据组加密优点：（1）实现简单;（2)不同明文分组的加密可并行实施，尤其是硬件实现时速度很快 缺点：（1）相同明文分组对应相同密文分组（2）不能隐蔽明文分组的统计规律和结构规律,不能抵抗统计分析、重传和代换攻击 密码分组链接(CBC)模式 这种模式先将明文分组与上一次的密文块进行按比特异或，然后再进行加密处理特点： 明文块的统计特性得到了隐蔽-&gt;各密文块不仅与当前明文块有关，而且还与以前的 明文块及初始化向量有关 具有有限的错误传播特性（两步）-&gt;一个密文块的错误将导致两个密文块不能正确解密 具有自同步功能-&gt;密文出现丢块和错块不影响后续密文块的解密 密码反馈(CFB)模式若待加密消息需按字符、字节或比特处理时，可采用CFB模式。 并称待加密消息按 r 比特处理的CFB模式为 r 比特CFB模式 选取最左边的r比特 作为加密密钥 特点 相同明文（改变IV同样会导致相同的明文输入得到不同的加密 输出。IV无需保密 链接依赖性（链接机制致使密文组依赖于当前明文组和其前面的明文组，重排密文组会影响解密 错误的传播（一个或多个比特错误出现在任一个r比特的密文组中 错误恢复（自同步 输出反馈(OFB)模式OFB模式在结构上类似于CFB模式，但反馈的内容是DES的输出而不是密文！ 特点： 相同明文（改变IV同样会导致相同的明文输入得到不同的加密 输出 没有链接依赖性（密钥流是独立于明文的 没有错误传播（有一个或多个比特错误的任一密文字符仅会影响 该字符的解密 错误恢复（OFB模式能从密文比特错误中得以恢复，但在丢失密文 比特后就无法实现自同步了，这是因为丢失密文比特会破坏密钥流 的编排 计数器（CTR）模式（OFB模式的简化版本）结构 优点： 效率（可并行加密、预处理、吞吐量仅受可使用并行数量的限制 加密数据块的随机访问 可证明安全 简单性（只要求实现加密算法 前四类工作模式比较和选用 ECB模式简单、高速，但最弱，易受重放和替换攻击，一般用于加密长度小于等于分组长度的消息。 明文不易丢信号，对明文的格式没有特殊要求的环境可选用CBC模式。需要完整性认证功能时也可选用该模式。 容易丢信号的环境，或对明文格式有特殊要求的环境，可选用CFB模式。 不易丢信号，但信号特别容易错，且明文冗余特别多，可选用OFB模式。 有限域AES算法AES提出的背景DES算法由于其密钥较短，难以抵抗现有的攻击，因此不再作 为加密标准 AES算法框架和参数说明设计思想设计简单速度快，编码紧凑抵抗所有已知的攻击没有采用Feistel结构，轮函数由3个不同的可逆均匀变 换构成的 轮函数线性混合层-&gt;确保多轮之上的高度扩散非线性层-&gt;将具有最优的“最坏情况非线性特性”的S盒并行使用，确保混淆特性密钥加层-&gt;单轮子密钥简单的异或到中间状态上，实现一次性掩盖 结构 轮函数字节代换（S盒）解密用到逆S盒 行移位状态阵列的各行进行循环移位，不同行的移位量不同0行：不动1行：循环左移C1字节2行：循环左移C2字节3行：循环左移C3字节 解密则相应逆行移位 列混淆列混合运算也可写为矩阵乘法 轮密钥加轮密钥与状态进行逐比特异或轮密钥由种子密钥通过密钥编排算法得到轮密钥长度与分组长度相同 AES密钥编排由密钥扩展和轮密钥选取两部分组成 SM4算法 SM4是一个分组密码算法，分组长度和密钥长度均为128比特。加密算法与密钥扩展算法都采用32轮非线性迭代结构 整体结构 第四章 公钥密码对称密码的困境-&gt;密钥共享和管理 -&gt;不支持“开放系统”两个没有预先建立关系的用户 公钥密码体制 主要思想：从一个方向计算非常容易，而 从另一个方向计算则很困难 公钥密码的理论基础: 陷门单向函数 公钥加密结构 公钥认证结构 公钥密码体制的优势密钥分发：公钥能够采用公开（认证的）信道进行传输；密钥管理：在用户N个用户的系统中，每个用户只需安全保管自己的私钥和N-1个 其他用户的公钥。整个系统仅仅需要维护N个公钥；开放系统：即使是没有预先建立关系的用户也能通过对方的公钥建立安全通信。 公钥密码的主要作用 公钥加密 数字签名 基于公钥的密钥分配 公钥密码算法的要求容易的：接收方B产生密钥对（PK.B和SK.B）在计算上是容易的。发方A对消息m加密以产生密文c，即c&#x3D;E.PKB[m]在计算上是容易的。收方B用自己的秘密钥对c解密，即m&#x3D;D.SKB[c]在计算上是容易的。 不可行：敌手由PKB求SKB在计算上是不可行的。敌手由密文c和PKB恢复明文m在计算上是不可行的。 研究公钥密码算法就是要找出合适的陷门单向函数。 RSA加密算法原理 选择两个大素数p, q 。 计算 m&#x3D;pq, z&#x3D;(p-1)(q-1) 。 随机选取 e（其中e&lt;n ）， e与z没有公因数。（ e, z“互为质数”） 选取d使得ed-1能够被z完全整除。 （换言之：ed mod z &#x3D; 1 ） 公钥是 (n,e)。私钥是(n,d) 。 加解密过程 例题 RSA的加密、解密过程都为求一个整数的整数次幂，再取模。如果按其 含义直接计算，则中间结果非常大，有可能超出计算机所允许的整数取值 范围。而用模运算的性质：(a×b) mod n&#x3D;[(a mod n)×(b mod n)] mod n 就可减小中间结果。 RSA密钥的产生 两个大素数p、q的选取。-&gt;Miller-Rabin算法 e的选取和d的计算-&gt;选取满足1&lt;e&lt;φ(n)和gcd(φ(n),e)&#x3D;1的e，并计算满足d·e≡1 mod φ(n)的d。这一问题可由推广的Euclid算法完成。 RSA的安全性RSA的安全性是基于分解大整数的困难性假定RSA是确定性的加密算法, 不能抵御选择密文攻击。 几个困难问题 大整数分解问题（factorization problem） 离散对数问题（discrete logarithm problem） 多项式求根问题 二次剩余问题（quadratic residue problem） 背包问题（knapsack problem） ElGamal公钥密码体制Elgamal加密基于CDH假设的单向性 ElGamal公钥密码体制历史ElGamal公钥加密体制原理 特点： 安全性基于有限域上的离散对数的难解性 加密算法是概率算法 不能抵御选择密文攻击 存在密文扩张 ElGamal密码的安全性参数要求：p应为150位以 上十进制数，500位以上的 二进制数，p-1应有大素数因子。K必须保密而且必须是一次性的。 ElGamal与RSA的区别 RSA：大整数分解问题 ElGamal：循环群的离散对数问题 椭圆曲线密码椭圆曲线密码体制ECC（elliptic curve cryptography）可用短得多的密钥获得同样的安全性 原理 加密流程 优点 安全性高 密钥量小-&gt;在实现相同的安全性能条件下，椭圆曲线密码 体制所需的密钥量远比基于有限域上的离散对数问题的公钥体制的密钥量小 灵活性好 SM2椭圆曲线公钥密码加密算法算法简介中国商用公钥密码标准算法一组椭 圆曲线密码算法，其中包含加解密算法、数字签名算法安全性都是基于求解椭圆曲线上的离散对数问题的困难性 算法原理密钥产生 加密算法 加密流程图 解密算法 解密流程图 SM2与ECC的区别ECC算法通常采用NIST等国际机构建议的曲线及参数SM2算法 的参数需要利用一定的算法产生-&gt;更安全 在ECC算法中，用户可以选择MD5、SHA-1等国际通用的哈希算法SM2算法中则使用SM3哈希算法 SM的优点：解密算法中的检错 第五章 哈希函数哈希函数的基本概念定义将任意长的消息M映射为较短的、固定长度的一个值H(M)。Hash函数也称为哈希函数、散列函数、压缩函数、杂凑函数、 指纹函数等其函数值H(M)为哈希值、散列值、杂凑码、指 纹、消息摘要等 目的Hash函数的目的是为需认证的数据产生一个“指纹” 要求输入可以是任意长输出是固定长易于在软件和硬件实现 安全条件 单向性 抗弱碰撞性 抗强碰撞性 -&gt;三者有包含关系，满足后者即可满足前者 生日攻击第一类生日攻击问题：“已知一杂凑函数H有n个可能的输出，H(x)是一个特定的输出，如果对H 随机取k个输入，则至少有一个输入y使得H(y)&#x3D;H(x)的概率为0.5时，k有多大？”对杂凑函数H寻找上述y的攻击为第I类生日攻击 H(y)&#x3D;H(x)的概率是1&#x2F;n &lt;&#x3D;&gt; H(y)≠H(x)的概率是1-1&#x2F;n y取k个随机值得到函数的k个输出中，至少有一个等于H(x)的概率为1-[1-1&#x2F;n]^k (约等于k&#x2F;n) 若使上述概率等于0.5，则k&#x3D;n&#x2F;2。如果H的输出为m比特长，即可 能的输出个数n&#x3D;2m，则k&#x3D;2^(m-1) 生日悖论问题描述：“在k个人中至少有两个人的生日相同的概率大于0.5时，k至少多大？”设有k个整数项，每一项都在1到n之间等可能地取值。P(n, k)：k个整数项中至少有两个取值相同的概率生日悖论就是求使得P(365,k)≥0.5的最小kP(365,23)&#x3D;0.5073，即只需23人 之所以称这一问题是悖论是因为： 当人数k给定时，得到的至少有两个人的生日相同的概率比想象的要大得多 生日悖论推广问题令P(n, k)&gt;0.5，可得 第二类生日攻击寻找函数H的具有相同输出的两个任意输入的攻击方式。 应用输出长度与碰撞-&gt;生日攻击给出了消息摘要长度的下界通常建议消息摘要的最小可接受的长度为128比特 SHA-1密码杂凑函数MD5哈希算法输入：任意长的消息（图中为K比特）分组：512比特输出：128比特的消息摘要。 安全杂凑算法SHA-1安全哈希算法(Secure Hash Algorithm, SHA)输入：小于264比特长的任意消息，分为512比特长的分组。输出：160比特长的消息摘要 算法处理步骤1)消息填充对消息填充，使得其比特长在模512下为448，即填充后消息的长度为 512的某一倍数减64，留出的64比特备用（￥）该步骤是必须的填充方式：第1位为1，其后各位皆为0 2)附加消息的长度留出的64比特（￥）来表示消息被填充前的长度 3)对MD缓冲区初始化使用160比特长的缓冲区存储中间结果和最终杂凑值缓冲区为5个32比特以big-endian方式存储数据的寄存器(A, B, C, D, E)分别为A&#x3D;67452301， B&#x3D;EFCDAB89， C&#x3D;98BADCFB， D&#x3D;10325476， E&#x3D;C3D2E1F0。 4)以分组为单位对消息进行处理（复杂）每一分组Yq都经一压缩函数处理，压缩函数由4轮处理 过程构成，每一轮又由20步迭代组成。第4轮的输出（即第80步迭代的输出）再与第1轮的输 入CV.q相加，以产生CV.(q+1)，其中加法是缓冲区5个字中的 每一个字与CV.q中相应的字模2^(32)相加。 5)输出消息输出消息的L个分组都被处理完后，最后 一个分组的输出即为160比特的消息摘要。 压缩函数SHA的压缩函数由4轮处理过程组成，每轮处理过程20步迭代运算组成公式解释： 字W.t的产生 常量字KtKt &#x3D; 0x5A827999 (0 &lt;&#x3D; t &lt;&#x3D; 19)Kt &#x3D; 0x6ED9EBA1 (20 &lt;&#x3D; t &lt;&#x3D; 39)Kt &#x3D; 0x8F1BBCDC (40 &lt;&#x3D; t &lt;&#x3D; 59)Kt &#x3D; 0xCA62C1D6 (60 &lt;&#x3D; t &lt;&#x3D; 79). SHA系列Hash函数 SM3密码杂凑函数输入：输入：小于264比特长的任意消息输出：哈希值长度为256比特 常量和函数IV、T.j为常量FF.j、GG.j如下P.0(X)、P.1(X)如下 1)数据填充目的是使填充后的数据长度为512的整数倍消息 的长度为l比特-&gt;首先将比特“1”添加到m的末尾，再添加k 个“0”，其中k满足l+1+k&#x3D;448 mod 512然后再添加一个64位比特串，该比特串是长度l的二进制表示 2)迭代压缩 3)消息扩展 -&gt;压缩函数 流程图 5)输出哈希值输出256比特的哈希值y&#x3D;ABCDEFGH SM3哈希算法的安全性 FF.j(X,Y,Z)和GG.j(X,Y,Z)是非线性函数，经过循环迭代后提供混淆作用 置换函数P.0(X)和P.1(X)是线性函数，经过循环迭代后提供扩散作用 SHA3密码杂凑函数结构采用了一种被称为海绵结构（海绵函数）的新的迭代结构海绵函数允许输入长度和输出长度都可变在海绵函数中，输入数据被分为固定长度的数据分组。每个分组逐次作为迭代的输入，同时上轮迭代的输出也反馈至下轮的迭代中，最终产生HASH码 特点 安全性可以抵御对Hash函数的现有攻击。到目前为止，没有发现它有严重的安全弱点。 灵活性可选参数配置，能够适应Hash函数的各种应用。 高效性设计简单，软硬件实现方便。在效率方面，它是高效的。尚未广泛应用，需要经过实践检验！","categories":[{"name":"笔记","slug":"笔记","permalink":"https://kievvv.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Cryptography","slug":"Cryptography","permalink":"https://kievvv.github.io/tags/Cryptography/"}]},{"title":"Hello World：建站日志","slug":"001HelloWorldLog","date":"2023-07-06T13:36:56.025Z","updated":"2023-07-25T14:02:32.586Z","comments":true,"path":"2023/07/06/001HelloWorldLog/","link":"","permalink":"https://kievvv.github.io/2023/07/06/001HelloWorldLog/","excerpt":"","text":"2023.7.6 21:38First Blog! 2023.7.18 更新主题： volantis 2023.7.19 小细节更新： 新增评论系统、启用滚动封面等 （图片文件过大导致加载较慢.. 2023.7.25 绑定域名：iullius.com 欢迎常来！","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://kievvv.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"HelloWorld","slug":"HelloWorld","permalink":"https://kievvv.github.io/tags/HelloWorld/"}]}],"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://kievvv.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"笔记","slug":"笔记","permalink":"https://kievvv.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"项目","slug":"项目","permalink":"https://kievvv.github.io/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"游记","slug":"游记","permalink":"https://kievvv.github.io/categories/%E6%B8%B8%E8%AE%B0/"}],"tags":[{"name":"Life","slug":"Life","permalink":"https://kievvv.github.io/tags/Life/"},{"name":"Cryptography","slug":"Cryptography","permalink":"https://kievvv.github.io/tags/Cryptography/"},{"name":"PrivacyProtection","slug":"PrivacyProtection","permalink":"https://kievvv.github.io/tags/PrivacyProtection/"},{"name":"Blockchain","slug":"Blockchain","permalink":"https://kievvv.github.io/tags/Blockchain/"},{"name":"Matlab","slug":"Matlab","permalink":"https://kievvv.github.io/tags/Matlab/"},{"name":"Netflix","slug":"Netflix","permalink":"https://kievvv.github.io/tags/Netflix/"},{"name":"Art","slug":"Art","permalink":"https://kievvv.github.io/tags/Art/"},{"name":"Photos","slug":"Photos","permalink":"https://kievvv.github.io/tags/Photos/"},{"name":"Fuzzing","slug":"Fuzzing","permalink":"https://kievvv.github.io/tags/Fuzzing/"},{"name":"Database","slug":"Database","permalink":"https://kievvv.github.io/tags/Database/"},{"name":"SQL","slug":"SQL","permalink":"https://kievvv.github.io/tags/SQL/"},{"name":"HelloWorld","slug":"HelloWorld","permalink":"https://kievvv.github.io/tags/HelloWorld/"}]}