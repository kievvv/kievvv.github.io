<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iullius’ Blog</title>
  
  
  <link href="https://kievvv.github.io/atom.xml" rel="self"/>
  
  <link href="https://kievvv.github.io/"/>
  <updated>2023-07-27T19:58:02.356Z</updated>
  <id>https://kievvv.github.io/</id>
  
  <author>
    <name>iullius</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQUIRREL：论文随记</title>
    <link href="https://kievvv.github.io/2023/07/28/SQUIRREL-review/"/>
    <id>https://kievvv.github.io/2023/07/28/SQUIRREL-review/</id>
    <published>2023-07-27T19:28:54.000Z</published>
    <updated>2023-07-27T19:58:02.356Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇Fuzzing测试相关论文的阅读随记，主要为了理清思路方法，文章题目是：<strong>SQUIRREL: Testing Database Management Systems with Language Validity and Coverage Feedback</strong>，2020年发表在CCS USA，一作是佐治亚理工学院的<a href="https://ieeexplore.ieee.org/author/37088950861">Rui Zhong</a>，二作<a href="https://changochen.github.io/">Yongheng Chen</a>（是CTFer！</p><p>相关链接如下：<a href="https://dl.acm.org/doi/pdf/10.1145/3372297.3417260">论文</a>，<a href="https://github.com/s3team/Squirrel">源码</a></p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><blockquote><p> Fuzzing is an increasingly popular technique for verifying software functionalities and finding security vulnerabilities. However, current mutation-based fuzzers cannot effectively test database management systems (DBMSs), which strictly check inputs for valid syntax and semantics. Generation-based testing can guarantee the syntax correctness of the inputs, but it does not utilize any feedback, like code coverage, to guide the path exploration. In this paper, we develop Sqirrel, a novel fuzzing framework that considers both language validity and coverage feedback to test DBMSs. We design an intermediate representation (IR) to maintain SQL queries in a structural and informative manner. To generate syntactically correct queries, we perform type-based mutations on IR, including statement insertion, deletion and replacement. To mitigate semantic errors, we analyze each IR to identify the logical dependencies between arguments, and generate queries that satisfy these dependencies. We evaluated Sqirrel on four popular DBMSs: SQLite, MySQL, PostgreSQL and MariaDB. Sqirrel found 51 bugs in SQLite, 7 in MySQL and 5 in MariaDB. 52 of the bugs are fixed with 12 CVEs assigned. In our experiment, Sqirrel achieves 2.4×243.9× higher semantic correctness than state-of-the-art fuzzers, and explores 2.0×-10.9× more new edges than mutation-based tools. These results show that Sqirrel is effective in finding memory errors in database management systems.</p></blockquote><p><strong>Fuzzing模糊测试 -&gt; 一种软件测试方法，通过半随机方式的数据发送以验证软件功能和查找安全漏洞</strong></p><ol><li><p>基于mutation的fuzzer<br> 因为DBMS严格检查输入-&gt;不可用</p></li><li><p>基于generation的fuzzer<br> -&gt;可以保证syntax correctness<br> 但不能利用feedback(代码覆盖率等)来引导探索路径</p></li></ol><p><strong>Squirrel</strong><br>    兼顾language validity和coverage feedback<br>    <strong>Intermediate Representation</strong> -&gt; 使得查询structural和informative<br>    <strong>Type-based mutation</strong> -&gt; 保证语法(syntactically)正确<br>    <strong>Semantics-Guided Instantiation</strong> -&gt; 保证语义(semantically)正确</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ol><li>Propose <strong>syntax-preserving mutation</strong> and <strong>semantics-guided instantiation</strong> to address the challenges of fuzzing DBMSs.</li><li>Implement Squirrel, an <strong>end-to-end system</strong> that <strong>combines mutation and generation</strong> to detect DBMS bugs.</li><li>Evaluated Squirrel on real-world DBMSs and identified <strong>63 memory error</strong> issues. The result shows that <strong>Squirrel outperforms existing tools on finding bugs from DBMSs</strong>.</li></ol><h1 id="Problem-Definition"><a href="#Problem-Definition" class="headerlink" title="Problem Definition"></a>Problem Definition</h1><h2 id="1-Query-Processing-in-DBMS"><a href="#1-Query-Processing-in-DBMS" class="headerlink" title="1. Query Processing in DBMS"></a>1. Query Processing in DBMS</h2><h3 id="How-a-DBMS-handles-SQL-queries"><a href="#How-a-DBMS-handles-SQL-queries" class="headerlink" title="How a DBMS handles SQL queries"></a>How a DBMS handles SQL queries</h3><h4 id="1-parse"><a href="#1-parse" class="headerlink" title="1) parse"></a>1) parse</h4><ul><li>First parses the query to get its syntactic meaning<ol><li>Breaks the query into individual tokens</li><li>Checks them against the grammar rules</li></ol></li></ul><h4 id="2-validation"><a href="#2-validation" class="headerlink" title="2) validation"></a>2) validation</h4><ul><li>Checks the semantic correctness of the query</li></ul><h4 id="3-ptimization"><a href="#3-ptimization" class="headerlink" title="3) ptimization"></a>3) ptimization</h4><ul><li>构造几个可能的查询计划 -&gt; 确定给定查询最有效的查询计划</li></ul><h4 id="4-execution"><a href="#4-execution" class="headerlink" title="4) execution"></a>4) execution</h4><ul><li>执行 + 返回</li></ul><blockquote><p>如果1, 2阶段不满足，则不会进行到3, 4</p></blockquote><h2 id="2-Challenges-of-DBMS-Testing"><a href="#2-Challenges-of-DBMS-Testing" class="headerlink" title="2 Challenges of DBMS Testing"></a>2 Challenges of DBMS Testing</h2><h3 id="Introduce-existing-DBMS-testing-techniques-amp-Illustrate-their-limitations"><a href="#Introduce-existing-DBMS-testing-techniques-amp-Illustrate-their-limitations" class="headerlink" title="Introduce existing DBMS testing techniques &amp; Illustrate their limitations"></a>Introduce existing DBMS testing techniques &amp; Illustrate their limitations</h3><h3 id="主要有两种DBMS测试方法："><a href="#主要有两种DBMS测试方法：" class="headerlink" title="主要有两种DBMS测试方法："></a>主要有两种DBMS测试方法：</h3><h4 id="1-model-based-generation-基于模型生成"><a href="#1-model-based-generation-基于模型生成" class="headerlink" title="1) model-based generation 基于模型生成"></a>1) model-based generation 基于模型生成</h4><h5 id="遵循精确的语法模型以生成语法正确的输入"><a href="#遵循精确的语法模型以生成语法正确的输入" class="headerlink" title="遵循精确的语法模型以生成语法正确的输入"></a>遵循精确的语法模型以生成语法正确的输入</h5><ul><li><strong>pros:</strong> 语法正确</li><li><strong>cons:</strong><br>  顺序扫描整个输入空间-&gt;不能有效搜索程序的状态空间<br>  很难保证语义正确性-&gt;会被过滤</li></ul><h4 id="2-random-mutation-随机变异"><a href="#2-random-mutation-随机变异" class="headerlink" title="2) random mutation 随机变异"></a>2) random mutation 随机变异</h4><h5 id="更新现有输入以生成新输入"><a href="#更新现有输入以生成新输入" class="headerlink" title="更新现有输入以生成新输入"></a>更新现有输入以生成新输入</h5><ul><li><strong>pros:</strong><br>  利用先前执行的反馈来评估生成的输入的优先级<br>  如果反馈表明之前的输入很有趣，模糊器会将其放入队列中以进行进一步的变异<br>  -&gt;可以有效地探索程序的状态空间</li><li><strong>cons:</strong><br>  在处理结构化输入方面效率低下(如SQL、JS)<br>   1. 随机翻转一个 SQL 关键字的位很难产生另一个有效的关键字<br>   2. 整个查询将在语法上变得不正确</li></ul><blockquote><p>AFL 生成的查询的验证率很低- &gt; 语义正确很重要</p></blockquote><h2 id="3-Our-Approach"><a href="#3-Our-Approach" class="headerlink" title="3 Our Approach"></a>3 Our Approach</h2><h3 id="Present-our-insight-to-solve-this-problem"><a href="#Present-our-insight-to-solve-this-problem" class="headerlink" title="Present our insight to solve this problem"></a>Present our insight to solve this problem</h3><h4 id="1-Generating-Syntax-Correct-Queries"><a href="#1-Generating-Syntax-Correct-Queries" class="headerlink" title="1) Generating Syntax-Correct Queries"></a>1) Generating Syntax-Correct Queries</h4><ul><li>IR-&gt;使得查询structural和informative</li><li>基于类型的突变来保证句法正确性<br>  -&gt;每个语句都有语法类型，每个数据都有语义类型</li><li>从每个 IR 中剥离具体数据，如表名，以专注于改变骨架</li></ul><h4 id="2-Improving-Semantic-Correctness"><a href="#2-Improving-Semantic-Correctness" class="headerlink" title="2) Improving Semantic Correctness"></a>2) Improving Semantic Correctness</h4><p>确保语义正确是NP-hard问题</p><ul><li>通过动态查询实例化 -&gt; 保证其 SQL 模板的表现力</li><li>给定语法正确的 SQL 查询的骨架 -&gt; 尝试用关系满足数据依赖图的具体操作数填充骨架</li><li>(根据预定义的基本规则构建其数据依赖图)</li></ul><h1 id="Overview-of-Sqirrel"><a href="#Overview-of-Sqirrel" class="headerlink" title="Overview of Sqirrel"></a>Overview of Sqirrel</h1><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-28%20033639.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-28%20033639.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="四个组成部分"><a href="#四个组成部分" class="headerlink" title="四个组成部分"></a>四个组成部分</h4><ol><li>Translator, </li><li>Mutator, </li><li>Instantiator,</li><li>SQL Fuzzer</li></ol><h4 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h4><ol><li>从查询队列中<strong>选一个查询I</strong></li><li><strong>IR Translator</strong>将查询I<strong>翻译成IR的向量V</strong><br> 同时从V中<strong>剥离具体值</strong>，使其<strong>成为骨架</strong></li><li><strong>Mutator</strong>生成<strong>新的向量V’</strong>(通过插入、删除、替换)<br> -&gt; V’语法正确</li><li><strong>Instantiator</strong>对V’进行<strong>数据依赖性分析</strong><br> （并构建新的数据依赖图）</li><li>Instantiator<strong>选择新的具体值填充V’</strong>,which满足数据依赖性</li><li>将V’转回SQL语句I‘</li><li>运行：<br> if 崩溃 -&gt; 找到触发错误的输入<br> else if 触发了新的执行路径 -&gt; 保存到队列</li></ol><h1 id="Intermediate-Representation-中间表示（IR-Translator）"><a href="#Intermediate-Representation-中间表示（IR-Translator）" class="headerlink" title="Intermediate Representation 中间表示（IR Translator）"></a>Intermediate Representation 中间表示（IR Translator）</h1><p><strong>SQL语句I转化成 -&gt; IR向量V -&gt; 改变成V’ -&gt; 转换回SQL语句I’</strong></p><ul><li>IR特点：expressive, general, simple</li></ul><h1 id="Syntax-Preserving-Mutation-语法保留突变"><a href="#Syntax-Preserving-Mutation-语法保留突变" class="headerlink" title="Syntax-Preserving Mutation 语法保留突变"></a>Syntax-Preserving Mutation 语法保留突变</h1><h3 id="Token区分"><a href="#Token区分" class="headerlink" title="Token区分"></a>Token区分</h3><ul><li><strong>structure</strong>：关键字 + 数学运算符<br>  改变structure会改变查询的操作，从而触发不同的功能</li><li><strong>data</strong>：常量值、名称等<br>  修改与语义相关的data可能会生成语义不正确的查询导致DBMS拒绝执行<br>  改变structure的影响更大-&gt;剥离数据，在结构上变异</li></ul><h2 id="1-Structure-Data-Separation"><a href="#1-Structure-Data-Separation" class="headerlink" title="1) Structure-Data Separation"></a>1) Structure-Data Separation</h2><ul><li>基本规则：用“x”替换语义数据，将常量数字更改为 1 或 1.0</li><li>在IR library存储不同的IR</li></ul><h2 id="2-Type-Based-Mutation"><a href="#2-Type-Based-Mutation" class="headerlink" title="2) Type-Based Mutation"></a>2) Type-Based Mutation</h2><ul><li><p>主要是operand的变异</p><p>-&gt; 要么修改整个IR，要么修改operand</p></li></ul><h3 id="三种变异"><a href="#三种变异" class="headerlink" title="三种变异"></a>三种变异</h3><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230509215933.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230509215933.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="Insertion插入"><a href="#Insertion插入" class="headerlink" title="Insertion插入"></a>Insertion插入</h4><h4 id="Replacement替换"><a href="#Replacement替换" class="headerlink" title="Replacement替换"></a>Replacement替换</h4><p> -&gt;在IR库中选择对应位置的孩子进行插入或替换</p><h4 id="Deletion删除"><a href="#Deletion删除" class="headerlink" title="Deletion删除"></a>Deletion删除</h4><h4 id="验证语法正确"><a href="#验证语法正确" class="headerlink" title="验证语法正确"></a>验证语法正确</h4><p>转回SQL语句，传入执行<br>    if 成功执行 -&gt; 语法正确，继续使用<br>    else -&gt; 丢弃</p><h1 id="Semantics-Guided-Instantiation-语义引导实例化"><a href="#Semantics-Guided-Instantiation-语义引导实例化" class="headerlink" title="Semantics-Guided Instantiation 语义引导实例化"></a>Semantics-Guided Instantiation 语义引导实例化</h1><h2 id="1-Data-Dependency-Inference"><a href="#1-Data-Dependency-Inference" class="headerlink" title="1) Data Dependency Inference"></a>1) Data Dependency Inference</h2><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230509220312.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230509220312.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br>灰色线是从属关系，黑色线是对等关系</p><p>细化数据类型，遵循<strong>lifetime原则：用前创建，删后不用</strong></p><p>关系规则是一个包含四个元素的元组（α,β,γ,S）：α是关系目标，β是关系源； γ 定义关系； S 表示关系的范围</p><h2 id="2-IR-Instantiation"><a href="#2-IR-Instantiation" class="headerlink" title="2) IR Instantiation"></a>2) IR Instantiation</h2><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230509221712.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230509221712.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><blockquote><p>dataMap：跟踪具有不同类型的唯一名称<br>relationMap：将每个元素映射到其依赖项</p></blockquote><h4 id="验证语义正确"><a href="#验证语义正确" class="headerlink" title="验证语义正确"></a>验证语义正确</h4><p>转回SQL语句，传入执行<br>    if 满足依赖性，成功执行 -&gt; 语义正确，继续使用<br>     else -&gt; 丢弃<br>    if interesting -&gt; 保存入队列</p><h1 id="Implementation-amp-Evaluation"><a href="#Implementation-amp-Evaluation" class="headerlink" title="Implementation &amp; Evaluation"></a>Implementation &amp; Evaluation</h1><p>此处略</p><h1 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h1><h3 id="1-DBMS-Specific-Logic"><a href="#1-DBMS-Specific-Logic" class="headerlink" title="1. DBMS-Specific Logic"></a>1. DBMS-Specific Logic</h3><p>-&gt;针对不同DBMS系统的SQL方言语法进行设计可以提高测试效果</p><h3 id="2-Relation-Rule-Construction"><a href="#2-Relation-Rule-Construction" class="headerlink" title="2. Relation-Rule Construction"></a>2. Relation-Rule Construction</h3><p>人工编写关系规则 -&gt; 自动推断（数据流分析&#x2F;深度学习）</p><h3 id="3-Collisions-in-Code-Coverage"><a href="#3-Collisions-in-Code-Coverage" class="headerlink" title="3. Collisions in Code-Coverage"></a>3. Collisions in Code-Coverage</h3><p>扩大Bitmap的大小以缓解Collision</p><h3 id="4-Alternative-Feedback-Mechanisms"><a href="#4-Alternative-Feedback-Mechanisms" class="headerlink" title="4. Alternative Feedback Mechanisms"></a>4. Alternative Feedback Mechanisms</h3><p>code coverage VS semantics-correct queries -&gt; 有害的代码覆盖率阻碍了语义正确查询的生成</p><h1 id="Related-Work-amp-Conclusion"><a href="#Related-Work-amp-Conclusion" class="headerlink" title="Related Work &amp; Conclusion"></a>Related Work &amp; Conclusion</h1><p>略</p><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p><strong>SQUIRREL: Testing Database Management Systems with Language Validity and Coverage Feedback</strong>这篇论文提出了一种新型的自动化测试工具Squirrel，它的主要作用是用于测试关系型数据库管理系统(DBMS)。这篇论文在2020年11月首次发表在2020 ACM SIGSAC Conference上，作者为来自宾夕法尼亚州立大学和佐治亚理工学院的Rui Zhong等6人，当前在Google学术上被引用次数为40次。</p><p>模糊测试是一种用于验证软件功能和查找软件安全漏洞的技术。但是，目前基于突变（mutation）的模糊器（fuzzer）无法有效测试会严格检查输入的语法语义正确性的数据库管理系统；基于生成（generation）的测试无法利用反馈来指导测试路径。</p><p>基于以上现状，本文整合了上述两种测试框架的优点，介绍了一种名为Sqirrel的新型模糊测试框架，用于测试数据库管理系统（DBMS），同时考虑了语言有效性和覆盖反馈。Squirrel使用中间表示（IR, Intermediate Representation）以结构化和信息化的方式维护SQL查询，并对IR进行基于类型的变异以生成语法正确的查询。它还分析每个IR以识别参数之间的逻辑依赖关系，并生成满足这些依赖关系的查询以减轻语义错误。</p><p>Squirrel的测试流程包括以下步骤： </p><ol><li>生成初始查询：Sqirrel使用基于模型的生成方法生成初始查询。</li><li>转换为IR：Sqirrel将初始查询转换为IR，以便于后续的变异和分析。 </li><li>变异：Sqirrel对IR进行基于类型的变异，以生成语法正确的查询。</li><li>依赖分析：Sqirrel分析每个IR以识别参数之间的逻辑依赖关系，并生成满足这些依赖关系的查询以减轻语义错误。</li><li>执行查询：Sqirrel执行生成的查询，并记录覆盖信息。</li><li>覆盖反馈：Sqirrel使用覆盖信息来指导下一轮变异，以提高测试效率和覆盖率。<br>这个流程不断迭代，直到达到预设的测试目标或者测试时间结束。<br>上述6个流程是对Squirrel框架的高度概括，在具体实现上仍有很多较为细节的步骤，保证了Squirrel框架的结果准确、逻辑合理、运算高效，整个框架的代码实现超过了四万行。</li></ol><p>随后，作者将Squirrel框架在真实的数据库管理系统上测试。主要关注以下三个问题：<br>是否能检测出内存漏洞？是否超过了SOTA的测试工具？语言正确性和覆盖率反馈在测试中的作用如何？</p><p>由此，将实验分为三个部分：语法正确性测试、语义正确性测试和性能测试。</p><p>在语法正确性和语义正确性测试中，作者使用Sqirrel、AFL、SQLsmith、QSYM、Angora和GRIMOIRE等六个工具对SQLite和MySQL进行测试，并比较了它们的测试效果。作者使用了10个已知的语法错误和缺陷来评估这些工具的测试效果，并计算了它们的错误检测率和测试时间。</p><p>在性能测试中，作者使用了Sqirrel、AFL、SQLsmith、QSYM、Angora和GRIMOIRE等六个工具对SQLite和MySQL进行测试，并比较了它们的测试效果。作者使用了10个已知的性能问题来评估这些工具的测试效果，并计算了它们的测试时间和覆盖率。</p><p>Sqirrel在40天内发现了四个流行的DBMSs上的63个内存错误问题，其中包括51个SQLite错误、7个MySQL错误和5个MariaDB错误。综合实验各项指标，其结果表明Sqirrel在语法正确性测试、语义正确性测试和性能测试中都表现出色，能够有效地检测出各种类型的错误和缺陷，并且具有较高的测试效率和覆盖率。</p><p>最后，对文章所做的研究不足之处及未来可以继续开展工作总结如下：</p><ol><li><p>提高测试效率：本文中提到Sqirrel的测试效率相对较低，需要较长的时间来生成测试用例。结合我自身复现代码的过程也印证了这一点。因此，未来的工作可以探索如何提高测试效率，例如使用并行化技术或者优化测试用例生成算法。</p></li><li><p>提高测试覆盖率：本文中Sqirrel的测试覆盖率仍有提升空间。未来的工作可以探索如何提高测试覆盖率，例如使用符号执行技术或者结合其他测试方法。</p></li><li><p>改进测试用例生成算法：本文中使用的测试用例生成算法可以生成语法正确的测试用例，但是无法保证语义正确。未来的工作可以探索如何改进测试用例生成算法，以提高测试用例的语义正确性。</p></li><li><p>扩展到其他类型的漏洞：本文中Sqirrel主要用于检测内存损坏漏洞，而数据库管理系统中存在的漏洞多种多样，面对的外部威胁更是防不胜防。未来的工作可以探索如何将Squirrel扩展到检测其他类型的漏洞，例如SQL注入漏洞或者逻辑漏洞等。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是一篇Fuzzing测试相关论文的阅读随记，主要为了理清思路方法，文章题目是：&lt;strong&gt;SQUIRREL: Testing Database Management Systems with Language Validity and Coverage Feedbac</summary>
      
    
    
    
    <category term="笔记" scheme="https://kievvv.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Fuzzing" scheme="https://kievvv.github.io/tags/Fuzzing/"/>
    
    <category term="Database" scheme="https://kievvv.github.io/tags/Database/"/>
    
    <category term="SQL" scheme="https://kievvv.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>密码学笔记</title>
    <link href="https://kievvv.github.io/2023/07/19/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://kievvv.github.io/2023/07/19/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2023-07-19T13:36:33.000Z</published>
    <updated>2023-07-19T14:04:52.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><h2 id="信息安全基本属性"><a href="#信息安全基本属性" class="headerlink" title="信息安全基本属性"></a>信息安全基本属性</h2><ul><li><strong>机密性 （Confidentiality）</strong><br>保证信息为授权者使用而不泄漏给未经授权者。<br>别人“看不到”或“看不懂”</li><li><strong>认证（Authentication）</strong><br>消息认证，保证消息来源的真实性<br>身份认证，确保通信实体的真实性<br>证明“你就是你”</li><li><strong>完整性 （Integrity）</strong><br>数据完整性，未被未授权篡改或者损坏<br>系统完整性，系统未被非授权操纵，按既定的功能运行<br>信息没有被“动过”</li><li><strong>不可否认性（Non-repudiation ）</strong><br>要求无论发送方还是接收方都不能抵赖所进行的传输</li><li><em>可靠性（Reliability）</em><br>特定行为和结果的一致性</li><li><em>可用性 （Availability）</em><br>保证信息和信息系统随时为授权者提供服务，而不要出现非授权者滥用却对授权者拒绝服务的情况。</li><li><em>可控性（Controllability）</em><br>授权实体可以控制信息系统和信息使用的特性</li><li><em>审计（Accountability）</em><br>确保实体的活动可被跟踪</li></ul><h2 id="密码编码学"><a href="#密码编码学" class="headerlink" title="密码编码学"></a>密码编码学</h2><h3 id="密码算法的分类"><a href="#密码算法的分类" class="headerlink" title="密码算法的分类"></a>密码算法的分类</h3><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230629170445.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230629170445.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="按功能"><a href="#按功能" class="headerlink" title="按功能"></a>按功能</h4><p>加密算法：用于机密性解决方案<br>杂凑函数：用于完整性解决方案<br>数字签名：用于认证和不可否认性</p><h4 id="按密钥的使用方式"><a href="#按密钥的使用方式" class="headerlink" title="按密钥的使用方式"></a>按密钥的使用方式</h4><p><strong>对称密钥密码</strong> : 加密密钥与解密密钥相同<br><strong>非对称密钥密码（公钥密码）</strong>:加密密钥与解密密钥不同<br>    公钥密码部分解决了对称密钥密码算法中<strong>密钥共享</strong>、<strong>密钥管理</strong>的问题。</p><ul><li><p>第一代公开的、完全说明细节的商业级密码标准是<strong>DES</strong></p></li><li><p>被动攻击与主动攻击<br>被动攻击-&gt;不影响通讯<br>网络嗅探、流量分析<br>主动攻击-&gt;影响通讯<br>网络中断、假冒身份、数据包篡改</p></li></ul><h2 id="密码分析学"><a href="#密码分析学" class="headerlink" title="密码分析学"></a>密码分析学</h2><h3 id="安全的概念"><a href="#安全的概念" class="headerlink" title="安全的概念"></a>安全的概念</h3><h4 id="Kerckhoffs假设"><a href="#Kerckhoffs假设" class="headerlink" title="Kerckhoffs假设"></a>Kerckhoffs假设</h4><p>假定密码分析者和敌手知道所使用的密码系统。 即<strong>密码体制的安全性仅依赖于对密钥的保密</strong>,而不应依赖于算法的保密。</p><h4 id="密码分析学的目标"><a href="#密码分析学的目标" class="headerlink" title="密码分析学的目标"></a>密码分析学的目标</h4><ol><li><strong>破译密文</strong></li><li><strong>破译密钥</strong></li><li><strong>破译出明文</strong></li></ol><p><em>密文是[破译]的基础，密钥是[破译]的核心目标，而明文虽然是有用的想要的信息，但它是[破译出]密钥后才有的产物，所以核心是破译密文和密钥</em></p><h3 id="密码分析方法的分类"><a href="#密码分析方法的分类" class="headerlink" title="密码分析方法的分类"></a>密码分析方法的分类</h3><h4 id="攻击密码体制的方法"><a href="#攻击密码体制的方法" class="headerlink" title="攻击密码体制的方法"></a>攻击密码体制的方法</h4><ol><li><strong>穷举攻击</strong>：通过<strong>试遍</strong>所有的密钥来进行破译。<br>对抗：可增大密钥的数量。</li><li><strong>统计分析攻击</strong>：通过分析密文和明文的<strong>统计规律</strong>来破译。<br>对抗：设法使明文和密文的统计规律不一样。</li><li><strong>解密变换攻击</strong>：针对加密变换的数学基础，通过<strong>数学求解</strong>设法找到解密变换。<br>对抗：选用具有坚实的数学基础和足够复杂的加密算法。</li></ol><h4 id="密码破译"><a href="#密码破译" class="headerlink" title="密码破译"></a>密码破译</h4><ol><li><p><strong>唯密文攻击（Ciphertext Only Attack）</strong>：在唯密文攻击中，<strong>攻击者只能获取到加密后的密文</strong>，没有任何关于明文或密钥的其他信息。攻击者的目标是通过分析密文来推断出明文或密钥的信息。</p></li><li><p><strong>已知明文攻击（Known Plaintext Attack）</strong>：在已知明文攻击中，<strong>攻击者可以获取到一些已知明文和对应的密文对</strong>。攻击者的目标是通过这些已知对来破解密钥或加密算法。</p></li><li><p><strong>选择明文攻击（Chosen Plaintext Attack）</strong>：在选择明文攻击中，<strong>攻击者可以选择一些明文，并获取对应的密文</strong>。攻击者可以根据这些选择的明文和对应的密文来分析加密算法或破解密钥。</p></li><li><p><strong>选择密文攻击（Chosen Ciphertext Attack）</strong>：在选择密文攻击中，<strong>攻击者可以选择一些密文，并获取对应的解密结果或其他与密文相关的信息</strong>。攻击者可以利用这些选择的密文和相关信息来破解密钥或分析加密算法。</p></li></ol><p><strong>以上攻击强度依次递增</strong></p><h3 id="无条件安全和计算上安全"><a href="#无条件安全和计算上安全" class="headerlink" title="无条件安全和计算上安全"></a>无条件安全和计算上安全</h3><h4 id="无条件安全的-不可破译的"><a href="#无条件安全的-不可破译的" class="headerlink" title="无条件安全的(不可破译的)"></a>无条件安全的(不可破译的)</h4><p>无论截获多少密文，都没有足够信息来唯一确定明文，则该密码是无条件安全的，即<strong>对算法的破译不比猜测有优势</strong></p><h4 id="计算上安全的"><a href="#计算上安全的" class="headerlink" title="计算上安全的"></a>计算上安全的</h4><p>使用<strong>有限资源</strong>对一个密码系统进行分析而未能破译，则该密码是强的或计算上安全的</p><h5 id="计算上安全的密码算法要满足的准则"><a href="#计算上安全的密码算法要满足的准则" class="headerlink" title="计算上安全的密码算法要满足的准则"></a>计算上安全的密码算法要满足的准则</h5><ol><li>破译密文的代价超过被加密信息的价值。</li><li>破译密文所花的时间超过信息的有用期。</li></ol><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p>Kerckhoffs假设指的是？<br>密码分析的目标在于？</p><h2 id="古典密码算法"><a href="#古典密码算法" class="headerlink" title="古典密码算法"></a>古典密码算法</h2><h3 id="置换密码"><a href="#置换密码" class="headerlink" title="置换密码"></a>置换密码</h3><p><strong>置换（Permutation）</strong><br>对明文字符或字符组进行位置移动的密码<br>明文的字母保持相同，但顺序被打乱了。<br>    值不变顺序变</p><h3 id="单表代替密码算法"><a href="#单表代替密码算法" class="headerlink" title="单表代替密码算法"></a>单表代替密码算法</h3><p><strong>代替(Substitution)</strong><br>密码构造一个或多个密文字母表，然后用密文 字母表中的字母或者字母组来代替明文字母或字母组，各字母或 字母组的相对位置不变，但其本身的值改变了。<br>    值变顺序不变</p><h4 id="加法密码"><a href="#加法密码" class="headerlink" title="加法密码"></a>加法密码</h4><p><strong>凯撒密码</strong></p><h4 id="乘法密码"><a href="#乘法密码" class="headerlink" title="乘法密码"></a>乘法密码</h4><h4 id="仿射密码"><a href="#仿射密码" class="headerlink" title="仿射密码"></a>仿射密码</h4><ul><li><p>仿射密码是乘法密码和加法密码的结合。<br>加密函数：y&#x3D;ax+b(mod26)<br>密钥：a，b<br>解密函数：x&#x3D;a^(-1)(y-b)(mod26)</p></li><li><p>缺点：不能对抗统计分析</p></li></ul><h3 id="多表代替密码算法"><a href="#多表代替密码算法" class="headerlink" title="多表代替密码算法"></a>多表代替密码算法</h3><p><strong>Vigenere（维吉尼亚）密码</strong></p><h2 id="可证明安全性"><a href="#可证明安全性" class="headerlink" title="可证明安全性"></a>可证明安全性</h2><h3 id="密码游戏与规约"><a href="#密码游戏与规约" class="headerlink" title="密码游戏与规约"></a>密码游戏与规约</h3><p>把密码破译归结到困难问题上，而当困难问题实际上是简单的：</p><ol><li>密码不安全，可通过解决困难问题来攻破</li><li>密码还是安全的，但是不是可证明安全</li></ol><h3 id="CDH假设"><a href="#CDH假设" class="headerlink" title="CDH假设"></a>CDH假设</h3><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230613233558.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230613233558.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h1 id="第二章-流密码"><a href="#第二章-流密码" class="headerlink" title="第二章 流密码"></a>第二章 流密码</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="一次一密"><a href="#一次一密" class="headerlink" title="一次一密"></a>一次一密</h3><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230609143652.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230609143652.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"><br>• 优点：<br>• 密钥随机产生，仅使用一次<br>• 无条件安全<br>• 加密和解密为加法运算，效率较高<br>• 缺点：<br>• 密钥长度至少与明文长度一样长<br>• 密钥共享困难，不太实用</p><p>• 改进：<br>• 种子密钥生成无限长的密钥（流密码的思想，共享一小段）</p><p>流密码的基本思想<br>• 利用密钥k产生一个密钥流z&#x3D;z0z1z2…，并使用如下规则对明文串<br>x&#x3D;x0x1x2…（加法或者简单处理方法）加密：<br>y&#x3D;y0y1y2…＝Ez0(x0)Ez1(x1) Ez2(x2)…，</p><h3 id="流密码的定义"><a href="#流密码的定义" class="headerlink" title="流密码的定义"></a>流密码的定义</h3><p>内部记忆元件的状态σi独立于明文字符的叫做同步流密码，否则叫<br>做自同步流密码。<br>在同步流密码中，由于zi&#x3D;f(k,σi)与明文字符无关，因而此时密文字符yi&#x3D;Ezi(xi)也不依赖于此前的明文字符。<br>可将同步流密码的加密器分成密钥流产生器和加密变换器两个部分。</p><h3 id="同步流密码"><a href="#同步流密码" class="headerlink" title="同步流密码"></a>同步流密码</h3><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230609160714.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230609160714.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p><p>密码设计者的最大愿望是设计出一个滚动密钥生成器，使得密<br>钥经其扩展成的密钥流序列具有如下性质：<br>极大的周期<br>良好的统计特性<br>抗线性分析</p><h3 id="有限状态自动机模型"><a href="#有限状态自动机模型" class="headerlink" title="有限状态自动机模型"></a>有限状态自动机模型</h3><p>有限状态自动机可用有向图表示，称为转移图<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230609161615.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230609161615.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"><br>箭头和箭尾代表状态，（)中前者代表引起状态改变的输入，后者代表状态改变后的输出</p><h3 id="密钥流生成器"><a href="#密钥流生成器" class="headerlink" title="密钥流生成器"></a>密钥流生成器</h3><p>密钥流产生器: 参数为k的有限状态自动机，<br>一个输出符号集Z、一个状态集∑、两个函数φ和ψ以及一个初始状态σ0组成。<br>状态转移函数φ:σi→σi+1，将当前状态σi变为一个新状态σi+1，<br>输出函数ψ:σi→zi，当前状态σi变为输出符号集中的一个元素zi。<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230609161759.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230609161759.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"><br>一般采用线性的φ和非线性的ψ<br>密钥流生成器可分成驱动部分和非线性组合部分<br>驱动部分是一个或多个线性反馈 移位寄存器。（LFSR是流密码构造的关键模块)</p><h2 id="二元序列的伪随机性"><a href="#二元序列的伪随机性" class="headerlink" title="二元序列的伪随机性"></a>二元序列的伪随机性</h2><h3 id="二元序列的相关概念"><a href="#二元序列的相关概念" class="headerlink" title="二元序列的相关概念"></a>二元序列的相关概念</h3><p>GF（2）上的一个无限序列-&gt;a&#x3D;(a1,a2,…,an,…)称为二元序列，若 ai属于GF(2)，0或者1。</p><p><strong>游程</strong><br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230609162824.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230609162824.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p><p><strong>自相关函数</strong></p><h3 id="伪随机序列满足条件"><a href="#伪随机序列满足条件" class="headerlink" title="伪随机序列满足条件"></a>伪随机序列满足条件</h3><p><strong>Golomb伪随机公设</strong><br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230609162943.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230609162943.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p><h2 id="线性反馈移位寄存器"><a href="#线性反馈移位寄存器" class="headerlink" title="线性反馈移位寄存器"></a>线性反馈移位寄存器</h2><h3 id="反馈移位寄存器"><a href="#反馈移位寄存器" class="headerlink" title="反馈移位寄存器"></a>反馈移位寄存器</h3><p>GF(2)上一个n级反馈移位寄存器由n个二元存储器与一个反馈函数f(a1,a2,…,an) 组成</p><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230609163935.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230609163935.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p><p>反馈函数f(a1,a2,…,an)是n元布尔函数，即函数的自变量和因变量只取0和1这 两个可能的值。</p><h3 id="线性反馈移位寄存器-1"><a href="#线性反馈移位寄存器-1" class="headerlink" title="线性反馈移位寄存器"></a>线性反馈移位寄存器</h3><p>反馈函数是个线性函数<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230609164316.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230609164316.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p><p><strong>密钥流的周期</strong><br>给定密钥流 ，如果存在整数r，使得 对于任意 ，都有 ，则称 r为该密钥流的一个周期， 称满足 的最小正整数为该密钥流的最小周期或简称周期。</p><h2 id="m-序列"><a href="#m-序列" class="headerlink" title="m-序列"></a>m-序列</h2><h3 id="线性反馈移位寄存器的多项式表示"><a href="#线性反馈移位寄存器的多项式表示" class="headerlink" title="线性反馈移位寄存器的多项式表示"></a>线性反馈移位寄存器的多项式表示</h3><p>定理2.2 p(x)|q(x)的充要条件是G(p(x)) Í G(q(x))</p><h3 id="m-序列产生的条件"><a href="#m-序列产生的条件" class="headerlink" title="m-序列产生的条件"></a>m-序列产生的条件</h3><h4 id="Golomb伪随机公设"><a href="#Golomb伪随机公设" class="headerlink" title="Golomb伪随机公设"></a>Golomb伪随机公设</h4><p>①在序列的一个周期内，0与1的个数相差至多为1。<br>②在序列的一个周期内，长为i的游程占游程总数的1&#x2F;2i (i&#x3D;1,2,…)，且在等长的游程中0的游程个数和1的游程个数相等。<br>③异相自相关函数是一个常数。</p><h3 id="m-序列安全性"><a href="#m-序列安全性" class="headerlink" title="m-序列安全性"></a>m-序列安全性</h3><h4 id="解方程方法"><a href="#解方程方法" class="headerlink" title="解方程方法"></a>解方程方法</h4><h4 id="线性反馈移位寄存器综合求解法"><a href="#线性反馈移位寄存器综合求解法" class="headerlink" title="线性反馈移位寄存器综合求解法"></a>线性反馈移位寄存器综合求解法</h4><h2 id="非线性序列"><a href="#非线性序列" class="headerlink" title="非线性序列"></a>非线性序列</h2><p>密钥流生成器可分解为<strong>驱动子系统</strong>和<strong>非线性组合子系统</strong><br>驱动子系统常用一个或多个线性反馈移位寄存器来实现<br>非线性组合子系统用非线性组合函数F来实现</p><p>密钥k扩展 而成的密钥流序列z应满足的性质：</p><ol><li>种子密钥的长度足够长（一般来说就是流密码的密钥长度）</li><li>极大的周期</li><li>良好的统计特性</li><li>极大的线性复杂度</li><li>极大的k错线性复杂度</li><li>抗统计分析</li><li>混乱性</li><li>扩散性</li><li>抗线性分析</li></ol><h3 id="Geffe序列生成器"><a href="#Geffe序列生成器" class="headerlink" title="Geffe序列生成器"></a>Geffe序列生成器</h3><h3 id="J-K触发器"><a href="#J-K触发器" class="headerlink" title="J-K触发器"></a>J-K触发器</h3><h3 id="Pless生成器"><a href="#Pless生成器" class="headerlink" title="Pless生成器"></a>Pless生成器</h3><h1 id="第三章-分组密码"><a href="#第三章-分组密码" class="headerlink" title="第三章 分组密码"></a>第三章 分组密码</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614213510.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614213510.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br>通常取n&#x3D;m<br>若n&lt;m ，则为有数据扩展的分组密码。<br>若n&gt;m ，则为有数据压缩的分组密码。</p><h2 id="安全性设计原则"><a href="#安全性设计原则" class="headerlink" title="安全性设计原则"></a>安全性设计原则</h2><h3 id="混淆原则-Confusion"><a href="#混淆原则-Confusion" class="headerlink" title="混淆原则(Confusion)"></a>混淆原则(Confusion)</h3><ul><li>混淆原则就是将密文、明文、密钥三者之间的统计关系和代数关系变 得尽可能复杂，使得敌手即使获得了密文和明文，也无法求出密钥的任何信息</li><li>即使获得了密文和明文的统计规律，也无法求出明文的新的信息</li></ul><ol><li><strong>明文</strong>不能由已知的明文，密文及少许密钥比特代数地或统计地表示出来。</li><li><strong>密钥</strong>不能由已知的明文，密文及少许密钥比特代数地或统计地表 示出来。</li></ol><p><strong>引入了非线性变化</strong></p><h3 id="扩散原则-Diffusion"><a href="#扩散原则-Diffusion" class="headerlink" title="扩散原则(Diffusion)"></a>扩散原则(Diffusion)</h3><ul><li>扩散原则就是应将明文的统计规律和结构规律散射到相当长的一段统计中去(Shannon的原话)</li><li>也就是说让明文中的每一位影响密文中的尽可能多的位，或者说让密 文中的每一位都受到明文中的尽可能多位的影响。<br>实际上扩散原则应该把密文和密钥的关系加进去，也就是<strong>要让密文中的每 一位影响尽可能多的位</strong></li></ul><h2 id="分组密码算法的要求"><a href="#分组密码算法的要求" class="headerlink" title="分组密码算法的要求"></a>分组密码算法的要求</h2><ul><li>分组长度n要足够大<br>防止明文穷举攻击</li><li>密钥量要足够大<br>使所有密钥同等地好+防止密钥穷举攻击</li><li>由密钥确定置换的算法要足够复杂<br>充分实现明文与密钥的扩散和混淆，没有简单的关系可循</li><li>加密和解密运算简单<br>易于高速实现</li><li>数据扩展</li><li>差错传播尽可能地小<br>一个密文分组的错误尽可能少的影响其他密文分组的解密</li></ul><h2 id="分组密码的结构"><a href="#分组密码的结构" class="headerlink" title="分组密码的结构"></a>分组密码的结构</h2><p>两种常见的分组密码结构是<strong>Feistel网络Feistel Net</strong>和 <strong>SP网络Substitution-permutation Net</strong></p><p>DES-&gt;Feistal<br>AES-&gt;SP</p><h3 id="代换"><a href="#代换" class="headerlink" title="代换"></a>代换</h3><p><strong>代换是输入集A到输出A’上的一一映射</strong><br>双射条件保证在给定k下可从密文惟一地恢复出原明文</p><h3 id="Feistel密码结构"><a href="#Feistel密码结构" class="headerlink" title="Feistel密码结构"></a>Feistel密码结构</h3><p>乘积密码指顺序地执行两个或多个基本密码系统，使得最后结果的密码强度高于每个基本密码系统产生的结果</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>分组大小<br>密钥大小<br>轮数<br>子密钥产生算法<br>轮函数</p><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><p>快速的软件实现<br>算法容易分析</p><h4 id="Feistel加密结构"><a href="#Feistel加密结构" class="headerlink" title="Feistel加密结构"></a>Feistel加密结构</h4><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614214856.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614214856.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br>将每组明文分成左右两半L0和R0，在进行完n轮迭代后，左右两半再合并到一起以产生密文分组<br>其中Ki是第i轮用的子密钥，由加密密钥K得到。一般地，各轮子密钥彼此不同而且与K也不同</p><h4 id="Feistel解密结构"><a href="#Feistel解密结构" class="headerlink" title="Feistel解密结构"></a>Feistel解密结构</h4><p>本质上和加密过程是一样的，子密钥Ki的次序与加密过程相反</p><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614215050.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614215050.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="DES算法"><a href="#DES算法" class="headerlink" title="DES算法"></a>DES算法</h3><h4 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h4><p>分组长度为64 bits (8 bytes)<br>密文分组长度也是64 bits<br>密钥长度为64 bits，有8 bits奇偶校验，有效密钥长度为56 bits</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>![[Pasted image 20230614220030.png]]<img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614220030.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614220030.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">初值置换IP</p><h5 id="16轮迭代的乘积变换"><a href="#16轮迭代的乘积变换" class="headerlink" title="16轮迭代的乘积变换"></a>16轮迭代的乘积变换</h5><h5 id="逆初值置换IP-1"><a href="#逆初值置换IP-1" class="headerlink" title="逆初值置换IP^-1"></a>逆初值置换IP^-1</h5><h4 id="轮函数"><a href="#轮函数" class="headerlink" title="轮函数"></a>轮函数</h4><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614220043.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614220043.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br>即<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614220114.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614220114.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="密钥编排"><a href="#密钥编排" class="headerlink" title="密钥编排"></a>密钥编排</h4><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614220247.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614220247.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br>即<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614220300.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614220300.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="填充Padding"><a href="#填充Padding" class="headerlink" title="填充Padding"></a>填充Padding</h4><p>给定加密消息的长度是随机的，按64bit分组时，最后一组消息 长度可能不足64 bit。可以填充一些数字，通常用最后1字节作为填 充指示符（PI）</p><h4 id="DES的安全性"><a href="#DES的安全性" class="headerlink" title="DES的安全性"></a>DES的安全性</h4><p>目前攻击DES的主要方法有时间-空间权衡攻击、差分攻击、线性攻击和相关 密钥攻击等方法<br><strong>线性攻击</strong>方法是最有效的一种方法</p><h4 id="多重DES"><a href="#多重DES" class="headerlink" title="多重DES"></a>多重DES</h4><p>多重DES就是使用多个密钥利用DES对明文进行多次加密<br>    可以增加密钥量</p><h5 id="双重DES"><a href="#双重DES" class="headerlink" title="双重DES"></a>双重DES</h5><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614220613.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614220613.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h6 id="中间相遇攻击"><a href="#中间相遇攻击" class="headerlink" title="中间相遇攻击"></a>中间相遇攻击</h6><h5 id="三重DES"><a href="#三重DES" class="headerlink" title="三重DES"></a>三重DES</h5><p>当k1&#x3D;k3时，则称为双密钥三重DES</p><h3 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h3><ul><li>工作模式：根据不同的数据格式和安全性要求, 以一个具体的分组密码算法为基础构造一个分组密码系统的方法</li></ul><h4 id="电码本-ECB-模式"><a href="#电码本-ECB-模式" class="headerlink" title="电码本(ECB)模式"></a>电码本(ECB)模式</h4><ul><li>直接利用加密算法分别对分组数据组加密<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614221318.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614221318.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br>优点：<br>（1）实现简单;<br>（2)不同明文分组的加密可并行实施，尤其是硬件实现时速度很快</li></ul><p>缺点：<br>（1）相同明文分组对应相同密文分组<br>（2）不能隐蔽明文分组的统计规律和结构规律,不能抵抗统计分析、重传和代换攻击</p><h4 id="密码分组链接-CBC-模式"><a href="#密码分组链接-CBC-模式" class="headerlink" title="密码分组链接(CBC)模式"></a>密码分组链接(CBC)模式</h4><ul><li>这种模式<strong>先将明文分组与上一次的密文块进行按比特异或</strong>，然后再进行加密处理<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614221546.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230614221546.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br>特点：</li></ul><ol><li>明文块的统计特性得到了隐蔽-&gt;各密文块不仅与当前明文块有关，而且还与以前的 明文块及初始化向量有关</li><li>具有有限的错误传播特性（两步）-&gt;一个密文块的错误将导致两个密文块不能正确解密</li><li>具有自同步功能-&gt;密文出现丢块和错块不影响后续密文块的解密</li></ol><h4 id="密码反馈-CFB-模式"><a href="#密码反馈-CFB-模式" class="headerlink" title="密码反馈(CFB)模式"></a>密码反馈(CFB)模式</h4><p>若待加密消息需按字符、字节或比特处理时，可采用CFB模式。 并称待加密消息按 r 比特处理的CFB模式为 r 比特CFB模式</p><ul><li>选取最左边的r比特 作为加密密钥<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616101732.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616101732.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></li></ul><p>特点</p><ol><li>相同明文（改变IV同样会导致相同的明文输入得到不同的加密 输出。IV无需保密</li><li>链接依赖性（链接机制致使密文组依赖于当前明文组和其前面的明文组，重排密文组会影响解密</li><li>错误的传播（一个或多个比特错误出现在任一个r比特的密文组中</li><li>错误恢复（自同步</li></ol><h4 id="输出反馈-OFB-模式"><a href="#输出反馈-OFB-模式" class="headerlink" title="输出反馈(OFB)模式"></a>输出反馈(OFB)模式</h4><p>OFB模式在结构上类似于CFB模式，但反馈的内容是DES的输出而不是密文！<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616101753.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616101753.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>特点：</p><ol><li>相同明文（改变IV同样会导致相同的明文输入得到不同的加密 输出</li><li>没有链接依赖性（密钥流是独立于明文的</li><li>没有错误传播（有一个或多个比特错误的任一密文字符仅会影响 该字符的解密</li><li>错误恢复（OFB模式能从密文比特错误中得以恢复，但在丢失密文 比特后就无法实现自同步了，这是因为丢失密文比特会破坏密钥流 的编排</li></ol><h4 id="计数器（CTR）模式"><a href="#计数器（CTR）模式" class="headerlink" title="计数器（CTR）模式"></a>计数器（CTR）模式</h4><p>（OFB模式的简化版本）<br>结构<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616103420.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616103420.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>优点：</p><ol><li>效率（可并行加密、预处理、吞吐量仅受可使用并行数量的限制</li><li>加密数据块的随机访问</li><li>可证明安全</li><li>简单性（只要求实现加密算法</li></ol><h3 id="前四类工作模式比较和选用"><a href="#前四类工作模式比较和选用" class="headerlink" title="前四类工作模式比较和选用"></a>前四类工作模式比较和选用</h3><ol><li><strong>ECB模式</strong>简单、高速，但最弱，易受重放和替换攻击，一般用于加密长度小于等于分组长度的消息。</li><li>明文不易丢信号，对明文的格式没有特殊要求的环境可选用<strong>CBC模式</strong>。需要完整性认证功能时也可选用该模式。</li><li>容易丢信号的环境，或对明文格式有特殊要求的环境，可选用<strong>CFB模式</strong>。</li><li>不易丢信号，但信号特别容易错，且明文冗余特别多，可选用<strong>OFB模式</strong>。</li></ol><h3 id="有限域"><a href="#有限域" class="headerlink" title="有限域"></a>有限域</h3><h3 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h3><h4 id="AES提出的背景"><a href="#AES提出的背景" class="headerlink" title="AES提出的背景"></a>AES提出的背景</h4><p>DES算法由于其密钥较短，难以抵抗现有的攻击，因此不再作 为加密标准</p><h4 id="AES算法框架和参数说明"><a href="#AES算法框架和参数说明" class="headerlink" title="AES算法框架和参数说明"></a>AES算法框架和参数说明</h4><h5 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h5><p>设计简单<br>速度快，编码紧凑<br>抵抗所有已知的攻击<br>没有采用Feistel结构，轮函数由3个不同的可逆均匀变 换构成的</p><h5 id="轮函数-1"><a href="#轮函数-1" class="headerlink" title="轮函数"></a>轮函数</h5><p>线性混合层-&gt;确保多轮之上的高度扩散<br>非线性层-&gt;将具有最优的“最坏情况非线性特性”的S盒并行使用，确保混淆特性<br>密钥加层-&gt;单轮子密钥简单的异或到中间状态上，实现一次性掩盖</p><h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616105100.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616105100.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="轮函数-2"><a href="#轮函数-2" class="headerlink" title="轮函数"></a>轮函数</h4><h5 id="字节代换（S盒）"><a href="#字节代换（S盒）" class="headerlink" title="字节代换（S盒）"></a>字节代换（S盒）</h5><p>解密用到逆S盒</p><h5 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h5><p>状态阵列的各行进行循环移位，不同行的移位量不同<br>0行：不动<br>1行：循环左移C1字节<br>2行：循环左移C2字节<br>3行：循环左移C3字节</p><p>解密则相应逆行移位</p><h5 id="列混淆"><a href="#列混淆" class="headerlink" title="列混淆"></a>列混淆</h5><p>列混合运算也可写为矩阵乘法</p><h5 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h5><p>轮密钥与状态进行逐比特异或<br>轮密钥由种子密钥通过密钥编排算法得到<br>轮密钥长度与分组长度相同</p><h4 id="AES密钥编排"><a href="#AES密钥编排" class="headerlink" title="AES密钥编排"></a>AES密钥编排</h4><p>由<strong>密钥扩展</strong>和<strong>轮密钥选取</strong>两部分组成</p><h3 id="SM4算法"><a href="#SM4算法" class="headerlink" title="SM4算法"></a>SM4算法</h3><ul><li>SM4是一个<strong>分组密码算法</strong>，<strong>分组长度和密钥长度均为128比特</strong>。加密算法与密钥扩展算法都采用<strong>32轮非线性迭代结构</strong></li></ul><h4 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h4><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616111713.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616111713.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h1 id="第四章-公钥密码"><a href="#第四章-公钥密码" class="headerlink" title="第四章 公钥密码"></a>第四章 公钥密码</h1><h2 id="对称密码的困境"><a href="#对称密码的困境" class="headerlink" title="对称密码的困境"></a>对称密码的困境</h2><p>-&gt;密钥共享和管理<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616112025.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616112025.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>-&gt;不支持“开放系统”<br>两个没有预先建立关系的用户<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616112909.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616112909.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h2 id="公钥密码体制"><a href="#公钥密码体制" class="headerlink" title="公钥密码体制"></a>公钥密码体制</h2><ul><li>主要思想：从一个方向计算非常容易，而 从另一个方向计算则很困难</li></ul><h3 id="公钥密码的理论基础-陷门单向函数"><a href="#公钥密码的理论基础-陷门单向函数" class="headerlink" title="公钥密码的理论基础: 陷门单向函数"></a>公钥密码的理论基础: <strong>陷门单向函数</strong></h3><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616112443.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616112443.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616112453.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616112453.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><ul><li><p>公钥加密结构<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616112635.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616112635.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></li><li><p>公钥认证结构<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616112721.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616112721.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></li><li><p>公钥密码体制的优势<br>密钥分发：公钥能够采用公开（认证的）信道进行传输；<br>密钥管理：在用户N个用户的系统中，每个用户只需安全保管自己的私钥和N-1个 其他用户的公钥。整个系统仅仅需要维护N个公钥；<br>开放系统：即使是没有预先建立关系的用户也能通过对方的公钥建立安全通信。</p></li><li><p>公钥密码的主要作用</p></li></ul><ol><li>公钥加密</li><li>数字签名</li><li>基于公钥的密钥分配</li></ol><h3 id="公钥密码算法的要求"><a href="#公钥密码算法的要求" class="headerlink" title="公钥密码算法的要求"></a>公钥密码算法的要求</h3><p>容易的：<br>接收方B产生密钥对（PK.B和SK.B）在计算上是容易的。<br>发方A对消息m加密以产生密文c，即c&#x3D;E.PKB[m]在计算上是容易的。<br>收方B用自己的秘密钥对c解密，即m&#x3D;D.SKB[c]在计算上是容易的。</p><p>不可行：<br>敌手由PKB求SKB在计算上是不可行的。<br>敌手由密文c和PKB恢复明文m在计算上是不可行的。</p><p>研究公钥密码算法就是要找出合适的陷门单向函数。</p><h3 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ol><li>选择两个大素数p, q 。</li><li>计算 m&#x3D;pq, z&#x3D;(p-1)(q-1) 。</li><li>随机选取 e（其中e&lt;n ）， e与z没有公因数。（ e, z“互为质数”）</li><li>选取d使得ed-1能够被z完全整除。 （换言之：ed mod z &#x3D; 1 ）</li><li>公钥是 (n,e)。私钥是(n,d) 。<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616114507.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616114507.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></li></ol><h4 id="加解密过程"><a href="#加解密过程" class="headerlink" title="加解密过程"></a>加解密过程</h4><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616114417.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616114417.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>例题<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616150625.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616150625.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>RSA的加密、解密过程都为求一个整数的整数次幂，再取模。如果按其 含义直接计算，则中间结果非常大，有可能超出计算机所允许的整数取值 范围。<br>而用模运算的性质：(a×b) mod n&#x3D;[(a mod n)×(b mod n)] mod n 就可减小中间结果。</p><h4 id="RSA密钥的产生"><a href="#RSA密钥的产生" class="headerlink" title="RSA密钥的产生"></a>RSA密钥的产生</h4><ol><li>两个大素数p、q的选取。-&gt;Miller-Rabin算法</li><li>e的选取和d的计算-&gt;选取满足1&lt;e&lt;φ(n)和gcd(φ(n),e)&#x3D;1的e，并计算满足d·e≡1 mod φ(n)的d。这一问题可由推广的Euclid算法完成。</li></ol><h4 id="RSA的安全性"><a href="#RSA的安全性" class="headerlink" title="RSA的安全性"></a>RSA的安全性</h4><p>RSA的安全性是基于<strong>分解大整数的困难性</strong>假定<br>RSA是确定性的加密算法, <strong>不能抵御选择密文攻击</strong>。</p><h5 id="几个困难问题"><a href="#几个困难问题" class="headerlink" title="几个困难问题"></a>几个困难问题</h5><ol><li>大整数分解问题（factorization problem）</li><li>离散对数问题（discrete logarithm problem）</li><li>多项式求根问题</li><li>二次剩余问题（quadratic residue problem）</li><li>背包问题（knapsack problem）</li></ol><h3 id="ElGamal公钥密码体制"><a href="#ElGamal公钥密码体制" class="headerlink" title="ElGamal公钥密码体制"></a>ElGamal公钥密码体制</h3><p>Elgamal加密<strong>基于CDH假设的单向性</strong></p><h4 id="ElGamal公钥密码体制历史"><a href="#ElGamal公钥密码体制历史" class="headerlink" title="ElGamal公钥密码体制历史"></a>ElGamal公钥密码体制历史</h4><h4 id="ElGamal公钥加密体制原理"><a href="#ElGamal公钥加密体制原理" class="headerlink" title="ElGamal公钥加密体制原理"></a>ElGamal公钥加密体制原理</h4><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616154338.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616154338.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>特点：</p><ol><li>安全性基于有限域上的离散对数的难解性</li><li>加密算法是概率算法</li><li>不能抵御选择密文攻击</li><li>存在密文扩张</li></ol><h4 id="ElGamal密码的安全性"><a href="#ElGamal密码的安全性" class="headerlink" title="ElGamal密码的安全性"></a>ElGamal密码的安全性</h4><p>参数要求：p应为150位以 上十进制数，500位以上的 二进制数，p-1应有大素数因子。<br>K必须保密而且必须是一次性的。</p><h3 id="ElGamal与RSA的区别"><a href="#ElGamal与RSA的区别" class="headerlink" title="ElGamal与RSA的区别"></a>ElGamal与RSA的区别</h3><ul><li>RSA：大整数分解问题</li><li>ElGamal：循环群的离散对数问题</li></ul><h3 id="椭圆曲线密码"><a href="#椭圆曲线密码" class="headerlink" title="椭圆曲线密码"></a>椭圆曲线密码</h3><p>椭圆曲线密码体制ECC（elliptic curve cryptography）可用短得多的密钥获得同样的安全性</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616160118.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616160118.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616160127.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616160127.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h4><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616160012.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616160012.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616160315.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616160315.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>安全性高</li><li>密钥量小-&gt;在实现相同的安全性能条件下，椭圆曲线密码 体制所需的密钥量远比基于有限域上的离散对数问题的公钥体制的密钥量小</li><li>灵活性好</li></ol><h3 id="SM2椭圆曲线公钥密码加密算法"><a href="#SM2椭圆曲线公钥密码加密算法" class="headerlink" title="SM2椭圆曲线公钥密码加密算法"></a>SM2椭圆曲线公钥密码加密算法</h3><h4 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h4><p>中国商用公钥密码标准算法<br>一组椭 圆曲线密码算法，其中包含加解密算法、数字签名算法<br>安全性都是<strong>基于求解椭圆曲线上的离散对数问题</strong>的困难性</p><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><h5 id="密钥产生"><a href="#密钥产生" class="headerlink" title="密钥产生"></a>密钥产生</h5><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616163259.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616163259.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h5 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h5><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616163317.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616163317.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h5 id="加密流程图"><a href="#加密流程图" class="headerlink" title="加密流程图"></a>加密流程图</h5><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616163338.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616163338.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h5 id="解密算法"><a href="#解密算法" class="headerlink" title="解密算法"></a>解密算法</h5><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616163453.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616163453.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h5 id="解密流程图"><a href="#解密流程图" class="headerlink" title="解密流程图"></a>解密流程图</h5><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616163628.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616163628.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="SM2与ECC的区别"><a href="#SM2与ECC的区别" class="headerlink" title="SM2与ECC的区别"></a>SM2与ECC的区别</h3><p>ECC算法通常采用NIST等国际机构建议的曲线及参数<br>SM2算法 的参数需要利用一定的算法产生-&gt;更安全</p><p>在ECC算法中，用户可以选择MD5、SHA-1等国际通用的哈希算法<br>SM2算法中则使用SM3哈希算法</p><p>SM的优点：解密算法中的检错</p><h1 id="第五章-哈希函数"><a href="#第五章-哈希函数" class="headerlink" title="第五章 哈希函数"></a>第五章 哈希函数</h1><h2 id="哈希函数的基本概念"><a href="#哈希函数的基本概念" class="headerlink" title="哈希函数的基本概念"></a>哈希函数的基本概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>将任意长的消息M映射为较短的、固定长度的一个值H(M)。<br>Hash函数也称为哈希函数、散列函数、压缩函数、杂凑函数、 指纹函数等<br>其函数值H(M)为哈希值、散列值、杂凑码、指 纹、消息摘要等</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>Hash函数的目的是为需认证的数据产生一个“指纹”</p><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><p>输入可以是任意长<br>输出是固定长<br>易于在软件和硬件实现</p><h3 id="安全条件"><a href="#安全条件" class="headerlink" title="安全条件"></a>安全条件</h3><ol><li>单向性</li><li>抗弱碰撞性</li><li>抗强碰撞性</li></ol><p>-&gt;三者有包含关系，满足后者即可满足前者</p><h2 id="生日攻击"><a href="#生日攻击" class="headerlink" title="生日攻击"></a>生日攻击</h2><h3 id="第一类生日攻击"><a href="#第一类生日攻击" class="headerlink" title="第一类生日攻击"></a>第一类生日攻击</h3><p>问题：“已知一杂凑函数H有n个可能的输出，H(x)是一个特定的输出，如果对H 随机取k个输入，则<strong>至少有一个输入y使得H(y)&#x3D;H(x)的概率为0.5时，k有多大？</strong>”<br>对杂凑函数H寻找上述y的攻击为<strong>第I类生日攻击</strong></p><p>H(y)&#x3D;H(x)的概率是1&#x2F;n &lt;&#x3D;&gt; H(y)≠H(x)的概率是1-1&#x2F;n</p><p>y取k个随机值得到函数的k个输出中，至少有一个等于H(x)的概率为1-[1-1&#x2F;n]^k (约等于k&#x2F;n)</p><p>若使上述概率等于0.5，则k&#x3D;n&#x2F;2。如果H的输出为m比特长，即可 能的输出个数n&#x3D;2m，则k&#x3D;2^(m-1)</p><h3 id="生日悖论"><a href="#生日悖论" class="headerlink" title="生日悖论"></a>生日悖论</h3><p>问题描述：“在k个人中<strong>至少有两个人的生日相同的概率大于0.5时，k至少多大？</strong>”<br>设有k个整数项，每一项都在1到n之间等可能地取值。<br>P(n, k)：k个整数项中至少有两个取值相同的概率<br><strong>生日悖论就是求使得P(365,k)≥0.5的最小k</strong><br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616174203.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616174203.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br>P(365,23)&#x3D;0.5073，即只需23人</p><p>之所以称这一问题是悖论是因为： 当人数k给定时，得到的至少有两个人的生日相同的概率比想象的要大得多</p><h4 id="生日悖论推广问题"><a href="#生日悖论推广问题" class="headerlink" title="生日悖论推广问题"></a>生日悖论推广问题</h4><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616174451.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616174451.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br>令P(n, k)&gt;0.5，可得<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616174530.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616174530.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="第二类生日攻击"><a href="#第二类生日攻击" class="headerlink" title="第二类生日攻击"></a>第二类生日攻击</h3><p>寻找函数H的具有相同输出的两个任意输入的攻击方式。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>输出长度与碰撞-&gt;生日攻击给出了消息摘要长度的下界<br>通常建议消息摘要的最小可接受的长度为128比特</p><h2 id="SHA-1密码杂凑函数"><a href="#SHA-1密码杂凑函数" class="headerlink" title="SHA-1密码杂凑函数"></a>SHA-1密码杂凑函数</h2><h3 id="MD5哈希算法"><a href="#MD5哈希算法" class="headerlink" title="MD5哈希算法"></a>MD5哈希算法</h3><p>输入：任意长的消息（图中为K比特）<br>分组：512比特<br>输出：128比特的消息摘要。</p><h3 id="安全杂凑算法SHA-1"><a href="#安全杂凑算法SHA-1" class="headerlink" title="安全杂凑算法SHA-1"></a>安全杂凑算法SHA-1</h3><p>安全哈希算法(Secure Hash Algorithm, SHA)<br>输入：小于264比特长的任意消息，分为512比特长的分组。<br>输出：160比特长的消息摘要<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616175152.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616175152.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="算法处理步骤"><a href="#算法处理步骤" class="headerlink" title="算法处理步骤"></a>算法处理步骤</h4><h5 id="1-消息填充"><a href="#1-消息填充" class="headerlink" title="1)消息填充"></a>1)消息填充</h5><p>对消息填充，使得其比特长在模512下为448，即填充后消息的长度为 512的某一倍数减64，留出的64比特备用（￥）<br>该步骤是必须的<br>填充方式：第1位为1，其后各位皆为0</p><h5 id="2-附加消息的长度"><a href="#2-附加消息的长度" class="headerlink" title="2)附加消息的长度"></a>2)附加消息的长度</h5><p>留出的64比特（￥）来表示消息被填充前的长度</p><h5 id="3-对MD缓冲区初始化"><a href="#3-对MD缓冲区初始化" class="headerlink" title="3)对MD缓冲区初始化"></a>3)对MD缓冲区初始化</h5><p>使用160比特长的缓冲区存储中间结果和最终杂凑值<br>缓冲区为5个32比特以big-endian方式存储数据的寄存器(A, B, C, D, E)<br>分别为A&#x3D;67452301， B&#x3D;EFCDAB89， C&#x3D;98BADCFB， D&#x3D;10325476， E&#x3D;C3D2E1F0。</p><h5 id="4-以分组为单位对消息进行处理（复杂）"><a href="#4-以分组为单位对消息进行处理（复杂）" class="headerlink" title="4)以分组为单位对消息进行处理（复杂）"></a>4)以分组为单位对消息进行处理（复杂）</h5><p>每一分组Yq都经一压缩函数处理，<strong>压缩函数</strong>由4轮处理 过程构成，每一轮又由20步迭代组成。<br>第4轮的输出（即第80步迭代的输出）再与第1轮的输 入CV.q相加，以产生CV.(q+1)，其中加法是缓冲区5个字中的 每一个字与CV.q中相应的字模2^(32)相加。<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616235416.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230616235416.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h5 id="5-输出消息"><a href="#5-输出消息" class="headerlink" title="5)输出消息"></a>5)输出消息</h5><p>输出消息的L个分组都被处理完后，最后 一个分组的输出即为160比特的消息摘要。</p><h4 id="压缩函数"><a href="#压缩函数" class="headerlink" title="压缩函数"></a>压缩函数</h4><p>SHA的压缩函数由4轮处理过程组成，每轮处理过程20步迭代运算组成<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617001018.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617001018.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br>公式解释：<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617001833.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617001833.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617002014.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617002014.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><ul><li><p>字W.t的产生<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617002113.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617002113.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></li><li><p>常量字Kt<br>Kt &#x3D; 0x5A827999 (0 &lt;&#x3D; t &lt;&#x3D; 19)<br>Kt &#x3D; 0x6ED9EBA1 (20 &lt;&#x3D; t &lt;&#x3D; 39)<br>Kt &#x3D; 0x8F1BBCDC (40 &lt;&#x3D; t &lt;&#x3D; 59)<br>Kt &#x3D; 0xCA62C1D6 (60 &lt;&#x3D; t &lt;&#x3D; 79).</p></li></ul><h3 id="SHA系列Hash函数"><a href="#SHA系列Hash函数" class="headerlink" title="SHA系列Hash函数"></a>SHA系列Hash函数</h3><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617002229.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617002229.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="SM3密码杂凑函数"><a href="#SM3密码杂凑函数" class="headerlink" title="SM3密码杂凑函数"></a>SM3密码杂凑函数</h3><p>输入：输入：小于264比特长的任意消息<br>输出：哈希值长度为256比特</p><h4 id="常量和函数"><a href="#常量和函数" class="headerlink" title="常量和函数"></a>常量和函数</h4><p>IV、T.j为常量<br>FF.j、GG.j如下<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617005202.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617005202.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br>P.0(X)、P.1(X)如下<br><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617005414.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617005414.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-数据填充"><a href="#1-数据填充" class="headerlink" title="1)数据填充"></a>1)数据填充</h4><p>目的是使填充后的数据长度为512的整数倍<br>消息 的长度为l比特-&gt;<br>首先将比特“1”添加到m的末尾，再添加k 个“0”，其中k满足l+1+k&#x3D;448 mod 512<br>然后再添加一个64位比特串，该比特串是长度l的二进制表示</p><h4 id="2-迭代压缩"><a href="#2-迭代压缩" class="headerlink" title="2)迭代压缩"></a>2)迭代压缩</h4><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617010111.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617010111.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="3-消息扩展"><a href="#3-消息扩展" class="headerlink" title="3)消息扩展"></a>3)消息扩展</h4><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617010251.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617010251.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="gt-压缩函数"><a href="#gt-压缩函数" class="headerlink" title="-&gt;压缩函数"></a>-&gt;压缩函数</h4><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617011430.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617011430.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617011527.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617011527.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="5-输出哈希值"><a href="#5-输出哈希值" class="headerlink" title="5)输出哈希值"></a>5)输出哈希值</h4><p>输出256比特的哈希值y&#x3D;ABCDEFGH</p><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617011655.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230617011655.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="SM3哈希算法的安全性"><a href="#SM3哈希算法的安全性" class="headerlink" title="SM3哈希算法的安全性"></a>SM3哈希算法的安全性</h4><ul><li>FF.j(X,Y,Z)和GG.j(X,Y,Z)是非线性函数，经过循环迭代后提供混淆作用</li><li>置换函数P.0(X)和P.1(X)是线性函数，经过循环迭代后提供扩散作用</li></ul><h3 id="SHA3密码杂凑函数"><a href="#SHA3密码杂凑函数" class="headerlink" title="SHA3密码杂凑函数"></a>SHA3密码杂凑函数</h3><h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><p>采用了一种被称为<strong>海绵结构</strong>（海绵函数）的新的迭代结构<br>海绵函数允许输入长度和输出长度都可变<br>在海绵函数中，输入数据被分为固定长度的数据分组。每个分组逐次作为迭代的输入，同时上轮迭代的输出也反馈至下轮的迭代中，最终产生HASH码</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>安全性<br>可以抵御对Hash函数的现有攻击。<br>到目前为止，没有发现它有严重的安全弱点。</li><li>灵活性<br>可选参数配置，能够适应Hash函数的各种应用。</li><li>高效性<br>设计简单，软硬件实现方便。在效率方面，它是高效的。<br>尚未广泛应用，需要经过实践检验！</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章-引言&quot;&gt;&lt;a href=&quot;#第一章-引言&quot; class=&quot;headerlink&quot; title=&quot;第一章 引言&quot;&gt;&lt;/a&gt;第一章 引言&lt;/h1&gt;&lt;h2 id=&quot;信息安全基本属性&quot;&gt;&lt;a href=&quot;#信息安全基本属性&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="笔记" scheme="https://kievvv.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="密码学" scheme="https://kievvv.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Hello World：建站日志</title>
    <link href="https://kievvv.github.io/2023/07/06/Hello%20World%EF%BC%9A%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/"/>
    <id>https://kievvv.github.io/2023/07/06/Hello%20World%EF%BC%9A%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/</id>
    <published>2023-07-06T13:36:56.025Z</published>
    <updated>2023-07-25T14:02:32.586Z</updated>
    
    <content type="html"><![CDATA[<p>2023.7.6  21:38<br>First Blog!</p><hr><p>2023.7.18</p><p>更新主题：</p><p><a href="https://github.com/volantis-x/hexo-theme-volantis">volantis</a></p><hr><p>2023.7.19</p><p>小细节更新：</p><p>新增评论系统、启用滚动封面等</p><p>（图片文件过大导致加载较慢..</p><hr><p>2023.7.25</p><p>绑定域名：<a href="http://iullius.com/">iullius.com</a></p><p>欢迎常来！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2023.7.6  21:38&lt;br&gt;First Blog!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2023.7.18&lt;/p&gt;
&lt;p&gt;更新主题：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/volantis-x/hexo-theme-volantis&quot;&gt;vola</summary>
      
    
    
    
    <category term="杂谈" scheme="https://kievvv.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="HelloWorld" scheme="https://kievvv.github.io/tags/HelloWorld/"/>
    
  </entry>
  
</feed>
