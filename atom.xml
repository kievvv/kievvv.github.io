<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iullius’ Blog</title>
  
  
  <link href="https://kievvv.github.io/atom.xml" rel="self"/>
  
  <link href="https://kievvv.github.io/"/>
  <updated>2024-06-19T12:39:51.687Z</updated>
  <id>https://kievvv.github.io/</id>
  
  <author>
    <name>iullius</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>对抗攻击四种算法实现(FGSM、BIM、PGD、MIFGSM)</title>
    <link href="https://kievvv.github.io/2024/06/19/011FourAdvAttack/"/>
    <id>https://kievvv.github.io/2024/06/19/011FourAdvAttack/</id>
    <published>2024-06-19T12:15:42.000Z</published>
    <updated>2024-06-19T12:39:51.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FGSM"><a href="#FGSM" class="headerlink" title="FGSM"></a>FGSM</h2><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>快速梯度符号法（Fast Gradient Sign Method，FGSM）是一种最早的对抗攻击方法之一。其基本思想是通过计算输入图像在损失函数上的梯度，并沿着梯度上升方向对图像进行扰动，从而生成对抗样本。具体公式为：</p><p>$$ x_{\text{adv}} &#x3D; x + \epsilon \cdot \text{sign}(\nabla_x J(\theta, x, y)) $$ </p><p>其中，$x_{\text{adv}}$ 为对抗样本，$x$为原始输入，$\epsilon$为扰动强度，$\nabla_x J(\theta, x, y)$为损失函数$J$对输入$x$的梯度。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>FGSM的核心算法在FGSM类中实现，除了初始化方法以外，这个类只有唯一一个函数，即攻击函数attack。这部分在示例代码中已经完成，但之后的攻击算法都基于这一函数实现，因此这里对这一函数进行详细分析，attack函数实现如下：</p><pre><code class="python">def attack(self):    perturbed_img=[]    perturbed_label=[]    org_img=[]    org_label=[]    wrong=0    right=0    success=0    for i,(img,label) in enumerate(self.data()):        if i==self.num_size:            break        tensor_img = paddle.to_tensor(img)        tensor_label=paddle.to_tensor(label)        tensor_img.stop_gradient = False        predict = self.model(tensor_img)        pred=predict.argmax(axis=1)        if pred == tensor_label:#如果被正确分类则执行攻击            right+=1            loss = self.criterion(predict, tensor_label)            loss.backward()            grad = paddle.to_tensor(tensor_img.grad)            grad = paddle.sign(grad)            adv_img = tensor_img + self.epsilon * grad            #攻击完成之后再次预测            predict = self.model(adv_img)            pred=predict.argmax(axis=1)            if pred!=tensor_label:                success+=1                #将攻击后的图片保存下来                adv_img=paddle.transpose(adv_img,perm=[0,2,3,1]).numpy()                tensor_img=paddle.transpose(tensor_img,perm=[0,2,3,1]).numpy()                adv_img=np.squeeze(adv_img)                tensor_img=np.squeeze(tensor_img)                adv_img=adv_img*127.5+127.5                tensor_img=tensor_img*127.5+127.5                adv_img=adv_img.astype(np.int64)                perturbed_img.append(adv_img)                tensor_img=tensor_img.astype(np.int64)                org_img.append(tensor_img)                org_label.append(tensor_label.numpy())                perturbed_label.append(pred.numpy())        else:            wrong+=1            continue    if right:                succ_rate=success/right    else :        print(&quot;全都预测错误&quot;)        return     print(right)    return succ_rate,perturbed_img,org_img,perturbed_label,org_label</code></pre><p>这一函数定义了一些初始变量，然后遍历数据图片，首先将图片输入模型以获取分类结果，对正确分类的图片进行攻击，计算损失，然后反向传播计算梯度，获取梯度符号后计算对抗样本，在图片上添加对抗样本。然后将对抗图片输入模型重新预测，比较预测结果与真实标签，并进行结果计数。然后保存结果，将攻击后的图片和原始图片进行转置、去除维度、反归一化、类型转换等处理后再保存到相应列表，根据结果计数来计算攻击成功率并返回。</p><p>返回结果分别为攻击成功率、攻击后图片、原始图片、攻击后分类标签、原始分类标签。这里的攻击成功率<code>succ_rate</code>由两个计数变量<code>right</code>和<code>success</code>计算得出，其中<code>right</code>是原始模型分类正确的图片数，<code>success</code>是原本分类正确而攻击后分类错误的图片数，攻击成功率计算公式为<code>succ_rate=success/right</code>。</p><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p>接下来进行效果测试，这里的模型（model）为vgg16，损失函数为交叉熵损失，批大小（batch size）为1，扰动大小设为4，数据量为1000，运行结果如下：</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192018755.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192018755.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240619163249698"></p><p>FGSM方法的攻击成功率约为73.4%，运行时间为57秒左右。</p><p>使用示例代码对攻击结果进行可视化，如下：</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192019945.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192019945.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="下载"></p><p>上图中第一行为原始图片及正确分类结果，而第二行为攻击后图片及攻击后分类结果。</p><h2 id="BIM"><a href="#BIM" class="headerlink" title="BIM"></a>BIM</h2><h3 id="算法原理-1"><a href="#算法原理-1" class="headerlink" title="算法原理"></a>算法原理</h3><p>基本迭代法（Basic Iterative Method, BIM）是快速梯度符号法（FGSM）的扩展版本。它通过在每一步迭代中对输入图像进行小幅度扰动，从而生成更具欺骗性的对抗样本。与FGSM不同，BIM通过多次迭代累积梯度，从而在每一步扰动中逐渐增强对抗效果。BIM的公式为：</p><p>$$<br>x^{(n+1)}<em>{\text{adv}} &#x3D; \text{clip}</em>{x, \epsilon} \left{ x^{(n)}<em>{\text{adv}} + \alpha \cdot \text{sign}(\nabla</em>{x^{(n)}<em>{\text{adv}}} J(\theta, x, y)) \right}<br>$$<br>其中， $x^{(n)}</em>{\text{adv}}$ 表示第$n$次迭代后的对抗样本，$\alpha$ 为每一步的扰动大小， $\epsilon$为总扰动范围，$\text{clip}$操作用于确保对抗样本在合法范围内。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>以下是BIM的代码实现的核心部分，与FGSM相比，主要的不同之处在于多次迭代和每次迭代中的裁剪操作。</p><pre><code class="python">    if pred== tensor_label:#如果被正确分类则执行攻击        right+=1        # Add code        for iter in range(self.num_iters):# 多次迭代            adv_img.stop_gradient = False            predict=model(adv_img)            loss = self.criterion(predict, tensor_label)            for parameter in self.model.parameters():                parameter.clear_grad()            loss.backward(retain_graph=True)            grad = paddle.to_tensor(adv_img.grad)            delta = self.alpha * paddle.sign(grad)            tmp_img = adv_img + delta            tensor_img=paddle.to_tensor(img)            clip_delta = paddle.clip(tmp_img-tensor_img, min=-self.epsilon, max=self.epsilon)            adv_img=adv_img+clip_delta            #攻击完成之后再次预测            predict = self.model(adv_img)            pred=predict.argmax(axis=1)            if pred!=tensor_label:                success+=1                #将攻击后的图片保存下来                adv_img=paddle.transpose(adv_img,perm=[0,2,3,1]).numpy()                tensor_img=paddle.transpose(tensor_img,perm=[0,2,3,1]).numpy()                adv_img=np.squeeze(adv_img)                tensor_img=np.squeeze(tensor_img)                adv_img=adv_img*127.5+127.5                tensor_img=tensor_img*127.5+127.5                adv_img=adv_img.astype(np.int64)                perturbed_img.append(adv_img)                tensor_img=tensor_img.astype(np.int64)                org_img.append(tensor_img)                org_label.append(tensor_label.numpy())                perturbed_label.append(pred.numpy())                break# 成功的退出迭代        #end addcode</code></pre><p>BIM实际上是FGSM的迭代版本，依据FGSM方法获取对抗样本并添加，在每次迭代后进行clip操作以控制扰动强度，在每次迭代后进行分类预测，如果成功则退出迭代，或者达到最大迭代次数自动退出。</p><h3 id="运行测试-1"><a href="#运行测试-1" class="headerlink" title="运行测试"></a>运行测试</h3><p>接下来进行效果测试，这里的模型（model）同样为vgg16，损失函数为交叉熵损失，批大小（batch size）为1，扰动大小设为4，数据量为1000，运行结果如下：</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192019923.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192019923.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240619165725962"></p><p>FGSM方法的攻击成功率约为90.6%，运行时间为1分26秒左右。</p><p>使用示例代码对攻击结果进行可视化，如下：</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192019157.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192019157.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="下载 (1)"></p><p>上图中第一行为原始图片及正确分类结果，而第二行为攻击后图片及攻击后分类结果。</p><h2 id="PGD"><a href="#PGD" class="headerlink" title="PGD"></a>PGD</h2><h3 id="算法原理-2"><a href="#算法原理-2" class="headerlink" title="算法原理"></a>算法原理</h3><p>投影梯度下降法（Projected Gradient Descent, PGD）是BIM的一个扩展版本，它被认为是最有效的第一阶对抗攻击方法之一。PGD方法通过多次迭代，在每一步应用FGSM生成扰动，然后将扰动结果投影回合法的输入范围。具体来说，PGD可以看作是带有投影操作的BIM方法。PGD的公式如下：</p><p> $$ x^{(0)}<em>{\text{adv}} &#x3D; x + \delta, \quad \delta \sim \mathcal{U}(-\epsilon, \epsilon) \ x^{(n+1)}</em>{\text{adv}} &#x3D; \text{clip}<em>{x, \epsilon} \left{ x^{(n)}</em>{\text{adv}} + \alpha \cdot \text{sign}(\nabla_{x^{(n)}_{\text{adv}}} J(\theta, x, y)) \right} $$ </p><p>其中，$x^{(0)}<em>{\text{adv}}$是初始对抗样本，通过在原始输入上添加一个均匀分布的随机噪声$\delta$生成。每一步迭代通过在当前对抗样本上添加扰动$\alpha \cdot \text{sign}(\nabla</em>{x^{(n)}_{\text{adv}}} J(\theta, x, y))$，并使用$\text{clip}$操作将结果投影回合法范围$[x - \epsilon, x + \epsilon]$。</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>以下是PGD的代码实现的核心部分，与BIM相比，PGD在初始时添加了一个随机噪声，并且每一步都包含投影操作。</p><pre><code class="python">if pred== tensor_label:#如果被正确分类则执行攻击    right+=1    delta_init = paddle.uniform(img.shape, dtype=&#39;float32&#39;, min=-self.epsilon, max=self.epsilon)    clip_delta = paddle.clip(delta_init, -self.epsilon, self.epsilon)    tensor_img_iter = tensor_img+clip_delta    for iter in range(self.num_iters):        tensor_img_iter.stop_gradient=False        predict=self.model(tensor_img_iter)        loss = self.criterion(predict, tensor_label)        for param in self.model.parameters():            param.clear_grad()        loss.backward(retain_graph=True)        grad = paddle.to_tensor(tensor_img_iter.grad)        delta = self.alpha * paddle.sign(grad)        tensor_img = paddle.to_tensor(img)        tmp_img = tensor_img_iter+delta        clip_delta = paddle.clip(tmp_img-tensor_img, min=-self.epsilon, max=self.epsilon)        adv_img = tensor_img_iter+clip_delta        #攻击完成之后再次预测        predict = self.model(adv_img)        pred = predict.argmax(axis=1)        if pred != tensor_label:            success += 1            #将攻击后的图片保存下来            adv_img = paddle.transpose(adv_img,perm=[0,2,3,1]).numpy()            # tensor_img = paddle.to_tensor(img)            tensor_img = paddle.transpose(tensor_img,perm=[0,2,3,1]).numpy()            adv_img = np.squeeze(adv_img)            tensor_img = np.squeeze(tensor_img)            adv_img = adv_img*127.5+127.5            tensor_img = tensor_img*127.5+127.5            adv_img = adv_img.astype(np.int64)            perturbed_img.append(adv_img)            tensor_img = tensor_img.astype(np.int64)            org_img.append(tensor_img)            org_label.append(tensor_label.numpy())            perturbed_label.append(pred.numpy())            break        tensor_img_iter = adv_img</code></pre><p>相比BIM，PGD方法的改进主要体现在初始随机噪声的引入，而随机噪声的生成方法，对攻击效果和速度都有明显的影响，这里尝试多种随机噪声生成方法。</p><p>均匀分布：</p><pre><code class="python">delta_init = paddle.uniform(img.shape, dtype=&#39;float32&#39;, min=-self.epsilon, max=self.epsilon)</code></pre><p>高斯分布：</p><pre><code class="python">delta_init = paddle.normal(shape=img.shape, mean=0.0, std=self.epsilon)</code></pre><p>随机分布</p><pre><code class="python">delta_init = paddle.rand(shape=img.shape) * self.epsilon</code></pre><p>这些生成方法各自具有特点，在运行测试部分测试它们的效果并进行对比分析。</p><h3 id="运行测试-2"><a href="#运行测试-2" class="headerlink" title="运行测试"></a>运行测试</h3><p>以下进行了三次运行测试，分别为均匀分布、高斯分布和随机分布的测试结果，最大迭代次数（num_iter）均设置为5：</p><p>均匀分布：</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192019451.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192019451.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240619170940855"></p><p>高斯分布：</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192020933.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192020933.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240619173858006"></p><p>随机分布：</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192021860.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192021860.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240619174325726"></p><p>在最大迭代次数设置为5时，均匀分布运行速度最快，而随机分布的攻击成功率最高。但通过与BIM方法的结果对比，这一系列攻击测试的成功率明显偏低，在80%-83%左右，与预期不符，推测是由于最大迭代次数设置得过小，攻击方法尚未收敛，于是将最大迭代次数（num_iter）调整为15，进行重复测试，结果分别如下：</p><p>均匀分布：</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192020457.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192020457.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240619173421987"></p><p>高斯分布：</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192019277.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192019277.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240619171916719"></p><p>随机分布：</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192021262.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192021262.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240619174808506"></p><p>可以看到，均匀分布和高斯分布的攻击成功率均有明显提高，达到了94%以上，但随机分布的攻击成功率反而有所下降。结合上面的测试结果，<strong>均匀分布生成随机噪声的PGD方法总体表现最好，高斯分布其次，而随机分布方法受到随机性影响，稳定性较差。</strong>同时，相较BIM方法，PGD攻击达到收敛所需的迭代次数更多，应设置更大的最大迭代次数以确保收敛，因此耗费的计算资源和时间也更多，但其攻击成功率也有相应的提升。</p><p>将以上不同噪声生成方法在不同最大迭代次数下运行所用的时间及其最终攻击成功率作成柱状图，以供直观地比较不同噪声生成方法的性能差异，如下图：</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192022360.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192022360.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240619194355982"></p><h2 id="MIFGSM"><a href="#MIFGSM" class="headerlink" title="MIFGSM"></a>MIFGSM</h2><h3 id="算法原理-3"><a href="#算法原理-3" class="headerlink" title="算法原理"></a>算法原理</h3><p>MIFGSM（Momentum Iterative Fast Gradient Sign Method）是一种改进的对抗攻击方法，基于FGSM的基础，通过引入动量项来加速收敛和提高攻击的稳定性。与传统的FGSM（Fast Gradient Sign Method）相比，MIFGSM在每次迭代中积累梯度信息，从而更有效地找到对抗样本。</p><p>MIFGSM 是一种利用动量加速收敛的对抗攻击方法。迭代过程如下：</p><ul><li><p>对于$t &#x3D; 1$到$T$（迭代次数），首先计算损失相对于输入的梯度：$\nabla_{\mathbf{x}^\mathrm{adv}<em>{t-1}} J(\mathbf{x}^\mathrm{adv}</em>{t-1}, y_{true})$</p></li><li><p>使用动量累积梯度：$\mathbf{g}<em>t &#x3D; \alpha \cdot \mathbf{g}</em>{t-1} + \frac{\nabla_{\mathbf{x}^\mathrm{adv}<em>{t-1}} J(\mathbf{x}^\mathrm{adv}</em>{t-1}, y_{true})}{|\nabla_{\mathbf{x}^\mathrm{adv}<em>{t-1}} J(\mathbf{x}^\mathrm{adv}</em>{t-1}, y_{true})|_1}$</p></li><li><p>使用这一公式更新对抗样本：$\mathbf{x}^\mathrm{adv}<em>t &#x3D; \mathrm{clip}(\mathbf{x}^\mathrm{adv}</em>{t-1} + \mathrm{clip}(\alpha \cdot \mathrm{sign}(\mathbf{g}_t), -\epsilon, \epsilon), \mathbf{x} - \epsilon, \mathbf{x} + \epsilon)$</p></li></ul><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><p>MIFGSM的代码核心实现如下，与FGSM的区别主要在动量项g的引入并利用其来累计梯度。</p><pre><code class="python">if pred == tensor_label:#如果被正确分类则执行攻击    right+=1    # Add code    g = 0#动量初始化    for iter in range(self.num_iters):        adv_img.stop_gradient=False        predict = self.model(adv_img)        loss = self.criterion(predict, tensor_label)        for param in self.model.parameters():            param.clear_grad()        loss.backward(retain_graph=True)        grad = paddle.to_tensor(adv_img.grad)        g = g * self.decay_factor + grad / paddle.norm(grad,p=1)#使用动量累积梯度        delta = self.alpha * paddle.sign(g)        tensor_img = paddle.to_tensor(img)        tmp_img = adv_img + delta        clip_delta = paddle.clip(tmp_img - tensor_img, -self.epsilon, self.epsilon)        adv_img = adv_img + clip_delta        #攻击完成之后再次预测        predict = self.model(adv_img)        pred = predict.argmax(axis = 1)        if pred != tensor_label:            success += 1            #将攻击后的图片保存下来            adv_img = paddle.transpose(adv_img,perm=[0,2,3,1]).numpy()            tensor_img = paddle.transpose(tensor_img,perm=[0,2,3,1]).numpy()            adv_img = np.squeeze(adv_img)            tensor_img = np.squeeze(tensor_img)            adv_img = adv_img*127.5+127.5            tensor_img = tensor_img*127.5+127.5            adv_img = adv_img.astype(np.int64)            perturbed_img.append(adv_img)            tensor_img = tensor_img.astype(np.int64)            org_img.append(tensor_img)            org_label.append(tensor_label.numpy())            perturbed_label.append(pred.numpy())            break    # end addcode</code></pre><p>相比FGSM，MIFGSM在开始攻击之初引入了动量项g，根据动量累积公式更新g的值，然后再更新<code>delta</code>；同时MIFGSM也是一个迭代方法，动量项g会在每次迭代中更新，同时也保留了上一次循环的信息。</p><h3 id="运行测试-3"><a href="#运行测试-3" class="headerlink" title="运行测试"></a>运行测试</h3><p>接下来进行效果测试，这里的模型（model）为vgg16，损失函数为交叉熵损失，批大小（batch size）为1，扰动大小设为4，最大迭代次数（num_iters）为5，数据量为1000，衰减因子（decay_factor）为1，运行结果如下：</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192021148.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192021148.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240619191202726"></p><p>MIFGSM方法的攻击成功率约为86.6%，运行时间为1分36秒左右。</p><p>使用示例代码对攻击结果进行可视化，如下：</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192021973.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202406192021973.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="下载 (2)"></p><p>上图中第一行为原始图片及正确分类结果，而第二行为攻击后图片及攻击后分类结果。</p><h2 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h2><p>为了横向对比四个攻击方法的性能差异，将同样超参数下的攻击数据作成如下表格，最大迭代次数均为5，如下表：</p><table><thead><tr><th>攻击方法</th><th>时间 (秒)</th><th>攻击成功率 (%)</th></tr></thead><tbody><tr><td>FGSM</td><td>57</td><td>73.4</td></tr><tr><td>BIM</td><td>86</td><td>90.6</td></tr><tr><td>PGD</td><td>87</td><td>82.8</td></tr><tr><td>MIFGSM</td><td>96</td><td>86.6</td></tr></tbody></table><p>在本场景下，用时最快的方法为FGSM，用时最久为MIFGSM；攻击成功率最高的方法为BIM，攻击成功率最低的为FGSM。但上述对比不能完全体现方法的优劣，仍需结合具体场景和不同算法的特点选取合适的攻击方法。</p><p>首先，FGSM 是一种简单而高效的对抗攻击方法，其优点在于计算速度快，因为只需进行一次梯度计算和一次扰动操作，而它的缺点是生成的对抗样本可能会被防御机制检测出来，因为扰动较大且不一定最优。</p><p>BIM 是在FGSM基础上发展而来的迭代攻击方法，相比FGSM具有更高的攻击成功率，但也会增加计算成本和生成时间。其优点在于相对较高的攻击成功率和适应性，可以绕过一些简单的防御机制，但可能需要更多的迭代次数和计算资源。</p><p>PGD 是一种更强大的迭代对抗攻击方法，PGD通常可以在较大的扰动范围内找到最优的对抗样本，因此具有较高的攻击成功率。它的缺点在于需要更多的迭代次数和计算成本，尤其是在处理复杂的模型和数据集时。</p><p>MIFGSM是基于动量的迭代FGSM方法，MIFGSM在FGSM和PGD之间找到了一种平衡，相比于普通的FGSM，具有更高的攻击成功率，同时相比于PGD，计算成本相对较低。然而，MIFGSM可能需要调节更多的超参数来达到最优效果，并且在处理不同模型和数据集时表现可能有所不同。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;FGSM&quot;&gt;&lt;a href=&quot;#FGSM&quot; class=&quot;headerlink&quot; title=&quot;FGSM&quot;&gt;&lt;/a&gt;FGSM&lt;/h2&gt;&lt;h3 id=&quot;算法原理&quot;&gt;&lt;a href=&quot;#算法原理&quot; class=&quot;headerlink&quot; title=&quot;算法原理&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="笔记" scheme="https://kievvv.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="AI Security" scheme="https://kievvv.github.io/tags/AI-Security/"/>
    
  </entry>
  
  <entry>
    <title>2023年终总结</title>
    <link href="https://kievvv.github.io/2023/12/31/010review_of_2023/"/>
    <id>https://kievvv.github.io/2023/12/31/010review_of_2023/</id>
    <published>2023-12-30T18:48:20.000Z</published>
    <updated>2024-01-04T16:30:07.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2023年终总结"><a href="#2023年终总结" class="headerlink" title="2023年终总结"></a>2023年终总结</h1><p>能够选择，是一项莫大的权力。2023年，我的可选项比以往来说都要多。至于我怎么选的，请看VCR：</p><h2 id="Jan"><a href="#Jan" class="headerlink" title="Jan."></a>Jan.</h2><p>买相机了</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310249291.JPG" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310249291.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_7666" width="70%" height="70%" /><p>跟同学爬楼</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310249351.JPG" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310249351.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_7727" width="70%" height="70%" /><p>去年春节，祝各位奉旨发财！</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310249125.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310249125.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA0762" width="70%" height="70%" /><h2 id="Feb"><a href="#Feb" class="headerlink" title="Feb."></a>Feb.</h2><p>海边</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310249330.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310249330.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA1998" width="70%" height="70%" /><p>第一次公费比赛</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310249295.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310249295.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_8361" width="70%" height="70%" /><h2 id="Mar"><a href="#Mar" class="headerlink" title="Mar."></a>Mar.</h2><p>久违，香港</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310250884.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310250884.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_8847" width="70%" height="70%" /><p>HKU</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310250462.JPG" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310250462.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_8869" width="70%" height="70%" /><p>草间弥生展</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310250311.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310250311.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_8740" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312311234254.JPG" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312311234254.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_8797" width="70%" height="70%" /><p>弥敦道</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310250391.JPG" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310250391.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2813" width="70%" height="70%" /><p>年度最佳风光照</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310250758.JPG" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310250758.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_8964" width="70%" height="70%" /><p>龚琳娜老师</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253844.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253844.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_9177" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253876.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253876.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_9193" width="70%" height="70%" /><h2 id="Apr"><a href="#Apr" class="headerlink" title="Apr."></a>Apr.</h2><p>南头古城</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253872.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253872.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA3692" width="70%" height="70%" /><p>计组…</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253519.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253519.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_9703" width="70%" height="70%" /><h2 id="May"><a href="#May" class="headerlink" title="May."></a>May.</h2><p>烫头了</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253969.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253969.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_9964" width="70%" height="70%" /><p>壮壮妈</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253644.JPG" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253644.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_0125" width="70%" height="70%" /><p>演出-《龙舌兰》</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253898.JPG" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253898.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="DSC_8318" width="70%" height="70%" /><p>国赛体验</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253668.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253668.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_0273" width="70%" height="70%" /><h2 id="Jun"><a href="#Jun" class="headerlink" title="Jun."></a>Jun.</h2><p>特种兵-长沙</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253086.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253086.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_0414" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253549.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253549.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_0390" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253908.JPG" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253908.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_0419" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253578.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253578.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_0490" width="70%" height="70%" /><p>年度最佳甜品</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253302.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253302.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_0475" width="70%" height="70%" /><p>过生日</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253060.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253060.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="7b4a485b5c3aa1966dae918a84cea2be" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253780.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253780.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_0527" width="70%" height="70%" /><p>年度最佳晚霞</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253459.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253459.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_0609" width="70%" height="70%" /><p>年度印象最深刻的演出-《Happy Now?》</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253400.JPG" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253400.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_0817" width="70%" height="70%" /><p>公费旅行-桂林</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253089.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253089.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_0958" width="70%" height="70%" /><p>每天都是阴雨</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253644.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253644.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_0946" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253236.JPG" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310253236.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_0952" width="70%" height="70%" /><h2 id="Jul"><a href="#Jul" class="headerlink" title="Jul."></a>Jul.</h2><p>后期末生活</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252723.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252723.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_0994" width="70%" height="70%" /><p>深圳湾</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252282.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252282.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_1091" width="70%" height="70%" /><p>欢乐谷-雪域雄鹰</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252529.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252529.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_1206" width="70%" height="70%" /><p>西湾红树林</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252599.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252599.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_1097" width="70%" height="70%" /><p>蛇口</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252235.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252235.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_2931" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252600.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252600.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_2908" width="70%" height="70%" /><p>第一次做勾线摆件</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252359.JPG" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252359.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_1295" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252224.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252224.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_1299" width="70%" height="70%" /><p>暑假回家前吃顿好的！</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252531.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252531.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_1323" width="70%" height="70%" /><p>平云山-露营</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252870.JPG" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252870.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_1378" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252293.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252293.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_1364" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252838.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252838.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_1372" width="70%" height="70%" /><p>在山上半夜被热得受不了，帐篷里都是小虫子</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252096.JPG" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252096.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_1391" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252225.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252225.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_1505" width="70%" height="70%" /><h2 id="Aug"><a href="#Aug" class="headerlink" title="Aug."></a>Aug.</h2><p>在家</p><p>我的comfort zone</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252846.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252846.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_1615" width="70%" height="70%" /><p>最后的卷毛</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252263.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252263.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_1532" width="70%" height="70%" /><p>跟家人一起</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252152.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252152.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_1901" width="70%" height="70%" /><p>假期消遣</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252732.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252732.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_1950" width="70%" height="70%" /><p>在湛江</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252417.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252417.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_1704" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252003.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252003.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="373d193c8c396ae73dbc4c9eade364f6" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252710.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252710.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="4aa9edd09c32733dee78f0b66f05e571" width="70%" height="70%" /><p>杨千嬅演唱会</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252188.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252188.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_2168" width="70%" height="70%" /><p>山顶的朋友</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252909.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252909.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_2192" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252177.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252177.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_2234" width="70%" height="70%" /><h2 id="Sep"><a href="#Sep" class="headerlink" title="Sep."></a>Sep.</h2><p>开学了</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252710.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310252710.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_2797" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312311511671.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312311511671.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_2680" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251216.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251216.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_2696" width="70%" height="70%" /><p>演出-《What was I made for》</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312311221399.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312311221399.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="3484a1ad30cdf9ec6b3d02a3ebeabfe" width="70%" height="70%" /><h2 id="Oct"><a href="#Oct" class="headerlink" title="Oct."></a>Oct.</h2><p>最五味杂陈的一个月</p><p>国庆去玩了：香港-澳门-顺德</p><p>又来了，香港</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251792.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251792.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA5237" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251040.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251040.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1ee361b5ca4d03538053bb67171596a3" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251902.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251902.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="8dd159f9abf8ad7d3fd188d0e8e092b8" width="70%" height="70%" /><p>故宫博物馆-互赠生日卡</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251966.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251966.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_2908 (1)" width="70%" height="70%" /><p>久违，澳门</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251950.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251950.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="4c7a62ce441592067c71f754c82eb730" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251382.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251382.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="178211edbdb63f55b959487538f1155d" width="70%" height="70%" /><p>又来了，顺德</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251287.JPG" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251287.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_3134" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251014.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251014.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_3092" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251700.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251700.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_3102" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251130.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251130.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_3561" width="70%" height="70%" /><p>月初开心的事情是旅行和见家人，月末开心的事情是和雅思分手</p><p>中间闹心的部分就不回忆了..</p><h2 id="Nov"><a href="#Nov" class="headerlink" title="Nov."></a>Nov.</h2><p>舞台-《胡桃夹子》</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251566.JPG" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251566.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="fa8c6eb4cs8b32fce94aed8484dc1ee9" width="70%" height="70%" /><p>盐田千春展</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251032.JPG" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251032.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_4123" width="70%" height="70%" /><p>2023年11月27日，年度最开心的一天</p><p>以评委身份回母校，it means a lot!</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251656.JPG" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251656.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_4362" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251263.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251263.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_4309" width="70%" height="70%" /><p>和高中班主任jw，一起回忆了一些我的PTSD，发现很多事情其实已经释怀了</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251962.JPG" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251962.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_4308" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251574.JPG" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251574.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_4369" width="70%" height="70%" /><p>Isaac Gracie-演唱会</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251171.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251171.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_4354" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251669.JPG" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251669.JPG" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_4377" width="70%" height="70%" /><h2 id="Dec"><a href="#Dec" class="headerlink" title="Dec."></a>Dec.</h2><p>结项了，真的很开心！</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251275.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251275.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="5c9433c1b56e5f3bb77069dd79ab7d4a" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251395.jpeg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312310251395.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IMG_4640" width="70%" height="70%" /><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312311225598.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312311225598.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="0dd0115dfa12fdc6d90b10b857e94eb" width="70%" height="70%" /><hr><p>2023年，普普通通地活着，如果突然想做什么事，能做的就做了。身边的人一直在，同时也认识了很多新朋友，解锁了很多新体验。</p><p>新年愿望是：希望家人身体健康，希望身边的人和自己人生顺利，希望世界上所有猫猫狗狗被善良对待，希望世界和平。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2023年终总结&quot;&gt;&lt;a href=&quot;#2023年终总结&quot; class=&quot;headerlink&quot; title=&quot;2023年终总结&quot;&gt;&lt;/a&gt;2023年终总结&lt;/h1&gt;&lt;p&gt;能够选择，是一项莫大的权力。2023年，我的可选项比以往来说都要多。至于我怎么选的，请看VC</summary>
      
    
    
    
    <category term="杂谈" scheme="https://kievvv.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="Life" scheme="https://kievvv.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>CKKS与BFV算法的图片同态加密、密态检索与同态解密</title>
    <link href="https://kievvv.github.io/2023/12/11/009CKKS_BFV_FHE/"/>
    <id>https://kievvv.github.io/2023/12/11/009CKKS_BFV_FHE/</id>
    <published>2023-12-11T11:57:43.000Z</published>
    <updated>2024-06-19T12:25:18.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CKKS与BFV算法的图片同态加密、密态检索与同态解密"><a href="#CKKS与BFV算法的图片同态加密、密态检索与同态解密" class="headerlink" title="CKKS与BFV算法的图片同态加密、密态检索与同态解密"></a>CKKS与BFV算法的图片同态加密、密态检索与同态解密</h1><p>本文基于<a href="https://github.com/OpenMined/TenSEAL">TenSEAL</a>库实现，是《数据安全与隐私保护》课程Project，由于是课程作业性质，这里的重点放在了运行效率的比较，没有将server端和client段做严谨区分，context的公私钥分离也略显潦草。本文的源码可以在<a href="https://github.com/kievvv/ckks_bfv_ImgFHE">这里</a>找到，仅供参考，若想深入学习请查看官方文档。</p><p>如果不了解同态加密，以下是一些供参考的文章：</p><p><a href="https://zhuanlan.zhihu.com/p/77478956">同态加密Homomorphic Encryption介绍</a></p><p><a href="https://zhuanlan.zhihu.com/p/54484449">全同态加密算法深入解析</a></p><p><a href="https://blog.csdn.net/shn111/article/details/124594241">同态加密详解</a></p><p>这是同态加密实现的经典逻辑框图：</p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312112014663.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312112014663.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20231211201406187" style="zoom: 67%;" /><p>以下是正文：</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>全同态加密（Fully Homomorphic Encryption，FHE）是一种密码学技术，允许在加密状态下执行计算操作，而无需解密数据。本实验选用两种常见的全同态加密方案，即CKKS（Cheon-Kim-Kim-Song）和BFV（Brakerski-Vaikuntanathan-Gentry）。</p><h3 id="CKKS（Cheon-Kim-Kim-Song）"><a href="#CKKS（Cheon-Kim-Kim-Song）" class="headerlink" title="CKKS（Cheon-Kim-Kim-Song）"></a>CKKS（Cheon-Kim-Kim-Song）</h3><p>CKKS 是一种基于环的全同态加密方案。环是一种数学结构，允许在加密域上进行多项式运算。CKKS 方案主要用于处理实数和复数，因此在机器学习和数据分析等领域中得到广泛应用。</p><p>主要特点：</p><ul><li>支持加法和乘法运算。</li><li>适用于实数和复数的加密计算。</li><li>允许动态调整安全参数以平衡安全性和性能。</li></ul><h3 id="BFV（Brakerski-Vaikuntanathan-Gentry）"><a href="#BFV（Brakerski-Vaikuntanathan-Gentry）" class="headerlink" title="BFV（Brakerski-Vaikuntanathan-Gentry）"></a>BFV（Brakerski-Vaikuntanathan-Gentry）</h3><p>BFV 是一种基于多项式环的全同态加密方案。它是 Gentry 的经典全同态加密方案的改进版本，旨在提高效率和应用范围。</p><p>主要特点：</p><ul><li>支持加法、乘法和混合运算（同时进行加法和乘法）。</li><li>允许在多项式环上进行计算。</li><li>提供更高的效率和灵活性，适用于更广泛的应用场景。</li></ul><h3 id="TenSEAL"><a href="#TenSEAL" class="headerlink" title="TenSEAL"></a>TenSEAL</h3><p>TenSEAL是一个基于 Microsoft Research 的 Simple Encrypted Arithmetic Library（SEAL）的同态加密库。它是专为支持深度学习任务中的同态加密操作而设计的，与 PySyft 框架集成，以支持联邦学习和安全多方计算。</p><p>主要特点和功能：</p><ol><li><strong>SEAL 基础：</strong> TenSEAL建立在 Microsoft Research 提供的 SEAL 库之上，该库专注于提供同态加密的基础原语。这使得 TenSEAL 可以充分利用 SEAL 的强大功能，同时为用户提供更高层次的接口。</li><li><strong>同态加密支持：</strong> TenSEAL 提供了同态加密的功能，使得用户可以在加密状态下执行计算，而无需解密敏感数据。</li><li><strong>PySyft 集成：</strong> TenSEAL 与 PySyft 框架集成，支持联邦学习和安全多方计算。这使得 TenSEAL 能够与 PySyft 中的其他工具和库协同工作，实现更广泛的隐私保护应用。</li><li><strong>CKKS 和 BFV 算法：</strong> TenSEAL 实现了两种常见的同态加密算法，即 CKKS 和 BFV。这两种算法分别适用于不同的使用场景，CKKS 用于处理实数和复数，而 BFV 用于通用的多项式环上的计算。</li></ol><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p><strong>从开源的库中选择一个开源库验证比较不同全同态加密算法的效率。</strong></p><ul><li><strong>场景设置：</strong><br>1）选取M张64*64（或更大的图片）加密存储于数据库 or 文件中；<br>2） 对于一张查询图片，在密态下跟数据库 or文件中加密图像进行匹配。</li><li><strong>要求：</strong><br>1） report实验环境（如，操作系统，CPU型号，内存等）<br>2） report同一开源库中不同FHE算法的计算效率（多测几次求平均）<br>3） 总结分析所测试算法的优劣</li></ul><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><table><thead><tr><th align="center">操作系统</th><th align="center">CPU型号</th><th align="center">内存</th></tr></thead><tbody><tr><td align="center">Linux Ubuntu 22.04.3</td><td align="center">AMD Ryzen 7 5800H(16 CPUs)</td><td align="center">16Gb</td></tr></tbody></table><p>本实验的图片数据集使用CelebA数据集，选取前100张做加密测试。</p><h2 id="实验流程与代码实现"><a href="#实验流程与代码实现" class="headerlink" title="实验流程与代码实现"></a>实验流程与代码实现</h2><p>本实验选用基于python的TenSEAL库，实现了CKKS和BFV两种全同态加密算法对批量图片文件的加密、解密、存储和密态检索，同时本实验进行多次测试，比较了同一同态加密库不同算法的加密、解密和检索效率，本部分主要汇报实验和代码实现流程，因为两算法实现流程类似，因此以CKKS为例子进行详细分析。</p><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><p>本代码需包含以下库：</p><pre><code class="python">import tenseal as tsimport sqlite3from PIL import Imageimport numpy as npimport osfrom time import time</code></pre><p>本代码主函数如下：</p><pre><code class="python">if __name__ == &quot;__main__&quot;:    # 定义 CKKS context，并分离公私钥    context = ts.context(        ts.SCHEME_TYPE.CKKS, poly_modulus_degree=8192, coeff_mod_bit_sizes=[60, 40, 40, 60]    )    context.generate_galois_keys()    context.global_scale = 2**40  # 设置全局缩放因子    ckks_secret_key = context.secret_key()    context.make_context_public()    # 创建或连接到 SQLite 数据库    conn = sqlite3.connect(&quot;ckks_encrypted_images.db&quot;)    cursor = conn.cursor()    # 创建表以存储加密向量    cursor.execute(&#39;&#39;&#39;        CREATE TABLE IF NOT EXISTS EncryptedImages (            id INTEGER PRIMARY KEY AUTOINCREMENT,            encrypted_red BLOB,            encrypted_green BLOB,            encrypted_blue BLOB        )    &#39;&#39;&#39;)    t_start_add = time()    # 加密并将每个图像存储到数据库中    restored_image()    t_end_add = time()    print(&quot;ckks同态加密用时: &#123;&#125; ms&quot;.format((t_end_add - t_start_add) * 1000))    # 提交更改并关闭连接    conn.commit()    conn.close()    print(&quot;加密存储完成&quot;)    # 读取要查询的图片并加密    query_image_path = &quot;./data/5.jpg&quot;    encrypted_query_red, encrypted_query_green, encrypted_query_blue = encrypt_image(query_image_path, context, ts.SCHEME_TYPE.CKKS)    # 连接到 SQLite 数据库    conn = sqlite3.connect(&quot;ckks_encrypted_images.db&quot;)    cursor = conn.cursor()    # 查询数据库以获取加密向量    cursor.execute(&quot;SELECT encrypted_red, encrypted_green, encrypted_blue FROM EncryptedImages&quot;)    rows = cursor.fetchall()    # 计算余弦相似度并排序    similarities = []    for i, row in enumerate(rows, start=1):        # 反序列化数据库中的密文向量        serialized_red, serialized_green, serialized_blue = row        encrypted_red = ts.ckks_vector_from(context, serialized_red)        encrypted_green = ts.ckks_vector_from(context, serialized_green)        encrypted_blue = ts.ckks_vector_from(context, serialized_blue)        # 计算余弦相似度        similarity_red = calculate_cosine_similarity(encrypted_query_red, encrypted_red)        similarity_green = calculate_cosine_similarity(encrypted_query_green, encrypted_green)        similarity_blue = calculate_cosine_similarity(encrypted_query_blue, encrypted_blue)        # 将三个通道的相似度取平均作为整体相似度        average_similarity = (similarity_red + similarity_green + similarity_blue) / 3        similarities.append((i, average_similarity))        print(f&quot;计算第&#123;i&#125;张图片的相似度&quot;)    # 对相似度进行排序    print(&quot;相似度排序中...&quot;)    similarities.sort(key=lambda x: abs(x[1] - 1))    # 输出相似度最接近1的图像编号和相似度值    print(similarities)    closest_result = similarities[0]    print(f&quot;最相似的图片为: &#123;closest_result[0]&#125;, 二者余弦相似度为: &#123;closest_result[1]&#125;&quot;)    # 关闭数据库连接    conn.close()    # 解密并还原图像    decrypt_all_image()</code></pre><p>主函数的每一个关键步骤均在代码中以注释说明，其流程可总结如下：</p><ol><li>定义 CKKS context，并分离公私钥；</li><li>创建并连接到 SQLite 数据库，创建表；</li><li>将图片数据进行同态加密，并存储到数据库中；</li><li>读取要查询的图片；</li><li>从数据库中获取加密数据，反序列化，并与查询图片计算余弦相似度，选取相似度最高的图片，输出；</li><li>将数据库中的所有加密数据全部解密，并还原为jpg图片。</li></ol><p>context是TenSEAL库实现同态加密的核心参数，在加密前要根据加密算法对context进行相应初始化，同时需要生成galois_keys、global_scale等特定参数。在默认生成的context中是同时包含公钥和私钥的，为了代码在现实中有使用价值，需要对context进行公私钥分离，使用分离了私钥只含有公钥的context加密，而使用单独保管的私钥进行解密和密文检索等工作。</p><p>本实验使用轻量级的SQLite数据库来存储加密后的密文数据，为将CKKSVector或BFVVector对象存入数据库，需要调用该类的序列化方法，相应地要对数据库中的数据进行解密或密文检索，需要使用反序列化方法后再进行后续操作。</p><h3 id="图像加密存储"><a href="#图像加密存储" class="headerlink" title="图像加密存储"></a>图像加密存储</h3><p>本实验的图像加密存储分为图像加密和图像存储两部分，在代码实现中也分为restored_image()和encrypt_image两个函数，restored_image函数中会调用encrypt_image函数，restored_image函数实现如下：</p><pre><code class="python">def restored_image():    # 加密并将每个图像存储到数据库中    for i in range(1, 101):  # 读取图片        image_path = f&quot;./data/&#123;i&#125;.jpg&quot;        values_red, values_green, values_blue = encrypt_image(image_path, context, ts.SCHEME_TYPE.CKKS)        # 将加密向量的值序列化        serialized_red = values_red.serialize()        serialized_green = values_green.serialize()        serialized_blue = values_blue.serialize()        # 将序列化的加密向量插入到数据库中        cursor.execute(&#39;&#39;&#39;        INSERT OR REPLACE INTO EncryptedImages (id, encrypted_red, encrypted_green, encrypted_blue)        VALUES (?, ?, ?, ?)    &#39;&#39;&#39;, (i, sqlite3.Binary(serialized_red), sqlite3.Binary(serialized_green), sqlite3.Binary(serialized_blue)))        print(f&quot;加密存储第&#123;i&#125;张图片&quot;)</code></pre><p>这一函数首先从.&#x2F;data文件夹中读取100张图片（本实验中图片数M取100），调用encrypt_image函数得到R、G、B三个加密数据列表，调用序列化方法，然后将加密数据按R、G、B三通道分别存入数据库中。</p><p>encrypt_image函数实现如下：</p><pre><code class="python">def encrypt_image(image_path, context_public, encryption_algorithm):    image = Image.open(image_path)    image = image.resize((64, 64))  # 调整大小    image_array = np.array(image)    # 分离每个通道    red_channel = image_array[:, :, 0].flatten().tolist()    green_channel = image_array[:, :, 1].flatten().tolist()    blue_channel = image_array[:, :, 2].flatten().tolist()    # 加密每个通道，使用公钥    encrypted_red = ts.ckks_vector(context_public, red_channel)    encrypted_green = ts.ckks_vector(context_public, green_channel)    encrypted_blue = ts.ckks_vector(context_public, blue_channel)    return encrypted_red, encrypted_green, encrypted_blue</code></pre><p>这一函数获取图片路径后，读取图片并调整图片分辨率（本实验图片分辨率取为64*64），将图片分为R、G、B三通道，分别调用TenSEAL加密方法ts.ckks_vector（或ts.bfv_vector）使用公钥进行加密。</p><h3 id="图像检索"><a href="#图像检索" class="headerlink" title="图像检索"></a>图像检索</h3><p>在图像加密存储到数据库之后，下一个任务是给定图像，在加密数据中进行图像检索，这一部分代码的核心逻辑在主函数中实现。</p><p>首先要读取希望查询的图片，并调用一次同态加密算法获取查询图片的密文：</p><pre><code class="python">if __name__ == &quot;__main__&quot;:        # ...    query_image_path = &quot;./data/5.jpg&quot;    encrypted_query_red, encrypted_query_green, encrypted_query_blue = encrypt_image(query_image_path, context, ts.SCHEME_TYPE.CKKS)    # ...</code></pre><p>图像检索核心逻辑如下：</p><pre><code class="python">if __name__ == &quot;__main__&quot;:    # ...    # 计算余弦相似度并排序    similarities = []    for i, row in enumerate(rows, start=1):        # 反序列化数据库中的密文向量        serialized_red, serialized_green, serialized_blue = row        encrypted_red = ts.ckks_vector_from(context, serialized_red)        encrypted_green = ts.ckks_vector_from(context, serialized_green)        encrypted_blue = ts.ckks_vector_from(context, serialized_blue)        # 计算余弦相似度        similarity_red = calculate_cosine_similarity(encrypted_query_red, encrypted_red)        similarity_green = calculate_cosine_similarity(encrypted_query_green, encrypted_green)        similarity_blue = calculate_cosine_similarity(encrypted_query_blue, encrypted_blue)        # 将三个通道的相似度取平均作为整体相似度        average_similarity = (similarity_red + similarity_green + similarity_blue) / 3        similarities.append((i, average_similarity))        print(f&quot;计算第&#123;i&#125;张图片的相似度&quot;)    # 对相似度进行排序    print(&quot;相似度排序中...&quot;)    similarities.sort(key=lambda x: abs(x[1] - 1))    # 输出相似度最接近1的图像编号和相似度值    print(similarities)    closest_result = similarities[0]    print(f&quot;最相似的图片为: &#123;closest_result[0]&#125;, 二者余弦相似度为: &#123;closest_result[1]&#125;&quot;)    # ...</code></pre><p>如上所说，首先要对数据库中的数据进行反序列化以获得密文，然后调用calculate_cosine_similarity函数计算三通道的余弦相似度，将三通道的平均余弦相似度作为匹配标准，因为同态加密往往涉及浮点数运算，密文之间无无法做精确比较，因此这里认为平均余弦相似度最接近1图片即为要匹配的图片，最后输出匹配图片的序号。</p><p>这里匹配的核心是余弦相似度的计算，其公式为：$\text{Similarity}(\mathbf{A}, \mathbf{B}) &#x3D; \frac{\sum_{i&#x3D;1}^{n} A_i \cdot B_i}{\sqrt{\sum_{i&#x3D;1}^{n} A_i^2} \cdot \sqrt{\sum_{i&#x3D;1}^{n} B_i^2}}$。</p><p>由于CKKSVector和BFVVector类的成员函数差异，在两个算法中，calculate_cosine_similarity函数的实现略有不同，如下：</p><pre><code class="python">def calculate_cosine_similarity(vector1, vector2):    # 分子（ckks）    numerator = vector1.dot(vector2)    numerator = numerator.pow(2)           # 如果是bfv算法，分子的计算方法替换为下面两行    # numerator = vector1.dot(vector2)    # numerator = numerator * numerator         # 分母    denominator1 = vector1.dot(vector1)    denominator2 = vector2.dot(vector2)    denominator = denominator1 * denominator2    numerator = numerator.decrypt(ckks_secret_key)    denominator = denominator.decrypt(ckks_secret_key)    numerator_array = np.array(numerator)    denominator_array = np.array(denominator)    similarity = np.sum(numerator_array) / np.sum(denominator_array)    return similarity</code></pre><h3 id="图像解密与还原"><a href="#图像解密与还原" class="headerlink" title="图像解密与还原"></a>图像解密与还原</h3><p>为了验证全此处全同态加密的有效性，这部分对加密数据进行解密和还原，这一部分实现封装在decrypt_all_image中，函数如下：</p><pre><code class="python">def decrypt_all_image():    # 创建或连接到 SQLite 数据库    conn = sqlite3.connect(&quot;bfv_encrypted_images.db&quot;)    cursor = conn.cursor()    # 查询数据库以获取加密向量    cursor.execute(&quot;SELECT encrypted_red, encrypted_green, encrypted_blue FROM EncryptedImages&quot;)    rows = cursor.fetchall()    # 创建保存目录    save_directory = &quot;./restored_images/&quot;    os.makedirs(save_directory, exist_ok=True)    # 解密并还原每个图像    for i, row in enumerate(rows, start=1):        # 反序列化加密向量的值        serialized_red, serialized_green, serialized_blue = row        # 反序列化加密向量        deserialized_red = ts.bfv_vector_from(context, serialized_red)        deserialized_green = ts.bfv_vector_from(context, serialized_green)        deserialized_blue = ts.bfv_vector_from(context, serialized_blue)        # 使用私钥解密        decrypted_red = deserialized_red.decrypt(secret_key = bfv_secret_key)        decrypted_green = deserialized_green.decrypt(secret_key = bfv_secret_key)        decrypted_blue = deserialized_blue.decrypt(secret_key = bfv_secret_key)        # 转换为 NumPy 数组        red_channel = np.array(decrypted_red)        green_channel = np.array(decrypted_green)        blue_channel = np.array(decrypted_blue)        # 由于解密后是一维数组，需要重新调整为图像形状        shape = (int(len(decrypted_red) ** 0.5), int(len(decrypted_red) ** 0.5), 1)        red_channel = red_channel.reshape(shape)        green_channel = green_channel.reshape(shape)        blue_channel = blue_channel.reshape(shape)        # 合并通道并进行值的缩放和截断        restored_image_array = np.clip(np.concatenate([red_channel, green_channel, blue_channel], axis=2), 0, 255).astype(&#39;uint8&#39;)        # 将还原后的图像数组转换为图像对象        restored_image = Image.fromarray(restored_image_array.astype(&#39;uint8&#39;))        # 保存还原后的图像为 JPG 文件        restored_image.save(f&quot;./restored_images/&#123;i&#125;_restored.jpg&quot;)        print(f&quot;解密还原第&#123;i&#125;张图片&quot;)    conn.close()    print(&quot;解密完成&quot;)</code></pre><p>其中关键步骤均用注释进行说明，需要注意的部分主要是：调用反序列化方法、使用私钥解密、图片形状reshape。</p><p>以上均基于CKKS同态加密算法进行分析，如果要换用BFV算法，需要更改的地方主要有：</p><ol><li><p>数据库名称：<code>conn = sqlite3.connect(&quot;bfv_encrypted_images.db&quot;)</code></p></li><li><p>context初始化：</p><pre><code class="python"># 定义 BFV context，并分离公私钥    context = ts.context(ts.SCHEME_TYPE.BFV,poly_modulus_degree=8192,plain_modulus=1032193)    context.global_scale = 2**20    context.generate_galois_keys()    bfv_secret_key = context.secret_key()    context.make_context_public()</code></pre></li><li><p>加密方法：</p><pre><code class="python">encrypted_red = ts.bfv_vector(context, red_channel)encrypted_green = ts.bfv_vector(context, green_channel)encrypted_blue = ts.bfv_vector(context, blue_channel)</code></pre></li><li><p>反序列化方法：</p><pre><code class="python">serialized_red, serialized_green, serialized_blue = rowencrypted_red = ts.bfv_vector_from(context, serialized_red)encrypted_green = ts.bfv_vector_from(context, serialized_green)encrypted_blue = ts.bfv_vector_from(context, serialized_blue)</code></pre></li><li><p>calculate_cosine_similarity函数中分子计算方法，上文已做解释。</p></li></ol><p>此外还有一些相应的变量名称需要更换，不再赘述。</p><h2 id="实验结果和效率比较"><a href="#实验结果和效率比较" class="headerlink" title="实验结果和效率比较"></a>实验结果和效率比较</h2><p>为保证算法比较的客观性，本实验实现两种算法的代码流程基本一致，影响算法复杂度的两个关键参数poly_modulus_degree和global_scale也保持一致，设置为：<code>context.poly_modulus_degree=8192</code>、<code>context.global_scale = 2**40</code>。在实验数据上，统一使用了CelebA人脸数据集的前100张图片作为测试数据，在读取图片时统一将图片分辨率更改为64*64。</p><p>下面对CKKS和BFV两个算法的三个测试维度（同态加密、密态搜索、同态解密）分别测试用时，测试过程截图如下：</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312112014045.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312112014045.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20231211133207261"></p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312112014186.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312112014186.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20231211133257989"></p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312112014765.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312112014765.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20231211133548923"></p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312112014462.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312112014462.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20231211133602023"></p><p>每次执行算法的用时都略有不同，这里对每种算法的每项任务的平均用时取3次测试结果的平均值，以便进行效率比较和分析，测试结果如下：</p><p>同态加密用时：</p><table><thead><tr><th>测试次数\算法</th><th>CKKS</th><th>BFV</th></tr></thead><tbody><tr><td>1</td><td>6877ms</td><td>7896ms</td></tr><tr><td>2</td><td>6957ms</td><td>7337ms</td></tr><tr><td>3</td><td>6699ms</td><td>7398ms</td></tr><tr><td>平均</td><td>6844.3ms</td><td>7543.7ms</td></tr></tbody></table><p>密态搜索用时：</p><table><thead><tr><th>测试次数\算法</th><th>CKKS</th><th>BFV</th></tr></thead><tbody><tr><td>1</td><td>21818ms</td><td>64848ms</td></tr><tr><td>2</td><td>20206ms</td><td>64673ms</td></tr><tr><td>3</td><td>20475ms</td><td>65213ms</td></tr><tr><td>平均</td><td>20833ms</td><td>64911.3ms</td></tr></tbody></table><p>同态解密用时：</p><table><thead><tr><th>测试次数\算法</th><th>CKKS</th><th>BFV</th></tr></thead><tbody><tr><td>1</td><td>3255ms</td><td>4545ms</td></tr><tr><td>2</td><td>3341ms</td><td>4044ms</td></tr><tr><td>3</td><td>3449ms</td><td>4185ms</td></tr><tr><td>平均</td><td>3348.3ms</td><td>4258ms</td></tr></tbody></table><p>上述测试结果，从不同任务的角度来看，密态搜索任务的用时是最长的，而密态解密的用时最短；从算法的角度来看，三项任务中CKKS算法的运行速度均比BFV算法快，CKKS算法在同态加密平均比BFV算法快10.2%，在密态搜索中快211.6%，在同态解密中快27.7%，整体上看，CKKS算法效率始终高于BFV算法，效率优势在密态搜索任务上体现得非常显著。</p><h2 id="分析与总结"><a href="#分析与总结" class="headerlink" title="分析与总结"></a>分析与总结</h2><p>在本次实验从不同的任务角度对比了CKKS和BFV两种同态加密算法在图像处理任务中的性能。结合实验过程和结果，做出以下分析与总结：</p><p>在实验环境方面，我在Window宿主系统使用wsl2的Linux Ubuntu操作系统（22.04.3）、CPU型号为AMD Ryzen 7 5800H（16核）以及16 Gb运行内存下进行了TenSEAL库中CKKS和BFV两种同态加密算法执行同态加密、密态检索、同态解密三个任务的效率测试。</p><p>在任务性能方面，我针对同一开源库中的CKKS和BFV两种同态加密算法进行了多次测试，以获取更为稳定的平均性能数据。在图像加密存储任务中，可以观察到CKKS算法相对于BFV算法，平均快了10.2%。在密态搜索任务中，CKKS算法表现出更为显著的优势，其运行速度相比BFV算法平均快了211.6%。而在同态解密任务中，CKKS算法仍然保持较高的效率，平均快了27.7%。</p><p>从不同算法的角度看，CKKS算法在所有测试任务中都表现出了更高的效率。在密态搜索任务中，其性能提升尤为显著，这可能归因于CKKS算法对多项式环上计算的适用性以及其更高的并行性。相较之下，BFV算法在同态加密任务中的性能相对较低，可能由于其更为复杂的计算模型导致的。</p><p>此外，在不同任务中，我们还观察到密态搜索任务的耗时相对较长，而密态解密任务的用时最短。这可以解释为，在同态加密中，解密操作相对简单，而密文搜索可能涉及到更多的计算，导致相对较高的执行时间。但是，更短的时间不能与算法的优劣直接关联，由于BFV更复杂的计算机制，虽然效率偏低，但可能会会同态加密的安全性或其他方面有提升，这里不做展开。</p><p>综上所述，从测试结果中可以得出结论，CKKS算法在多项测试任务中表现出更高的性能和效率，而BFV算法相对较慢。在选择同态加密算法时，需要根据具体应用场景和任务需求来权衡算法的优劣，以确保系统在安全性和性能之间取得合适的平衡。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CKKS与BFV算法的图片同态加密、密态检索与同态解密&quot;&gt;&lt;a href=&quot;#CKKS与BFV算法的图片同态加密、密态检索与同态解密&quot; class=&quot;headerlink&quot; title=&quot;CKKS与BFV算法的图片同态加密、密态检索与同态解密&quot;&gt;&lt;/a&gt;CKKS与</summary>
      
    
    
    
    <category term="笔记" scheme="https://kievvv.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Cryptography" scheme="https://kievvv.github.io/tags/Cryptography/"/>
    
    <category term="PrivacyProtection" scheme="https://kievvv.github.io/tags/PrivacyProtection/"/>
    
  </entry>
  
  <entry>
    <title>Bitcoin: A Peer-to-Peer Electronic Cash System-论文随记</title>
    <link href="https://kievvv.github.io/2023/12/05/008review-Bitcoin/"/>
    <id>https://kievvv.github.io/2023/12/05/008review-Bitcoin/</id>
    <published>2023-12-05T15:49:00.000Z</published>
    <updated>2023-12-05T15:50:01.705Z</updated>
    
    <content type="html"><![CDATA[<p>互联网上的商务活动几乎完全依赖于作为值得信赖的第三方的金融机构来处理电子支付。尽管这个系统对大多数交易来说运作良好，但仍然存在基于信任的模型固有的弱点。由于金融机构无法避免调解争端，完全不可逆转的交易并非真正可能。调解的成本增加了交易成本，限制了最小实际交易规模，并削减了小额随意交易的可能性。同时，无法进行不可逆转支付的能力丧失也带来了更广泛的代价。由于存在撤销的可能性，对信任的需求扩散开来。商家必须对其客户保持警惕，要求提供比他们实际需要的更多信息。一定比例的欺诈被接受为不可避免。这些成本和支付的不确定性可以通过使用实物货币进行面对面交易来避免，但在没有值得信赖的第三方的情况下，通过通信渠道进行支付的机制并不存在。</p><p>需要一种基于加密证明而不是信任的电子支付系统，使任何两个愿意的当事方能够直接进行交易，而无需信赖第三方。计算上不可逆转的交易将保护卖方免受欺诈，而常规的担保机制可以轻松实施以保护买方。</p><p>在这篇论文中，作者提出了使用点对点分布式时间戳服务器解决双花问题的方案，以生成交易的时间顺序的计算证明。只要诚实的节点总体上控制的CPU算力资源多于任何一组攻击节点的合作，该系统就是安全的。</p><h1 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h1><p><strong>在区块链中，电子货币就是数字签名链，数字签名链就是电子货币。</strong><br>        所有者转移货币给下一个所有者的方式为：将“前一个交易的哈希值+下一个所有者的公钥”进行数字签名，将该数字签名添加到货币末尾。</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312052340491.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312052340491.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20231205224011"></p><h2 id="双花问题"><a href="#双花问题" class="headerlink" title="双花问题"></a>双花问题</h2><p>上面的方法可以保证来源的可信，但是没有办法保证该货币只被使用了一次。在现实生活中，一块钱纸币花出去就没了，但比特币是没有实体的，它只是一个哈希签名，如果我使用前一个哈希值+不同人的公钥进行签名，那一个比特币就可以向不同人使用多次。如果一百块可以用两次，那它事实上就变成两百块了，这显然是不科学的，这就是双花问题。<br>比特币解决双花问题的方法就是引入时间戳，将时间纳入哈希签名中，经过验证后，只有交易时间最早的那笔交易是有效的。</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312052340599.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312052340599.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20231205224954"></p><p>纳入时间戳之后，事实上形成了一个连续性的系统，每个哈希都包含了上一个哈希的信息，如果系统中有恶意者想插入伪造的区块，那么他将要重做插入位置后面的所有块，他才能得到信任。</p><h1 id="Proof-of-Work"><a href="#Proof-of-Work" class="headerlink" title="Proof-of-Work"></a>Proof-of-Work</h1><p>Proof-of-Work（工作量证明）是在一个区块公布之前，号召所有节点来解决的一个数学难题。解决这个数学难题计算量非常大，非常耗费CPU算力。这个数学难题有且只有唯一的答案，这个答案将会作为这个区块的一部分。之所以需要Proof-of-Work，是为建立一个基于数学的信任机制，假定大多数的节点（的计算资源）都是可信的，那么解决同一个难题，肯定是计算资源多的更快计算出答案（！暂且这样说），最快得出答案将被采纳。<br>这个数学难题的特点是：</p><ol><li><p>基于每一个区块，答案都不一样，且答案唯一</p></li><li><p>解答这一问题无法利用任何先验知识，没有简便解法，其解答过程相当于是在遍历答案的所有取值空间，逐个尝试，<strong>相当于是完全随机的</strong></p></li><li><p>解答问题的计算量非常大，但验证答案是否正确只需要一次哈希运算</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312052341606.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202312052341606.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20231205230730"></p></li></ol><p>答案一经采纳，将作为区块的一部分，该区块的哈希将传给下一个区块。那么如果有人想插入伪造区块，那么他的工作量就是将插入位置之后的所有区块全部重做，将每一个区块中的数学难题全部重新算一遍，这在可信节点占大多的系统中是不可能办到的。</p><h2 id="一定是计算资源多的一方更快计算出答案吗？"><a href="#一定是计算资源多的一方更快计算出答案吗？" class="headerlink" title="一定是计算资源多的一方更快计算出答案吗？"></a>一定是计算资源多的一方更快计算出答案吗？</h2><p>不一定。因为答案是随机分布的，也许计算资源少的恶意节点计算恶意区块时恰巧很快就蒙到正确答案了。如果遇到这种情况，区块链是会接受这个答案的，但随后，可信节点会计算出真答案，恶意答案和真答案不一样，那么区块链会将两个答案同时保留，分别根据两个不同的答案建立下一个区块，区块链从这里开始会产生分支。但是，我们假定可信节点是占大多数的，恶意节点会一两次碰巧，但当链变长之后，其计算速度肯定不如占大多数的可信节点快的。可信链的长度将逐渐超过恶意链，当超过一个阈值时，较短的链（恶意链）将会被去除，只保留长的链。</p><p><em>PoW是区块链信任机制的核心，同时也是区块链灾难般性能的始作俑者，验证一笔交易的算力消耗太大了</em>。<br><em>In case you don’t know, “计算数学难题”这件事就是平时说的“挖矿”，计算出结果就可以将一个区块打包，为了激励矿工，计算出一道数学难题并将区块链打包，就会得到一定比特币作为回报，这就是激励机制。</em></p><h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><ol><li>新交易被广播到所有节点。 </li><li>每个节点将新交易收集到一个块中。 </li><li>每个节点都致力于为其区块寻找困难的工作量证明。 </li><li>当节点找到工作量证明时，它会将块广播到所有节点。 </li><li>仅当块中的所有交易均有效且尚未花费时，节点才会接受该块。</li><li>节点通过使用已接受块的哈希值作为前一个哈希值创建链中的下一个块来表达对块的接受。</li></ol><p>以上是区块链的基本流程，但原文中还有更加深入的内容，如激励、磁盘空间缩减、简化的支付验证、数值的合并与分割、交易隐私、数值计算等，有机会再做展开。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;互联网上的商务活动几乎完全依赖于作为值得信赖的第三方的金融机构来处理电子支付。尽管这个系统对大多数交易来说运作良好，但仍然存在基于信任的模型固有的弱点。由于金融机构无法避免调解争端，完全不可逆转的交易并非真正可能。调解的成本增加了交易成本，限制了最小实际交易规模，并削减了小</summary>
      
    
    
    
    <category term="笔记" scheme="https://kievvv.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Cryptography" scheme="https://kievvv.github.io/tags/Cryptography/"/>
    
    <category term="Blockchain" scheme="https://kievvv.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>基于Shamir门限的彩色图片秘密共享方案</title>
    <link href="https://kievvv.github.io/2023/11/08/007Shamir-pic-secret-sharing/"/>
    <id>https://kievvv.github.io/2023/11/08/007Shamir-pic-secret-sharing/</id>
    <published>2023-11-08T01:35:49.000Z</published>
    <updated>2023-12-11T12:25:24.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shamir门限秘密共享方案"><a href="#Shamir门限秘密共享方案" class="headerlink" title="Shamir门限秘密共享方案"></a>Shamir门限秘密共享方案</h1><p>Shamir的秘密共享（Shamir’s Secret Sharing）是一个将秘密分解为多个部分的方法，这样只有得到一定数量的部分才能重新构建该秘密。它是基于多项式插值，尤其是Lagrange插值原理。</p><p>在秘密共享的场景中，Shamir的方法允许一个秘密被分解为n个部分，其中任何k个部分可以用来重新构建原始的秘密，但k-1个部分或更少的部分没有任何信息。</p><p>以下是该方法的基本原理和流程：</p><ol><li><p>选择秘密: 假设我们有一个秘密S，并且S是一个数字。在数字图像中，这一数字可认为是图片中各个像素值。</p></li><li><p>定义多项式: 选择一个k-1阶多项式：<br>$$<br>f(x)&#x3D;a_0+a_1x+a_2x^2+…+a_{k-1}x^{k-1}<br>$$</p></li></ol><p>其中，$a_0&#x3D;S$(秘密），并且$a_0,a_2,…,a_{k-1}$是随机数。</p><ol start="3"><li><p>生成分享：对于共享秘密的每个接收者，选择一个不同的x值，并计算多项式f(x)在这个x值上的值。这将生成一系列的(x, y)坐标，其中x是x值，y是f(x)的结果。</p></li><li><p>分发分享：将每个接收者的(x, y)坐标提供给相应的接收者。每个接收者将获得一个坐标点，这个坐标点包含了足够的信息来还原出原始的秘密。</p></li><li><p>重构秘密：为了还原原始秘密S，至少需要k个坐标点。这可以通过使用拉格朗日插值法来实现，从这些坐标点中重建多项式f(x)，并找到其常数项$a_0$，即原始秘密S。</p></li></ol><h1 id="改进部分"><a href="#改进部分" class="headerlink" title="改进部分"></a>改进部分</h1><p>课上示例为灰度图片，要实现彩色图片秘密共享其实也很简单，把彩色图片分成RGB三个通道分别按灰度图片的方法处理，三通道合成为一个其中一个子秘密，共n个子秘密，选择其中任意k个（门限）即可恢复原图。</p><p>在解密实现上，使用了拉格朗日插值函数进行逐比特差值恢复。在拉格朗日函数的实现上进行了优化改进，由于原始的浮点数计算将会产生小数，在恢复为像素时由于近似运算会使恢复的秘密图片产生可察觉的视觉差异。这里将原拉格朗日函数中的除法修改为与其模逆元的乘法，避免了小数的出现，由于原本像素模数256不是质数，在计算模逆元时会带来一定麻烦，因此模数选用了大小近似但是质数的257，在此基础上可以使用费马小定理计算模逆元，提高了算法的效率，从测试结果看，这一替换方法在秘密恢复过程中不会产生可察觉的视觉影响。</p><h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><p>采用 3&#x2F;5 门限共享  ，原图如下：</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202311081004392.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202311081004392.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20231108100421288"></p><p>加密生成的5个子秘密如下：</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202311081005251.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202311081005251.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20231108100503126"></p><p>对以上彩色图像的 5 个子秘密进行了组合遍历测试，即遍历了 5 个子秘密中任意选取 3 个的所有可能情况，测试可视化结果如下：  </p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202311081005854.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202311081005854.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20231108100558364"></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><pre><code class="python">from PIL import Imageimport numpy as np#--------------------------------参数设定-------------------------------n = 5 # 秘密分割份数r = 3 # 门限数path = &#39;test4.png&#39; # 秘密图片路径testNum = 4 # 用于测试图片的命名mod = 257 # 模数#--------------------------------参数设定-------------------------------def read_image(path):    &#39;&#39;&#39;    input: 图片路径    output: 图片矩阵的三个通道, 图片矩阵形状    &#39;&#39;&#39;    img = Image.open(path)    img_array = np.asarray(img)    red_channel = img_array[:,:,0].flatten()    green_channel = img_array[:,:,1].flatten()    blue_channel = img_array[:,:,2].flatten()    return red_channel, green_channel, blue_channel, img_array.shapedef polynomial(img, n, r):    &#39;&#39;&#39;    input:        img: 输入图像，它应该是一个2D numpy数组。        n: 想生成的图像的数量。        r: 多项式的阶数。    output:        一个形状为 (n, num_pixels) 的numpy数组，其中每一行代表一个生成的图像    &#39;&#39;&#39;    num_pixels = img.shape[0]    coef = np.random.randint(low = 0, high = mod, size = (num_pixels, r - 1))    gen_imgs = []    for i in range(1, n + 1):#子秘密        base = np.array([i ** j for j in range(1, r)])        base = np.matmul(coef, base)        img_ = img + base        img_ = img_ % mod        gen_imgs.append(img_)    return np.array(gen_imgs)def lagrange(x, y, num_points, x_test):    l = np.zeros(shape=(num_points, ))    for k in range(num_points):        l[k] = 1        for k_ in range(num_points):            if k != k_:                num = (x_test - x[k_]) % mod                den = (x[k] - x[k_]) % mod                inverse_den = pow(int(den), mod-2, mod)                l[k] = (l[k] * num * inverse_den) % mod    L = 0    for i in range(num_points):        L = (L + y[i]*l[i]) % mod    return Ldef decode(imgs, index, r, n):    assert imgs.shape[0] &gt;= r    x = np.array(index)    dim = imgs.shape[1]    img = []    for i in range(dim):        y = imgs[:, i]        pixel = lagrange(x, y, r, 0) % mod        img.append(pixel)    return np.array(img)if __name__ == &quot;__main__&quot;:#------------------------------------加 密------------------------------------    print(&quot;**************&quot;)    print(&quot;Encrypt begin.&quot;)    print(&quot;**************&quot;)    r_channel, g_channel, b_channel, shape = read_image(path)    gen_imgs_r = polynomial(r_channel, n = n, r = r)    gen_imgs_g = polynomial(g_channel, n = n, r = r)    gen_imgs_b = polynomial(b_channel, n = n, r = r)    for i in range(n):        # 将三个通道合并，得到其中一个子秘密        combined_img = np.stack((            gen_imgs_r[i].reshape(shape[0], shape[1]),            gen_imgs_g[i].reshape(shape[0], shape[1]),            gen_imgs_b[i].reshape(shape[0], shape[1])        ), axis=-1)        Image.fromarray(combined_img.astype(np.uint8)).save(f&quot;test&#123;testNum&#125;_&#123;i+1&#125;.jpeg&quot;)        print(f&quot;test&#123;testNum&#125;_&#123;i+1&#125;.jpeg is saved.&quot;)#------------------------------------加 密------------------------------------#------------------------------------解 密------------------------------------    print(&quot;**************&quot;)    print(&quot;Decrypt begin.&quot;)    print(&quot;**************&quot;)    # 遍历所有图片组合以验证解密效果    for i in range(n):        for j in range(i+1, n):            for k in range(j+1, n):                # 选择子秘密和对应的x值                selected_subsecrets = [i, j,k]                selected_x_values = [i+1, j+1,k+1]                # 解密                origin_img_r = decode(gen_imgs_r[selected_subsecrets, :], selected_x_values, r=r, n=n)                origin_img_g = decode(gen_imgs_g[selected_subsecrets, :], selected_x_values, r=r, n=n)                origin_img_b = decode(gen_imgs_b[selected_subsecrets, :], selected_x_values, r=r, n=n)                # 将解密结果合并                combined_origin_img = np.stack((                    origin_img_r.reshape(shape[0], shape[1]),                    origin_img_g.reshape(shape[0], shape[1]),                    origin_img_b.reshape(shape[0], shape[1])                ), axis=-1)                # 保存图像，名称包含所选的子秘密的编号                filename = f&quot;test&#123;testNum&#125;_recovered_&#123;i+1&#125;_&#123;j+1&#125;_&#123;k+1&#125;.jpeg&quot;                Image.fromarray(combined_origin_img.astype(np.uint8)).save(filename)                print(f&quot;&#123;filename&#125; is saved.&quot;)    # 挑选制定的子秘密进行解密，如下标第1,2,4张，对应x值为2,3,5    # selected_subsecrets = [1,2,4]    # selected_x_values = [2,3,5]    # origin_img_r = decode(gen_imgs_r[selected_subsecrets, :], selected_x_values, r=r, n=n)    # origin_img_g = decode(gen_imgs_g[selected_subsecrets, :], selected_x_values, r=r, n=n)    # origin_img_b = decode(gen_imgs_b[selected_subsecrets, :], selected_x_values, r=r, n=n)    # 将解密结果合并    # combined_origin_img = np.stack((    #     origin_img_r.reshape(shape[0], shape[1]),    #     origin_img_g.reshape(shape[0], shape[1]),    #     origin_img_b.reshape(shape[0], shape[1])    # ), axis=-1)    # Image.fromarray(combined_origin_img.astype(np.uint8)).save(f&quot;test&#123;testNum&#125;_origin.jpeg&quot;)    #------------------------------------解 密------------------------------------</code></pre><p>项目地址：<a href="https://github.com/kievvv/RGBpicSecretSharing">https://github.com/kievvv/RGBpicSecretSharing</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Shamir门限秘密共享方案&quot;&gt;&lt;a href=&quot;#Shamir门限秘密共享方案&quot; class=&quot;headerlink&quot; title=&quot;Shamir门限秘密共享方案&quot;&gt;&lt;/a&gt;Shamir门限秘密共享方案&lt;/h1&gt;&lt;p&gt;Shamir的秘密共享（Shamir’s S</summary>
      
    
    
    
    <category term="项目" scheme="https://kievvv.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Cryptography" scheme="https://kievvv.github.io/tags/Cryptography/"/>
    
    <category term="PrivacyProtection" scheme="https://kievvv.github.io/tags/PrivacyProtection/"/>
    
  </entry>
  
  <entry>
    <title>Matlab基础语法备忘录</title>
    <link href="https://kievvv.github.io/2023/08/24/006MatlabNote/"/>
    <id>https://kievvv.github.io/2023/08/24/006MatlabNote/</id>
    <published>2023-08-24T11:55:29.000Z</published>
    <updated>2023-10-20T03:21:53.695Z</updated>
    
    <content type="html"><![CDATA[<p><strong>MatLab的索引是从1开始的</strong></p><ol><li><p>清空</p><p><code>clc</code> 清空命令行<br><code>clear all</code> 清空工作区所有变量</p></li><li><p>变量命名区分大小写，长度&lt;&#x3D;63</p></li><li><p><code>%</code>单行注释<br><code>%%</code>多行注释</p></li><li><p>变量名字以字母开头，中间可以是字母、数字、下划线</p></li><li><p>数据类型</p></li></ol><ul><li><p><strong>数字</strong></p></li><li><p><strong>字符和字符串</strong><br> 字符串用单引号``<br> length(str)</p></li><li><p><strong>矩阵</strong><br> <code>A=[1 2 3; 4 5 3; 3 2 7]</code>：<code>;</code>表示换行，行内用空格或<code>,</code><br> <code>B=A&#39;</code>：求转置<br> <code>C=A(:)</code>：转成一维矩阵<br> <code>D=inv(A)</code>：求逆矩阵<br> <code>E=zeros(10,5,3)</code>：3维矩阵，每维都是10行5列，元素全是0</p></li><li><p><strong>元胞数组</strong><br> <code>A=cell(1,6)</code>：1行6列的元胞数组<br> <code>A&#123;2&#125;=eye(3) </code>：把该单位矩阵赋给A中第2个元素<br> <code>eye(n)</code>：生成n维单位矩阵<br> <code>magic(n)</code>：生成n阶幻方（横竖斜任意方向数字和总相同）</p></li><li><p><strong>结构体</strong><br> <code>books=struct(&#39;name&#39;,&#123;&#123;'Machine Learning','Data Mining'&#125;&#125;,&#39;price&#39;,[30,40])</code>：相当于键值对、字典<br> <code>books.name</code><br> <code>books.name(1)</code>：小括号取出的是cell<br> <code>books.name&#123;1&#125;</code>：中括号取出的是具体值</p></li></ul><ol start="6"><li><p>矩阵操作<br><code>A=[1 2 3 4 5 6 7 8]</code>、】<br><code>B=1:2:9</code>：构造矩阵-&gt;<code>起点:步长:终点</code><br><code>B=[1 3 5 7 9]</code><br><code>C=repmat(B,3,2)</code>：重复B，竖着重复3次，横着重复2次<br><code>D=ones(2,4)</code>：2行4列的纯一矩阵</p></li><li><p>矩阵四则运算<br><code>+ - *</code>：字面意思<br><code>A/B</code>：等价于<code>A * inv(B)</code>，和B的逆相乘<br><code>A .* B</code>：两矩阵对应项相乘，有<code>.</code>的都是对对应项操作，<code>./</code>同理</p></li><li><p>下标<br><code>A(2,3)</code><br><code>A(2,:)</code>：<code>:</code>表示取所有<br><code>[m,n]=find(A&gt;20)</code>：找A中大于20的元素，将其横纵坐标分别赋给m数组和n数组</p></li><li><p>逻辑与流程控制</p></li></ol><ol><li>for循环</li></ol><pre><code class="matlab">for 循环变量=初值:步长:终值    ...end</code></pre><p>步长为1的话可以省略<br>即<code>for 循环变量=初值:终值</code></p><ol start="2"><li>while循环</li></ol><pre><code class="matlab">while 布尔表达式    ...end</code></pre><ol start="3"><li>if(else)语句</li></ol><pre><code class="matlab">if 布尔表达式    ...end</code></pre><pre><code class="matlab">if 布尔表达式    ...else    ...end</code></pre><ol start="10"><li>绘图<br>…</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;MatLab的索引是从1开始的&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;清空&lt;/p&gt;
&lt;p&gt;&lt;code&gt;clc&lt;/code&gt; 清空命令行&lt;br&gt;&lt;code&gt;clear all&lt;/code&gt; 清空工作区所有变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;变量</summary>
      
    
    
    
    <category term="笔记" scheme="https://kievvv.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Matlab" scheme="https://kievvv.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>Netflix使用及解锁4k折腾记</title>
    <link href="https://kievvv.github.io/2023/08/23/005Netflix4k/"/>
    <id>https://kievvv.github.io/2023/08/23/005Netflix4k/</id>
    <published>2023-08-22T18:39:31.000Z</published>
    <updated>2023-10-20T03:28:15.766Z</updated>
    
    <content type="html"><![CDATA[<p>其实没用Netflix之前也没什么，虽然天天看网飞剧，但找资源也不费劲。相安无事。<br>自从换了个4k屏幕，决定整一下Netflix，开始了新的折腾。</p><hr><p>大陆现在基本就是找平台买号。<br>已有很不错的文章，不再重复造轮子，如下：<br><a href="https://netflixhz.com/watch-netflix-in-china/">2023中国解锁Netflixi详细教程，教你用最少的钱看奈飞&#x2F;网飞</a><br>合租平台可以参考上文。一般都买最高级别的会员方案，支持4k分别率。在购买的时候注意有无地区限制，比如账号在某些地区不能使用。Netflix在不同地区登录其资源是不同的。<br>至于解锁流媒体限制的问题。登录账号后可以搜索《绝命毒师》进行验证，如果有这部剧集的资源说明当前节点已经解锁流媒体，反之则没有解锁。如果解锁流媒体就可以看到其他流媒体平台的影视作品，反之，则只能看Netflix自制的影视，即左上角都有”N”标志。是否能解锁流媒体限制与所用的节点搭建方式有关，与Netflix账号无关。</p><p>本人设备是Windows11 PC浏览器及客户端、IPad、IPhone。<br>1080P是基本需求。主要方法如下：</p><p>IPad、IPhone需要用非大陆Apple ID下载Netflix客户端，登陆即可正常播放。如果一直转圈圈基本是节点问题，多换几个。</p><p>Windows浏览器基本就是Microsoft Microsoft Edge和Chrome两个。</p><p>Microsoft Edge进官网登录直接播放就可以达到1080P。</p><blockquote><p>查看分辨率的方法：快捷键<code>Ctrl+Shift+Alt+D</code>，非全屏即可显示。该方法浏览器和客户端都适用。<img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309240009694.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309240009694.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="屏幕截图 2023-08-23 005418"></p></blockquote><p>Chrome原生会限制分辨率，最高720P。可以通过插件强制改成1080P。插件名字是<code>Netflix 1080p</code>。</p><p>按上面方法如果没达到1080p的话，先等一下缓冲看看，因为Netflix会自动根据网络情况调整画质。如果还是不行就更换节点。<br>浏览器用着挺好的，如果不用4k的话不推荐用Windows客户端。</p><hr><p>接下来是<strong>Netflix解锁4k分辨率</strong>的方法：</p><p><strong>基本条件：</strong></p><ol><li>支持<strong>4k(3840×2160) 60Hz</strong>的显示器</li><li>Netflix订阅方案为<strong>高级版（支持Ultra HD）</strong></li><li>Netflix<strong>串流画质设定为“高”或“自动”</strong>（账户-&gt;播放设定）</li><li>安装<strong>HEVC拓展</strong></li><li>CPU：至少要第7代Intel Core（Kaby Lake）或以上</li><li>GPU：Nvidia GTX 1050、1060、1070或 1080等级以上显卡</li><li><strong>HDMI线材&gt;&#x3D;2.0</strong>，才能支持60Hz HDR</li><li>网络速度：<strong>25Mbps以上</strong>（<a href="https://fast.com/">官方测速</a>）</li><li>充足的流量：4k一小时7GB左右</li></ol><p>Microsoft Edge最新版原生最高支持Netflix 4k<br>首先安装tampermonkey拓展，是一个浏览器脚本环境<br>然后打开并安装<a href="https://greasyfork.org/zh-CN/scripts/444125-netflix-uhd">Netflix UHD</a>脚本<br>在浏览器Netflix播放视频，右键菜单，点<code>PlayReady DRM Info(UHD Ready)</code><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309240009423.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309240009423.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230823012815"><br>如果全部都是勾说明符合4k播放条件，点开剧集详情页，应该会有4k的标识</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309240008527.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309240008527.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230823013053"></p><p>否则显示的是“高画质”。如果此时播放没办法达到4k，可能是网络问题。</p><blockquote><p>如果Info中最底下两行是叉，那就是没安装<strong>HEVC拓展</strong>。不介意几块钱可以直接在微软商店搜索，付费购买。<br>不付费的方法也有，网上搜到的大部分适用于win10的，win11不适用。<br>我最后摸索出来适用于win11的HEVC拓展免费安装方法：</p><p>进入如下网址：<a href="https://store.rg-adguard.net/">https://store.rg-adguard.net/</a></p><p>在微软商店中找到HEVC拓展应用程序的URL：<a href="https://www.microsoft.com/en-us/p/hevc-video-extensions-from-device-manufacturer/9n4wgh0z6vhq">https://www.microsoft.com/en-us/p/hevc-video-extensions-from-device-manufacturer/9n4wgh0z6vhq</a></p><p>输入搜索框，生成下载链接，下载<code>.appxbundle</code>文件，安装即可。</p></blockquote><p>如果浏览器还是达不到4k，可以尝试客户端。</p><p>首先在Windows系统设置中切换到国外地区，打开微软商店，下载Netflix客户端。<br>win11用户打开客户端大概率是一直在转圈圈，是因为windows的一个限制规则，可通过改注册表来解决。<br>方法如下：<a href="https://zhuanlan.zhihu.com/p/386357019">https://zhuanlan.zhihu.com/p/386357019</a><br>我用的是第二个方法。</p><p>进入并登录客户端后，应该可以播放4k了。</p><hr><p>2023.10.20更新</p><p>因为最近新设备mac mini，mac端使用Netflix观看4k影视最方便的方法应该是直接使用safari浏览器，是原生支持4k串流的。</p><p>如果更新了Mac OS 14(Sonoma)的话，新版safari可以制作伪app了，也就是把网页快捷方式包装得像是一个app，添加到程序坞和启动台，一键启动，体验蛮不错的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;其实没用Netflix之前也没什么，虽然天天看网飞剧，但找资源也不费劲。相安无事。&lt;br&gt;自从换了个4k屏幕，决定整一下Netflix，开始了新的折腾。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;大陆现在基本就是找平台买号。&lt;br&gt;已有很不错的文章，不再重复造轮子，如下：&lt;br&gt;&lt;a hre</summary>
      
    
    
    
    <category term="笔记" scheme="https://kievvv.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Netflix" scheme="https://kievvv.github.io/tags/Netflix/"/>
    
  </entry>
  
  <entry>
    <title>观展游记之「草间弥生：一九四五年至今」</title>
    <link href="https://kievvv.github.io/2023/08/10/004YayoiKusama/"/>
    <id>https://kievvv.github.io/2023/08/10/004YayoiKusama/</id>
    <published>2023-08-09T18:38:23.000Z</published>
    <updated>2023-09-23T16:06:46.239Z</updated>
    
    <content type="html"><![CDATA[<p>3月3日，我在香港M+艺术馆参观了《草间弥生：一九四五年至今》这个展，很喜欢。这篇游记主要记录和回顾观展的内容。（该展已于2023年5月14日结束）</p><p>展览官方介绍如下：</p><h4 id="「发掘草间弥生超凡绚烂的艺术之路，见证艺术连系人心、治愈心灵的力量」"><a href="#「发掘草间弥生超凡绚烂的艺术之路，见证艺术连系人心、治愈心灵的力量」" class="headerlink" title="「发掘草间弥生超凡绚烂的艺术之路，见证艺术连系人心、治愈心灵的力量」"></a><strong>「发掘草间弥生超凡绚烂的艺术之路，见证艺术连系人心、治愈心灵的力量」</strong></h4><blockquote><p>草间弥生坚持不懈地追求前卫艺术实践，使她成为二十一世纪的全球文化偶像。她在逾七十年的创作生涯中发展出独树一帜的核心美学和人生哲学。其作品展示浩瀚无垠之境，反思大自然的生命形态与循环，掳获世人的目光。“草间弥生：一九四五年至今”呈现艺术家的创作生涯，强调她对相互连结的追求，以及不断推动其创作的生命哲思。<br>“草间弥生：一九四五年至今”是草间在日本以外的亚洲地区举行的最大回顾展，展出逾200件展品，涵盖绘画、素描、雕塑、装置及档案资料等各种媒材。是次回顾展按时序及主题出发，由第二次世界大战尾声创作的绘画至其最近期的沉浸式作品，围绕“无限”、“积累”、“全面连结”、“生物宇宙”、“死亡”和“生命的力量”六个主题，全面地呈现草间艺术生涯的各个发展阶段。</p></blockquote><p><a href="https://www.mplus.org.hk/sc/exhibitions/yayoi-kusama-1945-to-now/">Offical Website</a></p><p>M+场馆不算十分好找，地铁九龙站出门后还有十分钟左右路程，稍微有些绕，不过当时在九龙站出站时就已经看到该展览的物料宣传，当然也有包括故宫博物馆等艺术展览的宣传，这个街区是艺术文化活动较集中的地方。<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232353733.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232353733.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2529"></p><p>在M+整体体验非常好，包括场馆的建筑风格、内部装潢、安静程度、服务人员和设施等都很不错。</p><p>几个记忆点：电梯前面有专人替顾客按电梯并礼貌地鞠躬打招呼；服务人员中英粤切换流利；买学生票无需check证件；支持微信支付宝。<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232353457.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232353457.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2551"></p><p>进入正题。展览标题处这幅自画像包含草间弥生经典的波点样式和黑黄配色，开篇明志，后续会看到更多类似元素。<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232353596.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232353596.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2554"></p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232353183.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232353183.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2639"></p><p>玄关处主要是波点元素为主的人脸像，配色十分鲜艳大胆，下图仍为艺术家自画像，配色很抓眼。</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232354982.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232354982.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2557"></p><p>第一个展厅。该展厅的展品全部是无主体的纹理平面画。<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232354224.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232354224.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2559"><br>场馆里人其实挺多的，但是很安静，连走路脚步都会不自觉放轻，基本没有小孩子吵闹声。</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232354844.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232354844.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2561"></p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232354226.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232354226.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2562"></p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232355039.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232355039.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2558"></p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232355518.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232355518.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2642"><br>每次看见纯纹理的作品我都会停下来仔细端详一下，在看草间这一系列作品时也不例外。这部分画都是纯视觉向的，比较抽象。有一种说法是这些花纹是作者在自己梦中看到的景象。<br>草间弥生的创作很大一部分与她早期患精神疾病时的灵感相联系。</p><p>然后来到装置艺术区域。</p><p><strong>红黑触手</strong><br>草间弥生的经典设计，视觉冲击力很强，我最爱的展品之一。<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232355524.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232355524.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2582"></p><p><strong>长满阴茎的女孩和家具</strong><br>主题是针对女性受性侵害的隐喻。</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232355565.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232355565.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2587"></p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232356397.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232356397.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2589"></p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232356950.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232356950.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2591"></p><p>综合展厅。该展厅装置和画都有，以波点、纹理为主。<br><strong>波点大蘑菇</strong><br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232356246.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232356246.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2603"></p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232356247.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232356247.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2604"></p><p>这是毛细血管么？<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232356455.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232356455.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2608"></p><p>然后就是Highlight之一：<strong>黑黄蛇纹图</strong><br>这幅画的画幅很大，现场效果非常震撼。近看纹理和质感都非常妙，摄人心魄。我凑近看了差不多有五分钟。<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232357441.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232357441.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2610"></p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232357817.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232357817.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2611"></p><p>下一个很出圈的装置艺术是<strong>黑黄南瓜</strong><br>展馆内的瓜，小小的很精致：<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232357241.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232357241.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2614"></p><p>场馆外的大瓜，应该不是艺术家原作品，属于是宣传周边：<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232358765.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232358765.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2716"></p><p>下一个展区，主题是<strong>生命的色彩</strong>。整个区域的作品色彩非常明艳，表现的是生命和活力。</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232358241.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232358241.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2635"></p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232358909.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232358909.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2630"></p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232358047.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232358047.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2631"></p><p>下一个装置艺术区，主要是探讨人体器官本身，以及人和地狱的联系</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232359150.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232359150.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2619"></p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232359037.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232359037.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2623"></p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232359990.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232359990.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2625"></p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232359460.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232359460.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2620"></p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232359471.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232359471.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2621"></p><p>接着是通过装置和影像展示的<strong>行为艺术</strong>相关的作品，也包括草间弥生的个人自白。这部分还是要在现场观看感受，很难描述清楚。</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309240000941.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309240000941.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2600"></p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309240000565.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309240000565.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2666"></p><p>1967 年，草间弥生纽约公园、克赖斯勒艺术博物馆举办“<strong>人体嘉年华</strong>”活动，邀请了许多模特在墙上以及各自的身体上进行创作。<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309240000770.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309240000770.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2672"></p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309240000624.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309240000624.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2673"></p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309240000283.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309240000283.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2674"></p><p>要离开时偶然从一个门缝进入，别有洞天。发现一处现代感很浓的装置艺术，一滩金属材质拟液态物体，就着栅状光线，如果以动态视角观看的话，金属表面有光怪陆离的效果。草间似乎不是善用光影的艺术家，该作品跟她其他作品的形态差别好像也比较大。<br>但就挺好看的。</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309240000480.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309240000480.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2647"></p><p>展览设计有些复杂，来来回回把二层场馆逛了两三遍，没想到还是有遗漏。出来之后发现地下一层还有大型装置艺术的场馆，有点遗憾地错过了。<img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309240001110.jpg" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309240001110.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="PANA2715"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;3月3日，我在香港M+艺术馆参观了《草间弥生：一九四五年至今》这个展，很喜欢。这篇游记主要记录和回顾观展的内容。（该展已于2023年5月14日结束）&lt;/p&gt;
&lt;p&gt;展览官方介绍如下：&lt;/p&gt;
&lt;h4 id=&quot;「发掘草间弥生超凡绚烂的艺术之路，见证艺术连系人心、治愈心灵的力量</summary>
      
    
    
    
    <category term="游记" scheme="https://kievvv.github.io/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
    <category term="Art" scheme="https://kievvv.github.io/tags/Art/"/>
    
    <category term="Photos" scheme="https://kievvv.github.io/tags/Photos/"/>
    
  </entry>
  
  <entry>
    <title>SQUIRREL：论文随记</title>
    <link href="https://kievvv.github.io/2023/07/28/003SQUIRREL-review/"/>
    <id>https://kievvv.github.io/2023/07/28/003SQUIRREL-review/</id>
    <published>2023-07-27T19:28:54.000Z</published>
    <updated>2023-09-23T15:43:09.296Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇Fuzzing测试相关论文的阅读随记，主要为了理清思路方法，文章题目是：<strong>SQUIRREL: Testing Database Management Systems with Language Validity and Coverage Feedback</strong>，2020年发表在CCS USA，一作是佐治亚理工学院的<a href="https://ieeexplore.ieee.org/author/37088950861">Rui Zhong</a>，二作<a href="https://changochen.github.io/">Yongheng Chen</a>（是CTFer！</p><p>相关链接如下：<a href="https://dl.acm.org/doi/pdf/10.1145/3372297.3417260">论文</a>，<a href="https://github.com/s3team/Squirrel">源码</a></p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><blockquote><p> Fuzzing is an increasingly popular technique for verifying software functionalities and finding security vulnerabilities. However, current mutation-based fuzzers cannot effectively test database management systems (DBMSs), which strictly check inputs for valid syntax and semantics. Generation-based testing can guarantee the syntax correctness of the inputs, but it does not utilize any feedback, like code coverage, to guide the path exploration. In this paper, we develop Sqirrel, a novel fuzzing framework that considers both language validity and coverage feedback to test DBMSs. We design an intermediate representation (IR) to maintain SQL queries in a structural and informative manner. To generate syntactically correct queries, we perform type-based mutations on IR, including statement insertion, deletion and replacement. To mitigate semantic errors, we analyze each IR to identify the logical dependencies between arguments, and generate queries that satisfy these dependencies. We evaluated Sqirrel on four popular DBMSs: SQLite, MySQL, PostgreSQL and MariaDB. Sqirrel found 51 bugs in SQLite, 7 in MySQL and 5 in MariaDB. 52 of the bugs are fixed with 12 CVEs assigned. In our experiment, Sqirrel achieves 2.4×243.9× higher semantic correctness than state-of-the-art fuzzers, and explores 2.0×-10.9× more new edges than mutation-based tools. These results show that Sqirrel is effective in finding memory errors in database management systems.</p></blockquote><p><strong>Fuzzing模糊测试 -&gt; 一种软件测试方法，通过半随机方式的数据发送以验证软件功能和查找安全漏洞</strong></p><ol><li><p>基于mutation的fuzzer<br> 因为DBMS严格检查输入-&gt;不可用</p></li><li><p>基于generation的fuzzer<br> -&gt;可以保证syntax correctness<br> 但不能利用feedback(代码覆盖率等)来引导探索路径</p></li></ol><p><strong>Squirrel</strong><br>    兼顾language validity和coverage feedback<br>    <strong>Intermediate Representation</strong> -&gt; 使得查询structural和informative<br>    <strong>Type-based mutation</strong> -&gt; 保证语法(syntactically)正确<br>    <strong>Semantics-Guided Instantiation</strong> -&gt; 保证语义(semantically)正确</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ol><li>Propose <strong>syntax-preserving mutation</strong> and <strong>semantics-guided instantiation</strong> to address the challenges of fuzzing DBMSs.</li><li>Implement Squirrel, an <strong>end-to-end system</strong> that <strong>combines mutation and generation</strong> to detect DBMS bugs.</li><li>Evaluated Squirrel on real-world DBMSs and identified <strong>63 memory error</strong> issues. The result shows that <strong>Squirrel outperforms existing tools on finding bugs from DBMSs</strong>.</li></ol><h1 id="Problem-Definition"><a href="#Problem-Definition" class="headerlink" title="Problem Definition"></a>Problem Definition</h1><h2 id="1-Query-Processing-in-DBMS"><a href="#1-Query-Processing-in-DBMS" class="headerlink" title="1. Query Processing in DBMS"></a>1. Query Processing in DBMS</h2><h3 id="How-a-DBMS-handles-SQL-queries"><a href="#How-a-DBMS-handles-SQL-queries" class="headerlink" title="How a DBMS handles SQL queries"></a>How a DBMS handles SQL queries</h3><h4 id="1-parse"><a href="#1-parse" class="headerlink" title="1) parse"></a>1) parse</h4><ul><li>First parses the query to get its syntactic meaning<ol><li>Breaks the query into individual tokens</li><li>Checks them against the grammar rules</li></ol></li></ul><h4 id="2-validation"><a href="#2-validation" class="headerlink" title="2) validation"></a>2) validation</h4><ul><li>Checks the semantic correctness of the query</li></ul><h4 id="3-ptimization"><a href="#3-ptimization" class="headerlink" title="3) ptimization"></a>3) ptimization</h4><ul><li>构造几个可能的查询计划 -&gt; 确定给定查询最有效的查询计划</li></ul><h4 id="4-execution"><a href="#4-execution" class="headerlink" title="4) execution"></a>4) execution</h4><ul><li>执行 + 返回</li></ul><blockquote><p>如果1, 2阶段不满足，则不会进行到3, 4</p></blockquote><h2 id="2-Challenges-of-DBMS-Testing"><a href="#2-Challenges-of-DBMS-Testing" class="headerlink" title="2 Challenges of DBMS Testing"></a>2 Challenges of DBMS Testing</h2><h3 id="Introduce-existing-DBMS-testing-techniques-amp-Illustrate-their-limitations"><a href="#Introduce-existing-DBMS-testing-techniques-amp-Illustrate-their-limitations" class="headerlink" title="Introduce existing DBMS testing techniques &amp; Illustrate their limitations"></a>Introduce existing DBMS testing techniques &amp; Illustrate their limitations</h3><h3 id="主要有两种DBMS测试方法："><a href="#主要有两种DBMS测试方法：" class="headerlink" title="主要有两种DBMS测试方法："></a>主要有两种DBMS测试方法：</h3><h4 id="1-model-based-generation-基于模型生成"><a href="#1-model-based-generation-基于模型生成" class="headerlink" title="1) model-based generation 基于模型生成"></a>1) model-based generation 基于模型生成</h4><h5 id="遵循精确的语法模型以生成语法正确的输入"><a href="#遵循精确的语法模型以生成语法正确的输入" class="headerlink" title="遵循精确的语法模型以生成语法正确的输入"></a>遵循精确的语法模型以生成语法正确的输入</h5><ul><li><strong>pros:</strong> 语法正确</li><li><strong>cons:</strong><br>  顺序扫描整个输入空间-&gt;不能有效搜索程序的状态空间<br>  很难保证语义正确性-&gt;会被过滤</li></ul><h4 id="2-random-mutation-随机变异"><a href="#2-random-mutation-随机变异" class="headerlink" title="2) random mutation 随机变异"></a>2) random mutation 随机变异</h4><h5 id="更新现有输入以生成新输入"><a href="#更新现有输入以生成新输入" class="headerlink" title="更新现有输入以生成新输入"></a>更新现有输入以生成新输入</h5><ul><li><strong>pros:</strong><br>  利用先前执行的反馈来评估生成的输入的优先级<br>  如果反馈表明之前的输入很有趣，模糊器会将其放入队列中以进行进一步的变异<br>  -&gt;可以有效地探索程序的状态空间</li><li><strong>cons:</strong><br>  在处理结构化输入方面效率低下(如SQL、JS)<br>   1. 随机翻转一个 SQL 关键字的位很难产生另一个有效的关键字<br>   2. 整个查询将在语法上变得不正确</li></ul><blockquote><p>AFL 生成的查询的验证率很低- &gt; 语义正确很重要</p></blockquote><h2 id="3-Our-Approach"><a href="#3-Our-Approach" class="headerlink" title="3 Our Approach"></a>3 Our Approach</h2><h3 id="Present-our-insight-to-solve-this-problem"><a href="#Present-our-insight-to-solve-this-problem" class="headerlink" title="Present our insight to solve this problem"></a>Present our insight to solve this problem</h3><h4 id="1-Generating-Syntax-Correct-Queries"><a href="#1-Generating-Syntax-Correct-Queries" class="headerlink" title="1) Generating Syntax-Correct Queries"></a>1) Generating Syntax-Correct Queries</h4><ul><li>IR-&gt;使得查询structural和informative</li><li>基于类型的突变来保证句法正确性<br>  -&gt;每个语句都有语法类型，每个数据都有语义类型</li><li>从每个 IR 中剥离具体数据，如表名，以专注于改变骨架</li></ul><h4 id="2-Improving-Semantic-Correctness"><a href="#2-Improving-Semantic-Correctness" class="headerlink" title="2) Improving Semantic Correctness"></a>2) Improving Semantic Correctness</h4><p>确保语义正确是NP-hard问题</p><ul><li>通过动态查询实例化 -&gt; 保证其 SQL 模板的表现力</li><li>给定语法正确的 SQL 查询的骨架 -&gt; 尝试用关系满足数据依赖图的具体操作数填充骨架</li><li>(根据预定义的基本规则构建其数据依赖图)</li></ul><h1 id="Overview-of-Sqirrel"><a href="#Overview-of-Sqirrel" class="headerlink" title="Overview of Sqirrel"></a>Overview of Sqirrel</h1><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232341319.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232341319.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="屏幕截图 2023-07-28 033639"></p><h4 id="四个组成部分"><a href="#四个组成部分" class="headerlink" title="四个组成部分"></a>四个组成部分</h4><ol><li>Translator, </li><li>Mutator, </li><li>Instantiator,</li><li>SQL Fuzzer</li></ol><h4 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h4><ol><li>从查询队列中<strong>选一个查询I</strong></li><li><strong>IR Translator</strong>将查询I<strong>翻译成IR的向量V</strong><br> 同时从V中<strong>剥离具体值</strong>，使其<strong>成为骨架</strong></li><li><strong>Mutator</strong>生成<strong>新的向量V’</strong>(通过插入、删除、替换)<br> -&gt; V’语法正确</li><li><strong>Instantiator</strong>对V’进行<strong>数据依赖性分析</strong><br> （并构建新的数据依赖图）</li><li>Instantiator<strong>选择新的具体值填充V’</strong>,which满足数据依赖性</li><li>将V’转回SQL语句I‘</li><li>运行：<br> if 崩溃 -&gt; 找到触发错误的输入<br> else if 触发了新的执行路径 -&gt; 保存到队列</li></ol><h1 id="Intermediate-Representation-中间表示（IR-Translator）"><a href="#Intermediate-Representation-中间表示（IR-Translator）" class="headerlink" title="Intermediate Representation 中间表示（IR Translator）"></a>Intermediate Representation 中间表示（IR Translator）</h1><p><strong>SQL语句I转化成 -&gt; IR向量V -&gt; 改变成V’ -&gt; 转换回SQL语句I’</strong></p><ul><li>IR特点：expressive, general, simple</li></ul><h1 id="Syntax-Preserving-Mutation-语法保留突变"><a href="#Syntax-Preserving-Mutation-语法保留突变" class="headerlink" title="Syntax-Preserving Mutation 语法保留突变"></a>Syntax-Preserving Mutation 语法保留突变</h1><h3 id="Token区分"><a href="#Token区分" class="headerlink" title="Token区分"></a>Token区分</h3><ul><li><strong>structure</strong>：关键字 + 数学运算符<br>  改变structure会改变查询的操作，从而触发不同的功能</li><li><strong>data</strong>：常量值、名称等<br>  修改与语义相关的data可能会生成语义不正确的查询导致DBMS拒绝执行<br>  改变structure的影响更大-&gt;剥离数据，在结构上变异</li></ul><h2 id="1-Structure-Data-Separation"><a href="#1-Structure-Data-Separation" class="headerlink" title="1) Structure-Data Separation"></a>1) Structure-Data Separation</h2><ul><li>基本规则：用“x”替换语义数据，将常量数字更改为 1 或 1.0</li><li>在IR library存储不同的IR</li></ul><h2 id="2-Type-Based-Mutation"><a href="#2-Type-Based-Mutation" class="headerlink" title="2) Type-Based Mutation"></a>2) Type-Based Mutation</h2><ul><li><p>主要是operand的变异</p><p>-&gt; 要么修改整个IR，要么修改operand</p></li></ul><h3 id="三种变异"><a href="#三种变异" class="headerlink" title="三种变异"></a>三种变异</h3><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232342901.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232342901.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230509215933"></p><h4 id="Insertion插入"><a href="#Insertion插入" class="headerlink" title="Insertion插入"></a>Insertion插入</h4><h4 id="Replacement替换"><a href="#Replacement替换" class="headerlink" title="Replacement替换"></a>Replacement替换</h4><p> -&gt;在IR库中选择对应位置的孩子进行插入或替换</p><h4 id="Deletion删除"><a href="#Deletion删除" class="headerlink" title="Deletion删除"></a>Deletion删除</h4><h4 id="验证语法正确"><a href="#验证语法正确" class="headerlink" title="验证语法正确"></a>验证语法正确</h4><p>转回SQL语句，传入执行<br>    if 成功执行 -&gt; 语法正确，继续使用<br>    else -&gt; 丢弃</p><h1 id="Semantics-Guided-Instantiation-语义引导实例化"><a href="#Semantics-Guided-Instantiation-语义引导实例化" class="headerlink" title="Semantics-Guided Instantiation 语义引导实例化"></a>Semantics-Guided Instantiation 语义引导实例化</h1><h2 id="1-Data-Dependency-Inference"><a href="#1-Data-Dependency-Inference" class="headerlink" title="1) Data Dependency Inference"></a>1) Data Dependency Inference</h2><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232342861.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232342861.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230509220312"><br>灰色线是从属关系，黑色线是对等关系</p><p>细化数据类型，遵循<strong>lifetime原则：用前创建，删后不用</strong></p><p>关系规则是一个包含四个元素的元组（α,β,γ,S）：α是关系目标，β是关系源； γ 定义关系； S 表示关系的范围</p><h2 id="2-IR-Instantiation"><a href="#2-IR-Instantiation" class="headerlink" title="2) IR Instantiation"></a>2) IR Instantiation</h2><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232342139.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232342139.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230509221712"></p><blockquote><p>dataMap：跟踪具有不同类型的唯一名称<br>relationMap：将每个元素映射到其依赖项</p></blockquote><h4 id="验证语义正确"><a href="#验证语义正确" class="headerlink" title="验证语义正确"></a>验证语义正确</h4><p>转回SQL语句，传入执行<br>    if 满足依赖性，成功执行 -&gt; 语义正确，继续使用<br>     else -&gt; 丢弃<br>    if interesting -&gt; 保存入队列</p><h1 id="Implementation-amp-Evaluation"><a href="#Implementation-amp-Evaluation" class="headerlink" title="Implementation &amp; Evaluation"></a>Implementation &amp; Evaluation</h1><p>此处略</p><h1 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h1><h3 id="1-DBMS-Specific-Logic"><a href="#1-DBMS-Specific-Logic" class="headerlink" title="1. DBMS-Specific Logic"></a>1. DBMS-Specific Logic</h3><p>-&gt;针对不同DBMS系统的SQL方言语法进行设计可以提高测试效果</p><h3 id="2-Relation-Rule-Construction"><a href="#2-Relation-Rule-Construction" class="headerlink" title="2. Relation-Rule Construction"></a>2. Relation-Rule Construction</h3><p>人工编写关系规则 -&gt; 自动推断（数据流分析&#x2F;深度学习）</p><h3 id="3-Collisions-in-Code-Coverage"><a href="#3-Collisions-in-Code-Coverage" class="headerlink" title="3. Collisions in Code-Coverage"></a>3. Collisions in Code-Coverage</h3><p>扩大Bitmap的大小以缓解Collision</p><h3 id="4-Alternative-Feedback-Mechanisms"><a href="#4-Alternative-Feedback-Mechanisms" class="headerlink" title="4. Alternative Feedback Mechanisms"></a>4. Alternative Feedback Mechanisms</h3><p>code coverage VS semantics-correct queries -&gt; 有害的代码覆盖率阻碍了语义正确查询的生成</p><h1 id="Related-Work-amp-Conclusion"><a href="#Related-Work-amp-Conclusion" class="headerlink" title="Related Work &amp; Conclusion"></a>Related Work &amp; Conclusion</h1><p>略</p><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p><strong>SQUIRREL: Testing Database Management Systems with Language Validity and Coverage Feedback</strong>这篇论文提出了一种新型的自动化测试工具Squirrel，它的主要作用是用于测试关系型数据库管理系统(DBMS)。这篇论文在2020年11月首次发表在2020 ACM SIGSAC Conference上，作者为来自宾夕法尼亚州立大学和佐治亚理工学院的Rui Zhong等6人，当前在Google学术上被引用次数为40次。</p><p>模糊测试是一种用于验证软件功能和查找软件安全漏洞的技术。但是，目前基于突变（mutation）的模糊器（fuzzer）无法有效测试会严格检查输入的语法语义正确性的数据库管理系统；基于生成（generation）的测试无法利用反馈来指导测试路径。</p><p>基于以上现状，本文整合了上述两种测试框架的优点，介绍了一种名为Sqirrel的新型模糊测试框架，用于测试数据库管理系统（DBMS），同时考虑了语言有效性和覆盖反馈。Squirrel使用中间表示（IR, Intermediate Representation）以结构化和信息化的方式维护SQL查询，并对IR进行基于类型的变异以生成语法正确的查询。它还分析每个IR以识别参数之间的逻辑依赖关系，并生成满足这些依赖关系的查询以减轻语义错误。</p><p>Squirrel的测试流程包括以下步骤： </p><ol><li>生成初始查询：Sqirrel使用基于模型的生成方法生成初始查询。</li><li>转换为IR：Sqirrel将初始查询转换为IR，以便于后续的变异和分析。 </li><li>变异：Sqirrel对IR进行基于类型的变异，以生成语法正确的查询。</li><li>依赖分析：Sqirrel分析每个IR以识别参数之间的逻辑依赖关系，并生成满足这些依赖关系的查询以减轻语义错误。</li><li>执行查询：Sqirrel执行生成的查询，并记录覆盖信息。</li><li>覆盖反馈：Sqirrel使用覆盖信息来指导下一轮变异，以提高测试效率和覆盖率。<br>这个流程不断迭代，直到达到预设的测试目标或者测试时间结束。<br>上述6个流程是对Squirrel框架的高度概括，在具体实现上仍有很多较为细节的步骤，保证了Squirrel框架的结果准确、逻辑合理、运算高效，整个框架的代码实现超过了四万行。</li></ol><p>随后，作者将Squirrel框架在真实的数据库管理系统上测试。主要关注以下三个问题：<br>是否能检测出内存漏洞？是否超过了SOTA的测试工具？语言正确性和覆盖率反馈在测试中的作用如何？</p><p>由此，将实验分为三个部分：语法正确性测试、语义正确性测试和性能测试。</p><p>在语法正确性和语义正确性测试中，作者使用Sqirrel、AFL、SQLsmith、QSYM、Angora和GRIMOIRE等六个工具对SQLite和MySQL进行测试，并比较了它们的测试效果。作者使用了10个已知的语法错误和缺陷来评估这些工具的测试效果，并计算了它们的错误检测率和测试时间。</p><p>在性能测试中，作者使用了Sqirrel、AFL、SQLsmith、QSYM、Angora和GRIMOIRE等六个工具对SQLite和MySQL进行测试，并比较了它们的测试效果。作者使用了10个已知的性能问题来评估这些工具的测试效果，并计算了它们的测试时间和覆盖率。</p><p>Sqirrel在40天内发现了四个流行的DBMSs上的63个内存错误问题，其中包括51个SQLite错误、7个MySQL错误和5个MariaDB错误。综合实验各项指标，其结果表明Sqirrel在语法正确性测试、语义正确性测试和性能测试中都表现出色，能够有效地检测出各种类型的错误和缺陷，并且具有较高的测试效率和覆盖率。</p><p>最后，对文章所做的研究不足之处及未来可以继续开展工作总结如下：</p><ol><li><p>提高测试效率：本文中提到Sqirrel的测试效率相对较低，需要较长的时间来生成测试用例。结合我自身复现代码的过程也印证了这一点。因此，未来的工作可以探索如何提高测试效率，例如使用并行化技术或者优化测试用例生成算法。</p></li><li><p>提高测试覆盖率：本文中Sqirrel的测试覆盖率仍有提升空间。未来的工作可以探索如何提高测试覆盖率，例如使用符号执行技术或者结合其他测试方法。</p></li><li><p>改进测试用例生成算法：本文中使用的测试用例生成算法可以生成语法正确的测试用例，但是无法保证语义正确。未来的工作可以探索如何改进测试用例生成算法，以提高测试用例的语义正确性。</p></li><li><p>扩展到其他类型的漏洞：本文中Sqirrel主要用于检测内存损坏漏洞，而数据库管理系统中存在的漏洞多种多样，面对的外部威胁更是防不胜防。未来的工作可以探索如何将Squirrel扩展到检测其他类型的漏洞，例如SQL注入漏洞或者逻辑漏洞等。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是一篇Fuzzing测试相关论文的阅读随记，主要为了理清思路方法，文章题目是：&lt;strong&gt;SQUIRREL: Testing Database Management Systems with Language Validity and Coverage Feedbac</summary>
      
    
    
    
    <category term="笔记" scheme="https://kievvv.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Fuzzing" scheme="https://kievvv.github.io/tags/Fuzzing/"/>
    
    <category term="Database" scheme="https://kievvv.github.io/tags/Database/"/>
    
    <category term="SQL" scheme="https://kievvv.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>密码学笔记</title>
    <link href="https://kievvv.github.io/2023/07/19/002CryptoNote/"/>
    <id>https://kievvv.github.io/2023/07/19/002CryptoNote/</id>
    <published>2023-07-19T13:36:33.000Z</published>
    <updated>2023-09-23T15:40:08.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><h2 id="信息安全基本属性"><a href="#信息安全基本属性" class="headerlink" title="信息安全基本属性"></a>信息安全基本属性</h2><ul><li><strong>机密性 （Confidentiality）</strong><br>保证信息为授权者使用而不泄漏给未经授权者。<br>别人“看不到”或“看不懂”</li><li><strong>认证（Authentication）</strong><br>消息认证，保证消息来源的真实性<br>身份认证，确保通信实体的真实性<br>证明“你就是你”</li><li><strong>完整性 （Integrity）</strong><br>数据完整性，未被未授权篡改或者损坏<br>系统完整性，系统未被非授权操纵，按既定的功能运行<br>信息没有被“动过”</li><li><strong>不可否认性（Non-repudiation ）</strong><br>要求无论发送方还是接收方都不能抵赖所进行的传输</li><li><em>可靠性（Reliability）</em><br>特定行为和结果的一致性</li><li><em>可用性 （Availability）</em><br>保证信息和信息系统随时为授权者提供服务，而不要出现非授权者滥用却对授权者拒绝服务的情况。</li><li><em>可控性（Controllability）</em><br>授权实体可以控制信息系统和信息使用的特性</li><li><em>审计（Accountability）</em><br>确保实体的活动可被跟踪</li></ul><h2 id="密码编码学"><a href="#密码编码学" class="headerlink" title="密码编码学"></a>密码编码学</h2><h3 id="密码算法的分类"><a href="#密码算法的分类" class="headerlink" title="密码算法的分类"></a>密码算法的分类</h3><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232319818.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232319818.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230629170445"></p><h4 id="按功能"><a href="#按功能" class="headerlink" title="按功能"></a>按功能</h4><p>加密算法：用于机密性解决方案<br>杂凑函数：用于完整性解决方案<br>数字签名：用于认证和不可否认性</p><h4 id="按密钥的使用方式"><a href="#按密钥的使用方式" class="headerlink" title="按密钥的使用方式"></a>按密钥的使用方式</h4><p><strong>对称密钥密码</strong> : 加密密钥与解密密钥相同<br><strong>非对称密钥密码（公钥密码）</strong>:加密密钥与解密密钥不同<br>    公钥密码部分解决了对称密钥密码算法中<strong>密钥共享</strong>、<strong>密钥管理</strong>的问题。</p><ul><li><p>第一代公开的、完全说明细节的商业级密码标准是<strong>DES</strong></p></li><li><p>被动攻击与主动攻击<br>被动攻击-&gt;不影响通讯<br>网络嗅探、流量分析<br>主动攻击-&gt;影响通讯<br>网络中断、假冒身份、数据包篡改</p></li></ul><h2 id="密码分析学"><a href="#密码分析学" class="headerlink" title="密码分析学"></a>密码分析学</h2><h3 id="安全的概念"><a href="#安全的概念" class="headerlink" title="安全的概念"></a>安全的概念</h3><h4 id="Kerckhoffs假设"><a href="#Kerckhoffs假设" class="headerlink" title="Kerckhoffs假设"></a>Kerckhoffs假设</h4><p>假定密码分析者和敌手知道所使用的密码系统。 即<strong>密码体制的安全性仅依赖于对密钥的保密</strong>,而不应依赖于算法的保密。</p><h4 id="密码分析学的目标"><a href="#密码分析学的目标" class="headerlink" title="密码分析学的目标"></a>密码分析学的目标</h4><ol><li><strong>破译密文</strong></li><li><strong>破译密钥</strong></li><li><strong>破译出明文</strong></li></ol><p><em>密文是[破译]的基础，密钥是[破译]的核心目标，而明文虽然是有用的想要的信息，但它是[破译出]密钥后才有的产物，所以核心是破译密文和密钥</em></p><h3 id="密码分析方法的分类"><a href="#密码分析方法的分类" class="headerlink" title="密码分析方法的分类"></a>密码分析方法的分类</h3><h4 id="攻击密码体制的方法"><a href="#攻击密码体制的方法" class="headerlink" title="攻击密码体制的方法"></a>攻击密码体制的方法</h4><ol><li><strong>穷举攻击</strong>：通过<strong>试遍</strong>所有的密钥来进行破译。<br>对抗：可增大密钥的数量。</li><li><strong>统计分析攻击</strong>：通过分析密文和明文的<strong>统计规律</strong>来破译。<br>对抗：设法使明文和密文的统计规律不一样。</li><li><strong>解密变换攻击</strong>：针对加密变换的数学基础，通过<strong>数学求解</strong>设法找到解密变换。<br>对抗：选用具有坚实的数学基础和足够复杂的加密算法。</li></ol><h4 id="密码破译"><a href="#密码破译" class="headerlink" title="密码破译"></a>密码破译</h4><ol><li><p><strong>唯密文攻击（Ciphertext Only Attack）</strong>：在唯密文攻击中，<strong>攻击者只能获取到加密后的密文</strong>，没有任何关于明文或密钥的其他信息。攻击者的目标是通过分析密文来推断出明文或密钥的信息。</p></li><li><p><strong>已知明文攻击（Known Plaintext Attack）</strong>：在已知明文攻击中，<strong>攻击者可以获取到一些已知明文和对应的密文对</strong>。攻击者的目标是通过这些已知对来破解密钥或加密算法。</p></li><li><p><strong>选择明文攻击（Chosen Plaintext Attack）</strong>：在选择明文攻击中，<strong>攻击者可以选择一些明文，并获取对应的密文</strong>。攻击者可以根据这些选择的明文和对应的密文来分析加密算法或破解密钥。</p></li><li><p><strong>选择密文攻击（Chosen Ciphertext Attack）</strong>：在选择密文攻击中，<strong>攻击者可以选择一些密文，并获取对应的解密结果或其他与密文相关的信息</strong>。攻击者可以利用这些选择的密文和相关信息来破解密钥或分析加密算法。</p></li></ol><p><strong>以上攻击强度依次递增</strong></p><h3 id="无条件安全和计算上安全"><a href="#无条件安全和计算上安全" class="headerlink" title="无条件安全和计算上安全"></a>无条件安全和计算上安全</h3><h4 id="无条件安全的-不可破译的"><a href="#无条件安全的-不可破译的" class="headerlink" title="无条件安全的(不可破译的)"></a>无条件安全的(不可破译的)</h4><p>无论截获多少密文，都没有足够信息来唯一确定明文，则该密码是无条件安全的，即<strong>对算法的破译不比猜测有优势</strong></p><h4 id="计算上安全的"><a href="#计算上安全的" class="headerlink" title="计算上安全的"></a>计算上安全的</h4><p>使用<strong>有限资源</strong>对一个密码系统进行分析而未能破译，则该密码是强的或计算上安全的</p><h5 id="计算上安全的密码算法要满足的准则"><a href="#计算上安全的密码算法要满足的准则" class="headerlink" title="计算上安全的密码算法要满足的准则"></a>计算上安全的密码算法要满足的准则</h5><ol><li>破译密文的代价超过被加密信息的价值。</li><li>破译密文所花的时间超过信息的有用期。</li></ol><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p>Kerckhoffs假设指的是？<br>密码分析的目标在于？</p><h2 id="古典密码算法"><a href="#古典密码算法" class="headerlink" title="古典密码算法"></a>古典密码算法</h2><h3 id="置换密码"><a href="#置换密码" class="headerlink" title="置换密码"></a>置换密码</h3><p><strong>置换（Permutation）</strong><br>对明文字符或字符组进行位置移动的密码<br>明文的字母保持相同，但顺序被打乱了。<br>    值不变顺序变</p><h3 id="单表代替密码算法"><a href="#单表代替密码算法" class="headerlink" title="单表代替密码算法"></a>单表代替密码算法</h3><p><strong>代替(Substitution)</strong><br>密码构造一个或多个密文字母表，然后用密文 字母表中的字母或者字母组来代替明文字母或字母组，各字母或 字母组的相对位置不变，但其本身的值改变了。<br>    值变顺序不变</p><h4 id="加法密码"><a href="#加法密码" class="headerlink" title="加法密码"></a>加法密码</h4><p><strong>凯撒密码</strong></p><h4 id="乘法密码"><a href="#乘法密码" class="headerlink" title="乘法密码"></a>乘法密码</h4><h4 id="仿射密码"><a href="#仿射密码" class="headerlink" title="仿射密码"></a>仿射密码</h4><ul><li><p>仿射密码是乘法密码和加法密码的结合。<br>加密函数：y&#x3D;ax+b(mod26)<br>密钥：a，b<br>解密函数：x&#x3D;a^(-1)(y-b)(mod26)</p></li><li><p>缺点：不能对抗统计分析</p></li></ul><h3 id="多表代替密码算法"><a href="#多表代替密码算法" class="headerlink" title="多表代替密码算法"></a>多表代替密码算法</h3><p><strong>Vigenere（维吉尼亚）密码</strong></p><h2 id="可证明安全性"><a href="#可证明安全性" class="headerlink" title="可证明安全性"></a>可证明安全性</h2><h3 id="密码游戏与规约"><a href="#密码游戏与规约" class="headerlink" title="密码游戏与规约"></a>密码游戏与规约</h3><p>把密码破译归结到困难问题上，而当困难问题实际上是简单的：</p><ol><li>密码不安全，可通过解决困难问题来攻破</li><li>密码还是安全的，但是不是可证明安全</li></ol><h3 id="CDH假设"><a href="#CDH假设" class="headerlink" title="CDH假设"></a>CDH假设</h3><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230613233558.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230613233558.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h1 id="第二章-流密码"><a href="#第二章-流密码" class="headerlink" title="第二章 流密码"></a>第二章 流密码</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="一次一密"><a href="#一次一密" class="headerlink" title="一次一密"></a>一次一密</h3><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232319965.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232319965.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230609143652"><br>• 优点：<br>• 密钥随机产生，仅使用一次<br>• 无条件安全<br>• 加密和解密为加法运算，效率较高<br>• 缺点：<br>• 密钥长度至少与明文长度一样长<br>• 密钥共享困难，不太实用</p><p>• 改进：<br>• 种子密钥生成无限长的密钥（流密码的思想，共享一小段）</p><p>流密码的基本思想<br>• 利用密钥k产生一个密钥流z&#x3D;z0z1z2…，并使用如下规则对明文串<br>x&#x3D;x0x1x2…（加法或者简单处理方法）加密：<br>y&#x3D;y0y1y2…＝Ez0(x0)Ez1(x1) Ez2(x2)…，</p><h3 id="流密码的定义"><a href="#流密码的定义" class="headerlink" title="流密码的定义"></a>流密码的定义</h3><p>内部记忆元件的状态σi独立于明文字符的叫做同步流密码，否则叫<br>做自同步流密码。<br>在同步流密码中，由于zi&#x3D;f(k,σi)与明文字符无关，因而此时密文字符yi&#x3D;Ezi(xi)也不依赖于此前的明文字符。<br>可将同步流密码的加密器分成密钥流产生器和加密变换器两个部分。</p><h3 id="同步流密码"><a href="#同步流密码" class="headerlink" title="同步流密码"></a>同步流密码</h3><p><img src="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230609160714.png" class="lazyload" data-srcset="https://cdn.staticaly.com/gh/kievvv/blogcdn@master/img/Pasted%20image%2020230609160714.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p><p>密码设计者的最大愿望是设计出一个滚动密钥生成器，使得密钥经其扩展成的密钥流序列具有如下性质：<br>极大的周期<br>良好的统计特性<br>抗线性分析</p><h3 id="有限状态自动机模型"><a href="#有限状态自动机模型" class="headerlink" title="有限状态自动机模型"></a>有限状态自动机模型</h3><p>有限状态自动机可用有向图表示，称为转移图<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232321859.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232321859.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230609161615"><br>箭头和箭尾代表状态，（)中前者代表引起状态改变的输入，后者代表状态改变后的输出</p><h3 id="密钥流生成器"><a href="#密钥流生成器" class="headerlink" title="密钥流生成器"></a>密钥流生成器</h3><p>密钥流产生器: 参数为k的有限状态自动机，<br>一个输出符号集Z、一个状态集∑、两个函数φ和ψ以及一个初始状态σ0组成。<br>状态转移函数φ:σi→σi+1，将当前状态σi变为一个新状态σi+1，<br>输出函数ψ:σi→zi，当前状态σi变为输出符号集中的一个元素zi。<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232321101.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232321101.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230609161759"><br>一般采用线性的φ和非线性的ψ<br>密钥流生成器可分成驱动部分和非线性组合部分<br>驱动部分是一个或多个线性反馈 移位寄存器。（LFSR是流密码构造的关键模块)</p><h2 id="二元序列的伪随机性"><a href="#二元序列的伪随机性" class="headerlink" title="二元序列的伪随机性"></a>二元序列的伪随机性</h2><h3 id="二元序列的相关概念"><a href="#二元序列的相关概念" class="headerlink" title="二元序列的相关概念"></a>二元序列的相关概念</h3><p>GF（2）上的一个无限序列-&gt;a&#x3D;(a1,a2,…,an,…)称为二元序列，若 ai属于GF(2)，0或者1。</p><p><strong>游程</strong><br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232322051.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232322051.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230609162824"></p><p><strong>自相关函数</strong></p><h3 id="伪随机序列满足条件"><a href="#伪随机序列满足条件" class="headerlink" title="伪随机序列满足条件"></a>伪随机序列满足条件</h3><p><strong>Golomb伪随机公设</strong><br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232322654.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232322654.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230609162943"></p><h2 id="线性反馈移位寄存器"><a href="#线性反馈移位寄存器" class="headerlink" title="线性反馈移位寄存器"></a>线性反馈移位寄存器</h2><h3 id="反馈移位寄存器"><a href="#反馈移位寄存器" class="headerlink" title="反馈移位寄存器"></a>反馈移位寄存器</h3><p>GF(2)上一个n级反馈移位寄存器由n个二元存储器与一个反馈函数f(a1,a2,…,an) 组成</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232322143.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232322143.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230609163935"></p><p>反馈函数f(a1,a2,…,an)是n元布尔函数，即函数的自变量和因变量只取0和1这 两个可能的值。</p><h3 id="线性反馈移位寄存器-1"><a href="#线性反馈移位寄存器-1" class="headerlink" title="线性反馈移位寄存器"></a>线性反馈移位寄存器</h3><p>反馈函数是个线性函数<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232322381.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232322381.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230609164316"></p><p><strong>密钥流的周期</strong><br>给定密钥流 ，如果存在整数r，使得 对于任意 ，都有 ，则称 r为该密钥流的一个周期， 称满足 的最小正整数为该密钥流的最小周期或简称周期。</p><h2 id="m-序列"><a href="#m-序列" class="headerlink" title="m-序列"></a>m-序列</h2><h3 id="线性反馈移位寄存器的多项式表示"><a href="#线性反馈移位寄存器的多项式表示" class="headerlink" title="线性反馈移位寄存器的多项式表示"></a>线性反馈移位寄存器的多项式表示</h3><p>定理2.2 p(x)|q(x)的充要条件是G(p(x)) Í G(q(x))</p><h3 id="m-序列产生的条件"><a href="#m-序列产生的条件" class="headerlink" title="m-序列产生的条件"></a>m-序列产生的条件</h3><h4 id="Golomb伪随机公设"><a href="#Golomb伪随机公设" class="headerlink" title="Golomb伪随机公设"></a>Golomb伪随机公设</h4><p>①在序列的一个周期内，0与1的个数相差至多为1。<br>②在序列的一个周期内，长为i的游程占游程总数的1&#x2F;2i (i&#x3D;1,2,…)，且在等长的游程中0的游程个数和1的游程个数相等。<br>③异相自相关函数是一个常数。</p><h3 id="m-序列安全性"><a href="#m-序列安全性" class="headerlink" title="m-序列安全性"></a>m-序列安全性</h3><h4 id="解方程方法"><a href="#解方程方法" class="headerlink" title="解方程方法"></a>解方程方法</h4><h4 id="线性反馈移位寄存器综合求解法"><a href="#线性反馈移位寄存器综合求解法" class="headerlink" title="线性反馈移位寄存器综合求解法"></a>线性反馈移位寄存器综合求解法</h4><h2 id="非线性序列"><a href="#非线性序列" class="headerlink" title="非线性序列"></a>非线性序列</h2><p>密钥流生成器可分解为<strong>驱动子系统</strong>和<strong>非线性组合子系统</strong><br>驱动子系统常用一个或多个线性反馈移位寄存器来实现<br>非线性组合子系统用非线性组合函数F来实现</p><p>密钥k扩展 而成的密钥流序列z应满足的性质：</p><ol><li>种子密钥的长度足够长（一般来说就是流密码的密钥长度）</li><li>极大的周期</li><li>良好的统计特性</li><li>极大的线性复杂度</li><li>极大的k错线性复杂度</li><li>抗统计分析</li><li>混乱性</li><li>扩散性</li><li>抗线性分析</li></ol><h3 id="Geffe序列生成器"><a href="#Geffe序列生成器" class="headerlink" title="Geffe序列生成器"></a>Geffe序列生成器</h3><h3 id="J-K触发器"><a href="#J-K触发器" class="headerlink" title="J-K触发器"></a>J-K触发器</h3><h3 id="Pless生成器"><a href="#Pless生成器" class="headerlink" title="Pless生成器"></a>Pless生成器</h3><h1 id="第三章-分组密码"><a href="#第三章-分组密码" class="headerlink" title="第三章 分组密码"></a>第三章 分组密码</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232323222.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232323222.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230614213510"><br>通常取n&#x3D;m<br>若n&lt;m ，则为有数据扩展的分组密码。<br>若n&gt;m ，则为有数据压缩的分组密码。</p><h2 id="安全性设计原则"><a href="#安全性设计原则" class="headerlink" title="安全性设计原则"></a>安全性设计原则</h2><h3 id="混淆原则-Confusion"><a href="#混淆原则-Confusion" class="headerlink" title="混淆原则(Confusion)"></a>混淆原则(Confusion)</h3><ul><li>混淆原则就是将密文、明文、密钥三者之间的统计关系和代数关系变 得尽可能复杂，使得敌手即使获得了密文和明文，也无法求出密钥的任何信息</li><li>即使获得了密文和明文的统计规律，也无法求出明文的新的信息</li></ul><ol><li><strong>明文</strong>不能由已知的明文，密文及少许密钥比特代数地或统计地表示出来。</li><li><strong>密钥</strong>不能由已知的明文，密文及少许密钥比特代数地或统计地表 示出来。</li></ol><p><strong>引入了非线性变化</strong></p><h3 id="扩散原则-Diffusion"><a href="#扩散原则-Diffusion" class="headerlink" title="扩散原则(Diffusion)"></a>扩散原则(Diffusion)</h3><ul><li>扩散原则就是应将明文的统计规律和结构规律散射到相当长的一段统计中去(Shannon的原话)</li><li>也就是说让明文中的每一位影响密文中的尽可能多的位，或者说让密 文中的每一位都受到明文中的尽可能多位的影响。<br>实际上扩散原则应该把密文和密钥的关系加进去，也就是<strong>要让密文中的每 一位影响尽可能多的位</strong></li></ul><h2 id="分组密码算法的要求"><a href="#分组密码算法的要求" class="headerlink" title="分组密码算法的要求"></a>分组密码算法的要求</h2><ul><li>分组长度n要足够大<br>防止明文穷举攻击</li><li>密钥量要足够大<br>使所有密钥同等地好+防止密钥穷举攻击</li><li>由密钥确定置换的算法要足够复杂<br>充分实现明文与密钥的扩散和混淆，没有简单的关系可循</li><li>加密和解密运算简单<br>易于高速实现</li><li>数据扩展</li><li>差错传播尽可能地小<br>一个密文分组的错误尽可能少的影响其他密文分组的解密</li></ul><h2 id="分组密码的结构"><a href="#分组密码的结构" class="headerlink" title="分组密码的结构"></a>分组密码的结构</h2><p>两种常见的分组密码结构是<strong>Feistel网络Feistel Net</strong>和 <strong>SP网络Substitution-permutation Net</strong></p><p>DES-&gt;Feistal<br>AES-&gt;SP</p><h3 id="代换"><a href="#代换" class="headerlink" title="代换"></a>代换</h3><p><strong>代换是输入集A到输出A’上的一一映射</strong><br>双射条件保证在给定k下可从密文惟一地恢复出原明文</p><h3 id="Feistel密码结构"><a href="#Feistel密码结构" class="headerlink" title="Feistel密码结构"></a>Feistel密码结构</h3><p>乘积密码指顺序地执行两个或多个基本密码系统，使得最后结果的密码强度高于每个基本密码系统产生的结果</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>分组大小<br>密钥大小<br>轮数<br>子密钥产生算法<br>轮函数</p><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><p>快速的软件实现<br>算法容易分析</p><h4 id="Feistel加密结构"><a href="#Feistel加密结构" class="headerlink" title="Feistel加密结构"></a>Feistel加密结构</h4><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232323745.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232323745.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230614214856"><br>将每组明文分成左右两半L0和R0，在进行完n轮迭代后，左右两半再合并到一起以产生密文分组<br>其中Ki是第i轮用的子密钥，由加密密钥K得到。一般地，各轮子密钥彼此不同而且与K也不同</p><h4 id="Feistel解密结构"><a href="#Feistel解密结构" class="headerlink" title="Feistel解密结构"></a>Feistel解密结构</h4><p>本质上和加密过程是一样的，子密钥Ki的次序与加密过程相反</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232323205.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232323205.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230614215050"></p><h3 id="DES算法"><a href="#DES算法" class="headerlink" title="DES算法"></a>DES算法</h3><h4 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h4><p>分组长度为64 bits (8 bytes)<br>密文分组长度也是64 bits<br>密钥长度为64 bits，有8 bits奇偶校验，有效密钥长度为56 bits</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232324214.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232324214.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230614220030"></p><p>初值置换IP</p><h5 id="16轮迭代的乘积变换"><a href="#16轮迭代的乘积变换" class="headerlink" title="16轮迭代的乘积变换"></a>16轮迭代的乘积变换</h5><h5 id="逆初值置换IP-1"><a href="#逆初值置换IP-1" class="headerlink" title="逆初值置换IP^-1"></a>逆初值置换IP^-1</h5><h4 id="轮函数"><a href="#轮函数" class="headerlink" title="轮函数"></a>轮函数</h4><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232325368.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232325368.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230614220043"><br>即<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232325894.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232325894.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230614220114"></p><h4 id="密钥编排"><a href="#密钥编排" class="headerlink" title="密钥编排"></a>密钥编排</h4><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232325760.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232325760.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230614220247"><br>即<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232325278.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232325278.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230614220300"></p><h4 id="填充Padding"><a href="#填充Padding" class="headerlink" title="填充Padding"></a>填充Padding</h4><p>给定加密消息的长度是随机的，按64bit分组时，最后一组消息 长度可能不足64 bit。可以填充一些数字，通常用最后1字节作为填 充指示符（PI）</p><h4 id="DES的安全性"><a href="#DES的安全性" class="headerlink" title="DES的安全性"></a>DES的安全性</h4><p>目前攻击DES的主要方法有时间-空间权衡攻击、差分攻击、线性攻击和相关 密钥攻击等方法<br><strong>线性攻击</strong>方法是最有效的一种方法</p><h4 id="多重DES"><a href="#多重DES" class="headerlink" title="多重DES"></a>多重DES</h4><p>多重DES就是使用多个密钥利用DES对明文进行多次加密<br>    可以增加密钥量</p><h5 id="双重DES"><a href="#双重DES" class="headerlink" title="双重DES"></a>双重DES</h5><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232325769.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232325769.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230614220613"></p><h6 id="中间相遇攻击"><a href="#中间相遇攻击" class="headerlink" title="中间相遇攻击"></a>中间相遇攻击</h6><h5 id="三重DES"><a href="#三重DES" class="headerlink" title="三重DES"></a>三重DES</h5><p>当k1&#x3D;k3时，则称为双密钥三重DES</p><h3 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h3><ul><li>工作模式：根据不同的数据格式和安全性要求, 以一个具体的分组密码算法为基础构造一个分组密码系统的方法</li></ul><h4 id="电码本-ECB-模式"><a href="#电码本-ECB-模式" class="headerlink" title="电码本(ECB)模式"></a>电码本(ECB)模式</h4><ul><li>直接利用加密算法分别对分组数据组加密<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232325336.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232325336.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230614221318"><br>优点：<br>（1）实现简单;<br>（2)不同明文分组的加密可并行实施，尤其是硬件实现时速度很快</li></ul><p>缺点：<br>（1）相同明文分组对应相同密文分组<br>（2）不能隐蔽明文分组的统计规律和结构规律,不能抵抗统计分析、重传和代换攻击</p><h4 id="密码分组链接-CBC-模式"><a href="#密码分组链接-CBC-模式" class="headerlink" title="密码分组链接(CBC)模式"></a>密码分组链接(CBC)模式</h4><ul><li>这种模式<strong>先将明文分组与上一次的密文块进行按比特异或</strong>，然后再进行加密处理<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232325933.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232325933.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230614221546"><br>特点：</li></ul><ol><li>明文块的统计特性得到了隐蔽-&gt;各密文块不仅与当前明文块有关，而且还与以前的 明文块及初始化向量有关</li><li>具有有限的错误传播特性（两步）-&gt;一个密文块的错误将导致两个密文块不能正确解密</li><li>具有自同步功能-&gt;密文出现丢块和错块不影响后续密文块的解密</li></ol><h4 id="密码反馈-CFB-模式"><a href="#密码反馈-CFB-模式" class="headerlink" title="密码反馈(CFB)模式"></a>密码反馈(CFB)模式</h4><p>若待加密消息需按字符、字节或比特处理时，可采用CFB模式。 并称待加密消息按 r 比特处理的CFB模式为 r 比特CFB模式</p><ul><li>选取最左边的r比特 作为加密密钥<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232326587.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232326587.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616101732"></li></ul><p>特点</p><ol><li>相同明文（改变IV同样会导致相同的明文输入得到不同的加密 输出。IV无需保密</li><li>链接依赖性（链接机制致使密文组依赖于当前明文组和其前面的明文组，重排密文组会影响解密</li><li>错误的传播（一个或多个比特错误出现在任一个r比特的密文组中</li><li>错误恢复（自同步</li></ol><h4 id="输出反馈-OFB-模式"><a href="#输出反馈-OFB-模式" class="headerlink" title="输出反馈(OFB)模式"></a>输出反馈(OFB)模式</h4><p>OFB模式在结构上类似于CFB模式，但反馈的内容是DES的输出而不是密文！<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232326418.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232326418.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616101753"></p><p>特点：</p><ol><li>相同明文（改变IV同样会导致相同的明文输入得到不同的加密 输出</li><li>没有链接依赖性（密钥流是独立于明文的</li><li>没有错误传播（有一个或多个比特错误的任一密文字符仅会影响 该字符的解密</li><li>错误恢复（OFB模式能从密文比特错误中得以恢复，但在丢失密文 比特后就无法实现自同步了，这是因为丢失密文比特会破坏密钥流 的编排</li></ol><h4 id="计数器（CTR）模式"><a href="#计数器（CTR）模式" class="headerlink" title="计数器（CTR）模式"></a>计数器（CTR）模式</h4><p>（OFB模式的简化版本）<br>结构<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232326404.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232326404.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616103420"></p><p>优点：</p><ol><li>效率（可并行加密、预处理、吞吐量仅受可使用并行数量的限制</li><li>加密数据块的随机访问</li><li>可证明安全</li><li>简单性（只要求实现加密算法</li></ol><h3 id="前四类工作模式比较和选用"><a href="#前四类工作模式比较和选用" class="headerlink" title="前四类工作模式比较和选用"></a>前四类工作模式比较和选用</h3><ol><li><strong>ECB模式</strong>简单、高速，但最弱，易受重放和替换攻击，一般用于加密长度小于等于分组长度的消息。</li><li>明文不易丢信号，对明文的格式没有特殊要求的环境可选用<strong>CBC模式</strong>。需要完整性认证功能时也可选用该模式。</li><li>容易丢信号的环境，或对明文格式有特殊要求的环境，可选用<strong>CFB模式</strong>。</li><li>不易丢信号，但信号特别容易错，且明文冗余特别多，可选用<strong>OFB模式</strong>。</li></ol><h3 id="有限域"><a href="#有限域" class="headerlink" title="有限域"></a>有限域</h3><h3 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h3><h4 id="AES提出的背景"><a href="#AES提出的背景" class="headerlink" title="AES提出的背景"></a>AES提出的背景</h4><p>DES算法由于其密钥较短，难以抵抗现有的攻击，因此不再作 为加密标准</p><h4 id="AES算法框架和参数说明"><a href="#AES算法框架和参数说明" class="headerlink" title="AES算法框架和参数说明"></a>AES算法框架和参数说明</h4><h5 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h5><p>设计简单<br>速度快，编码紧凑<br>抵抗所有已知的攻击<br>没有采用Feistel结构，轮函数由3个不同的可逆均匀变 换构成的</p><h5 id="轮函数-1"><a href="#轮函数-1" class="headerlink" title="轮函数"></a>轮函数</h5><p>线性混合层-&gt;确保多轮之上的高度扩散<br>非线性层-&gt;将具有最优的“最坏情况非线性特性”的S盒并行使用，确保混淆特性<br>密钥加层-&gt;单轮子密钥简单的异或到中间状态上，实现一次性掩盖</p><h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232326348.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232326348.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616105100"></p><h4 id="轮函数-2"><a href="#轮函数-2" class="headerlink" title="轮函数"></a>轮函数</h4><h5 id="字节代换（S盒）"><a href="#字节代换（S盒）" class="headerlink" title="字节代换（S盒）"></a>字节代换（S盒）</h5><p>解密用到逆S盒</p><h5 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h5><p>状态阵列的各行进行循环移位，不同行的移位量不同<br>0行：不动<br>1行：循环左移C1字节<br>2行：循环左移C2字节<br>3行：循环左移C3字节</p><p>解密则相应逆行移位</p><h5 id="列混淆"><a href="#列混淆" class="headerlink" title="列混淆"></a>列混淆</h5><p>列混合运算也可写为矩阵乘法</p><h5 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h5><p>轮密钥与状态进行逐比特异或<br>轮密钥由种子密钥通过密钥编排算法得到<br>轮密钥长度与分组长度相同</p><h4 id="AES密钥编排"><a href="#AES密钥编排" class="headerlink" title="AES密钥编排"></a>AES密钥编排</h4><p>由<strong>密钥扩展</strong>和<strong>轮密钥选取</strong>两部分组成</p><h3 id="SM4算法"><a href="#SM4算法" class="headerlink" title="SM4算法"></a>SM4算法</h3><ul><li>SM4是一个<strong>分组密码算法</strong>，<strong>分组长度和密钥长度均为128比特</strong>。加密算法与密钥扩展算法都采用<strong>32轮非线性迭代结构</strong></li></ul><h4 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h4><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232326173.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232326173.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616111713"></p><h1 id="第四章-公钥密码"><a href="#第四章-公钥密码" class="headerlink" title="第四章 公钥密码"></a>第四章 公钥密码</h1><h2 id="对称密码的困境"><a href="#对称密码的困境" class="headerlink" title="对称密码的困境"></a>对称密码的困境</h2><p>-&gt;密钥共享和管理<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232326218.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232326218.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616112025"></p><p>-&gt;不支持“开放系统”<br>两个没有预先建立关系的用户<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232327720.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232327720.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616112909"></p><h2 id="公钥密码体制"><a href="#公钥密码体制" class="headerlink" title="公钥密码体制"></a>公钥密码体制</h2><ul><li>主要思想：从一个方向计算非常容易，而 从另一个方向计算则很困难</li></ul><h3 id="公钥密码的理论基础-陷门单向函数"><a href="#公钥密码的理论基础-陷门单向函数" class="headerlink" title="公钥密码的理论基础: 陷门单向函数"></a>公钥密码的理论基础: <strong>陷门单向函数</strong></h3><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232327460.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232327460.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616112443"><br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232327867.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232327867.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616112453"></p><ul><li><p>公钥加密结构<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232327681.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232327681.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616112635"></p></li><li><p>公钥认证结构<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232327475.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232327475.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616112721"></p></li><li><p>公钥密码体制的优势<br>密钥分发：公钥能够采用公开（认证的）信道进行传输；<br>密钥管理：在用户N个用户的系统中，每个用户只需安全保管自己的私钥和N-1个 其他用户的公钥。整个系统仅仅需要维护N个公钥；<br>开放系统：即使是没有预先建立关系的用户也能通过对方的公钥建立安全通信。</p></li><li><p>公钥密码的主要作用</p></li></ul><ol><li>公钥加密</li><li>数字签名</li><li>基于公钥的密钥分配</li></ol><h3 id="公钥密码算法的要求"><a href="#公钥密码算法的要求" class="headerlink" title="公钥密码算法的要求"></a>公钥密码算法的要求</h3><p>容易的：<br>接收方B产生密钥对（PK.B和SK.B）在计算上是容易的。<br>发方A对消息m加密以产生密文c，即c&#x3D;E.PKB[m]在计算上是容易的。<br>收方B用自己的秘密钥对c解密，即m&#x3D;D.SKB[c]在计算上是容易的。</p><p>不可行：<br>敌手由PKB求SKB在计算上是不可行的。<br>敌手由密文c和PKB恢复明文m在计算上是不可行的。</p><p>研究公钥密码算法就是要找出合适的陷门单向函数。</p><h3 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ol><li>选择两个大素数p, q 。</li><li>计算 m&#x3D;pq, z&#x3D;(p-1)(q-1) 。</li><li>随机选取 e（其中e&lt;n ）， e与z没有公因数。（ e, z“互为质数”）</li><li>选取d使得ed-1能够被z完全整除。 （换言之：ed mod z &#x3D; 1 ）</li><li>公钥是 (n,e)。私钥是(n,d) 。<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232328786.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232328786.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616114507"></li></ol><h4 id="加解密过程"><a href="#加解密过程" class="headerlink" title="加解密过程"></a>加解密过程</h4><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232328405.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232328405.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616114417"></p><p>例题<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232328932.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232328932.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616150625"></p><p>RSA的加密、解密过程都为求一个整数的整数次幂，再取模。如果按其 含义直接计算，则中间结果非常大，有可能超出计算机所允许的整数取值 范围。<br>而用模运算的性质：(a×b) mod n&#x3D;[(a mod n)×(b mod n)] mod n 就可减小中间结果。</p><h4 id="RSA密钥的产生"><a href="#RSA密钥的产生" class="headerlink" title="RSA密钥的产生"></a>RSA密钥的产生</h4><ol><li>两个大素数p、q的选取。-&gt;Miller-Rabin算法</li><li>e的选取和d的计算-&gt;选取满足1&lt;e&lt;φ(n)和gcd(φ(n),e)&#x3D;1的e，并计算满足d·e≡1 mod φ(n)的d。这一问题可由推广的Euclid算法完成。</li></ol><h4 id="RSA的安全性"><a href="#RSA的安全性" class="headerlink" title="RSA的安全性"></a>RSA的安全性</h4><p>RSA的安全性是基于<strong>分解大整数的困难性</strong>假定<br>RSA是确定性的加密算法, <strong>不能抵御选择密文攻击</strong>。</p><h5 id="几个困难问题"><a href="#几个困难问题" class="headerlink" title="几个困难问题"></a>几个困难问题</h5><ol><li>大整数分解问题（factorization problem）</li><li>离散对数问题（discrete logarithm problem）</li><li>多项式求根问题</li><li>二次剩余问题（quadratic residue problem）</li><li>背包问题（knapsack problem）</li></ol><h3 id="ElGamal公钥密码体制"><a href="#ElGamal公钥密码体制" class="headerlink" title="ElGamal公钥密码体制"></a>ElGamal公钥密码体制</h3><p>Elgamal加密<strong>基于CDH假设的单向性</strong></p><h4 id="ElGamal公钥密码体制历史"><a href="#ElGamal公钥密码体制历史" class="headerlink" title="ElGamal公钥密码体制历史"></a>ElGamal公钥密码体制历史</h4><h4 id="ElGamal公钥加密体制原理"><a href="#ElGamal公钥加密体制原理" class="headerlink" title="ElGamal公钥加密体制原理"></a>ElGamal公钥加密体制原理</h4><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232328661.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232328661.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616154338"></p><p>特点：</p><ol><li>安全性基于有限域上的离散对数的难解性</li><li>加密算法是概率算法</li><li>不能抵御选择密文攻击</li><li>存在密文扩张</li></ol><h4 id="ElGamal密码的安全性"><a href="#ElGamal密码的安全性" class="headerlink" title="ElGamal密码的安全性"></a>ElGamal密码的安全性</h4><p>参数要求：p应为150位以 上十进制数，500位以上的 二进制数，p-1应有大素数因子。<br>K必须保密而且必须是一次性的。</p><h3 id="ElGamal与RSA的区别"><a href="#ElGamal与RSA的区别" class="headerlink" title="ElGamal与RSA的区别"></a>ElGamal与RSA的区别</h3><ul><li>RSA：大整数分解问题</li><li>ElGamal：循环群的离散对数问题</li></ul><h3 id="椭圆曲线密码"><a href="#椭圆曲线密码" class="headerlink" title="椭圆曲线密码"></a>椭圆曲线密码</h3><p>椭圆曲线密码体制ECC（elliptic curve cryptography）可用短得多的密钥获得同样的安全性</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232329094.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232329094.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616160118"><br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232329491.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232329491.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616160127"></p><h4 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h4><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232330509.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232330509.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616160012"><br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232330106.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232330106.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616160315"></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>安全性高</li><li>密钥量小-&gt;在实现相同的安全性能条件下，椭圆曲线密码 体制所需的密钥量远比基于有限域上的离散对数问题的公钥体制的密钥量小</li><li>灵活性好</li></ol><h3 id="SM2椭圆曲线公钥密码加密算法"><a href="#SM2椭圆曲线公钥密码加密算法" class="headerlink" title="SM2椭圆曲线公钥密码加密算法"></a>SM2椭圆曲线公钥密码加密算法</h3><h4 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h4><p>中国商用公钥密码标准算法<br>一组椭 圆曲线密码算法，其中包含加解密算法、数字签名算法<br>安全性都是<strong>基于求解椭圆曲线上的离散对数问题</strong>的困难性</p><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><h5 id="密钥产生"><a href="#密钥产生" class="headerlink" title="密钥产生"></a>密钥产生</h5><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232330575.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232330575.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616163259"></p><h5 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h5><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232330479.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232330479.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616163317"></p><h5 id="加密流程图"><a href="#加密流程图" class="headerlink" title="加密流程图"></a>加密流程图</h5><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232330070.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232330070.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616163338"></p><h5 id="解密算法"><a href="#解密算法" class="headerlink" title="解密算法"></a>解密算法</h5><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232330172.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232330172.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616163453"></p><h5 id="解密流程图"><a href="#解密流程图" class="headerlink" title="解密流程图"></a>解密流程图</h5><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232331360.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232331360.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616163628"></p><h3 id="SM2与ECC的区别"><a href="#SM2与ECC的区别" class="headerlink" title="SM2与ECC的区别"></a>SM2与ECC的区别</h3><p>ECC算法通常采用NIST等国际机构建议的曲线及参数<br>SM2算法 的参数需要利用一定的算法产生-&gt;更安全</p><p>在ECC算法中，用户可以选择MD5、SHA-1等国际通用的哈希算法<br>SM2算法中则使用SM3哈希算法</p><p>SM的优点：解密算法中的检错</p><h1 id="第五章-哈希函数"><a href="#第五章-哈希函数" class="headerlink" title="第五章 哈希函数"></a>第五章 哈希函数</h1><h2 id="哈希函数的基本概念"><a href="#哈希函数的基本概念" class="headerlink" title="哈希函数的基本概念"></a>哈希函数的基本概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>将任意长的消息M映射为较短的、固定长度的一个值H(M)。<br>Hash函数也称为哈希函数、散列函数、压缩函数、杂凑函数、 指纹函数等<br>其函数值H(M)为哈希值、散列值、杂凑码、指 纹、消息摘要等</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>Hash函数的目的是为需认证的数据产生一个“指纹”</p><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><p>输入可以是任意长<br>输出是固定长<br>易于在软件和硬件实现</p><h3 id="安全条件"><a href="#安全条件" class="headerlink" title="安全条件"></a>安全条件</h3><ol><li>单向性</li><li>抗弱碰撞性</li><li>抗强碰撞性</li></ol><p>-&gt;三者有包含关系，满足后者即可满足前者</p><h2 id="生日攻击"><a href="#生日攻击" class="headerlink" title="生日攻击"></a>生日攻击</h2><h3 id="第一类生日攻击"><a href="#第一类生日攻击" class="headerlink" title="第一类生日攻击"></a>第一类生日攻击</h3><p>问题：“已知一杂凑函数H有n个可能的输出，H(x)是一个特定的输出，如果对H 随机取k个输入，则<strong>至少有一个输入y使得H(y)&#x3D;H(x)的概率为0.5时，k有多大？</strong>”<br>对杂凑函数H寻找上述y的攻击为<strong>第I类生日攻击</strong></p><p>H(y)&#x3D;H(x)的概率是1&#x2F;n &lt;&#x3D;&gt; H(y)≠H(x)的概率是1-1&#x2F;n</p><p>y取k个随机值得到函数的k个输出中，至少有一个等于H(x)的概率为1-[1-1&#x2F;n]^k (约等于k&#x2F;n)</p><p>若使上述概率等于0.5，则k&#x3D;n&#x2F;2。如果H的输出为m比特长，即可 能的输出个数n&#x3D;2m，则k&#x3D;2^(m-1)</p><h3 id="生日悖论"><a href="#生日悖论" class="headerlink" title="生日悖论"></a>生日悖论</h3><p>问题描述：“在k个人中<strong>至少有两个人的生日相同的概率大于0.5时，k至少多大？</strong>”<br>设有k个整数项，每一项都在1到n之间等可能地取值。<br>P(n, k)：k个整数项中至少有两个取值相同的概率<br><strong>生日悖论就是求使得P(365,k)≥0.5的最小k</strong><br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232331298.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232331298.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616174203"><br>P(365,23)&#x3D;0.5073，即只需23人</p><p>之所以称这一问题是悖论是因为： 当人数k给定时，得到的至少有两个人的生日相同的概率比想象的要大得多</p><h4 id="生日悖论推广问题"><a href="#生日悖论推广问题" class="headerlink" title="生日悖论推广问题"></a>生日悖论推广问题</h4><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232331094.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232331094.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616174451"><br>令P(n, k)&gt;0.5，可得<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232331038.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232331038.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616174530"></p><h3 id="第二类生日攻击"><a href="#第二类生日攻击" class="headerlink" title="第二类生日攻击"></a>第二类生日攻击</h3><p>寻找函数H的具有相同输出的两个任意输入的攻击方式。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>输出长度与碰撞-&gt;生日攻击给出了消息摘要长度的下界<br>通常建议消息摘要的最小可接受的长度为128比特</p><h2 id="SHA-1密码杂凑函数"><a href="#SHA-1密码杂凑函数" class="headerlink" title="SHA-1密码杂凑函数"></a>SHA-1密码杂凑函数</h2><h3 id="MD5哈希算法"><a href="#MD5哈希算法" class="headerlink" title="MD5哈希算法"></a>MD5哈希算法</h3><p>输入：任意长的消息（图中为K比特）<br>分组：512比特<br>输出：128比特的消息摘要。</p><h3 id="安全杂凑算法SHA-1"><a href="#安全杂凑算法SHA-1" class="headerlink" title="安全杂凑算法SHA-1"></a>安全杂凑算法SHA-1</h3><p>安全哈希算法(Secure Hash Algorithm, SHA)<br>输入：小于264比特长的任意消息，分为512比特长的分组。<br>输出：160比特长的消息摘要<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232331991.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232331991.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616175152"></p><h4 id="算法处理步骤"><a href="#算法处理步骤" class="headerlink" title="算法处理步骤"></a>算法处理步骤</h4><h5 id="1-消息填充"><a href="#1-消息填充" class="headerlink" title="1)消息填充"></a>1)消息填充</h5><p>对消息填充，使得其比特长在模512下为448，即填充后消息的长度为 512的某一倍数减64，留出的64比特备用（￥）<br>该步骤是必须的<br>填充方式：第1位为1，其后各位皆为0</p><h5 id="2-附加消息的长度"><a href="#2-附加消息的长度" class="headerlink" title="2)附加消息的长度"></a>2)附加消息的长度</h5><p>留出的64比特（￥）来表示消息被填充前的长度</p><h5 id="3-对MD缓冲区初始化"><a href="#3-对MD缓冲区初始化" class="headerlink" title="3)对MD缓冲区初始化"></a>3)对MD缓冲区初始化</h5><p>使用160比特长的缓冲区存储中间结果和最终杂凑值<br>缓冲区为5个32比特以big-endian方式存储数据的寄存器(A, B, C, D, E)<br>分别为A&#x3D;67452301， B&#x3D;EFCDAB89， C&#x3D;98BADCFB， D&#x3D;10325476， E&#x3D;C3D2E1F0。</p><h5 id="4-以分组为单位对消息进行处理（复杂）"><a href="#4-以分组为单位对消息进行处理（复杂）" class="headerlink" title="4)以分组为单位对消息进行处理（复杂）"></a>4)以分组为单位对消息进行处理（复杂）</h5><p>每一分组Yq都经一压缩函数处理，<strong>压缩函数</strong>由4轮处理 过程构成，每一轮又由20步迭代组成。<br>第4轮的输出（即第80步迭代的输出）再与第1轮的输 入CV.q相加，以产生CV.(q+1)，其中加法是缓冲区5个字中的 每一个字与CV.q中相应的字模2^(32)相加。<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232331443.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232331443.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230616235416"></p><h5 id="5-输出消息"><a href="#5-输出消息" class="headerlink" title="5)输出消息"></a>5)输出消息</h5><p>输出消息的L个分组都被处理完后，最后 一个分组的输出即为160比特的消息摘要。</p><h4 id="压缩函数"><a href="#压缩函数" class="headerlink" title="压缩函数"></a>压缩函数</h4><p>SHA的压缩函数由4轮处理过程组成，每轮处理过程20步迭代运算组成<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232332511.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232332511.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230617001018"><br>公式解释：<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232332806.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232332806.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230617001833"><br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232332823.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232332823.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230617002014"></p><ul><li><p>字W.t的产生<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232332515.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232332515.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230617002113"></p></li><li><p>常量字Kt<br>Kt &#x3D; 0x5A827999 (0 &lt;&#x3D; t &lt;&#x3D; 19)<br>Kt &#x3D; 0x6ED9EBA1 (20 &lt;&#x3D; t &lt;&#x3D; 39)<br>Kt &#x3D; 0x8F1BBCDC (40 &lt;&#x3D; t &lt;&#x3D; 59)<br>Kt &#x3D; 0xCA62C1D6 (60 &lt;&#x3D; t &lt;&#x3D; 79).</p></li></ul><h3 id="SHA系列Hash函数"><a href="#SHA系列Hash函数" class="headerlink" title="SHA系列Hash函数"></a>SHA系列Hash函数</h3><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232332721.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232332721.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230617002229"></p><h3 id="SM3密码杂凑函数"><a href="#SM3密码杂凑函数" class="headerlink" title="SM3密码杂凑函数"></a>SM3密码杂凑函数</h3><p>输入：输入：小于264比特长的任意消息<br>输出：哈希值长度为256比特</p><h4 id="常量和函数"><a href="#常量和函数" class="headerlink" title="常量和函数"></a>常量和函数</h4><p>IV、T.j为常量<br>FF.j、GG.j如下<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232332060.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232332060.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230617005202"><br>P.0(X)、P.1(X)如下<br><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232332938.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232332938.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230617005414"></p><h4 id="1-数据填充"><a href="#1-数据填充" class="headerlink" title="1)数据填充"></a>1)数据填充</h4><p>目的是使填充后的数据长度为512的整数倍<br>消息 的长度为l比特-&gt;<br>首先将比特“1”添加到m的末尾，再添加k 个“0”，其中k满足l+1+k&#x3D;448 mod 512<br>然后再添加一个64位比特串，该比特串是长度l的二进制表示</p><h4 id="2-迭代压缩"><a href="#2-迭代压缩" class="headerlink" title="2)迭代压缩"></a>2)迭代压缩</h4><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232333761.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232333761.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230617010111"></p><h4 id="3-消息扩展"><a href="#3-消息扩展" class="headerlink" title="3)消息扩展"></a>3)消息扩展</h4><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232333070.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232333070.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230617010251"></p><h4 id="gt-压缩函数"><a href="#gt-压缩函数" class="headerlink" title="-&gt;压缩函数"></a>-&gt;压缩函数</h4><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232333655.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232333655.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230617011430"></p><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232333310.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232333310.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230617011527"></p><h4 id="5-输出哈希值"><a href="#5-输出哈希值" class="headerlink" title="5)输出哈希值"></a>5)输出哈希值</h4><p>输出256比特的哈希值y&#x3D;ABCDEFGH</p><p><img src="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232333079.png" class="lazyload" data-srcset="https://iulliusimg.oss-cn-shenzhen.aliyuncs.com/blogImg/202309232333079.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pasted image 20230617011655"></p><h4 id="SM3哈希算法的安全性"><a href="#SM3哈希算法的安全性" class="headerlink" title="SM3哈希算法的安全性"></a>SM3哈希算法的安全性</h4><ul><li>FF.j(X,Y,Z)和GG.j(X,Y,Z)是非线性函数，经过循环迭代后提供混淆作用</li><li>置换函数P.0(X)和P.1(X)是线性函数，经过循环迭代后提供扩散作用</li></ul><h3 id="SHA3密码杂凑函数"><a href="#SHA3密码杂凑函数" class="headerlink" title="SHA3密码杂凑函数"></a>SHA3密码杂凑函数</h3><h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><p>采用了一种被称为<strong>海绵结构</strong>（海绵函数）的新的迭代结构<br>海绵函数允许输入长度和输出长度都可变<br>在海绵函数中，输入数据被分为固定长度的数据分组。每个分组逐次作为迭代的输入，同时上轮迭代的输出也反馈至下轮的迭代中，最终产生HASH码</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>安全性<br>可以抵御对Hash函数的现有攻击。<br>到目前为止，没有发现它有严重的安全弱点。</li><li>灵活性<br>可选参数配置，能够适应Hash函数的各种应用。</li><li>高效性<br>设计简单，软硬件实现方便。在效率方面，它是高效的。<br>尚未广泛应用，需要经过实践检验！</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章-引言&quot;&gt;&lt;a href=&quot;#第一章-引言&quot; class=&quot;headerlink&quot; title=&quot;第一章 引言&quot;&gt;&lt;/a&gt;第一章 引言&lt;/h1&gt;&lt;h2 id=&quot;信息安全基本属性&quot;&gt;&lt;a href=&quot;#信息安全基本属性&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="笔记" scheme="https://kievvv.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Cryptography" scheme="https://kievvv.github.io/tags/Cryptography/"/>
    
  </entry>
  
  <entry>
    <title>Hello World：建站日志</title>
    <link href="https://kievvv.github.io/2023/07/06/001HelloWorldLog/"/>
    <id>https://kievvv.github.io/2023/07/06/001HelloWorldLog/</id>
    <published>2023-07-06T13:36:56.025Z</published>
    <updated>2024-01-04T16:30:53.358Z</updated>
    
    <content type="html"><![CDATA[<p>2023.7.6  21:38<br>First Blog!</p><hr><p>2023.7.18</p><p>更新主题：</p><p><a href="https://github.com/volantis-x/hexo-theme-volantis">volantis</a></p><hr><p>2023.7.19</p><p>小细节更新：</p><p>新增评论系统、启用滚动封面等</p><p>（图片文件过大导致加载较慢..</p><hr><p>2023.7.25</p><p>绑定域名：<a href="http://iullius.com/">iullius.com</a></p><p>欢迎常来！</p><hr><p>2024.1.5</p><p>评论功能现在已经可以正常使用</p><p>需要以github账号登录，发表你的评论或给我留下表情。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2023.7.6  21:38&lt;br&gt;First Blog!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2023.7.18&lt;/p&gt;
&lt;p&gt;更新主题：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/volantis-x/hexo-theme-volantis&quot;&gt;vola</summary>
      
    
    
    
    <category term="杂谈" scheme="https://kievvv.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="HelloWorld" scheme="https://kievvv.github.io/tags/HelloWorld/"/>
    
  </entry>
  
</feed>
